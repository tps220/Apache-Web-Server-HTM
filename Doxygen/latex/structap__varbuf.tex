\hypertarget{structap__varbuf}{}\section{ap\+\_\+varbuf Struct Reference}
\label{structap__varbuf}\index{ap\+\_\+varbuf@{ap\+\_\+varbuf}}


{\ttfamily \#include $<$util\+\_\+varbuf.\+h$>$}



Collaboration diagram for ap\+\_\+varbuf\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{structap__varbuf__coll__graph}
\end{center}
\end{figure}
\subsection*{Data Fields}
\begin{DoxyCompactItemize}
\item 
char $\ast$ \hyperlink{structap__varbuf_a7877daf6c339eac8308a117fe0fcc112}{buf}
\item 
\hyperlink{group__apr__platform_gaaa72b2253f6f3032cefea5712a27540e}{apr\+\_\+size\+\_\+t} \hyperlink{structap__varbuf_a2a13c995fb5f9c15c677ff03df0f1ceb}{avail}
\item 
\hyperlink{group__apr__platform_gaaa72b2253f6f3032cefea5712a27540e}{apr\+\_\+size\+\_\+t} \hyperlink{structap__varbuf_a2d592128ff738e2d4d0c5f2afb0d2f83}{strlen}
\item 
\hyperlink{structapr__pool__t}{apr\+\_\+pool\+\_\+t} $\ast$ \hyperlink{structap__varbuf_a194c9dfb9bd169672dc081d655b4626f}{pool}
\item 
struct \hyperlink{structap__varbuf__info}{ap\+\_\+varbuf\+\_\+info} $\ast$ \hyperlink{structap__varbuf_ae5363fe8061898625080f8a4558890c5}{info}
\end{DoxyCompactItemize}


\subsection{Detailed Description}
A resizable buffer. 

\subsection{Field Documentation}
\index{ap\+\_\+varbuf@{ap\+\_\+varbuf}!avail@{avail}}
\index{avail@{avail}!ap\+\_\+varbuf@{ap\+\_\+varbuf}}
\subsubsection[{\texorpdfstring{avail}{avail}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf apr\+\_\+size\+\_\+t} ap\+\_\+varbuf\+::avail}\hypertarget{structap__varbuf_a2a13c995fb5f9c15c677ff03df0f1ceb}{}\label{structap__varbuf_a2a13c995fb5f9c15c677ff03df0f1ceb}
Allocated size of the buffer (minus one for the final \textbackslash{}0); must only be changed using ap\+\_\+varbuf\+\_\+grow(). \index{ap\+\_\+varbuf@{ap\+\_\+varbuf}!buf@{buf}}
\index{buf@{buf}!ap\+\_\+varbuf@{ap\+\_\+varbuf}}
\subsubsection[{\texorpdfstring{buf}{buf}}]{\setlength{\rightskip}{0pt plus 5cm}char$\ast$ ap\+\_\+varbuf\+::buf}\hypertarget{structap__varbuf_a7877daf6c339eac8308a117fe0fcc112}{}\label{structap__varbuf_a7877daf6c339eac8308a117fe0fcc112}
The actual buffer; will point to a const \textquotesingle{}\textbackslash{}0\textquotesingle{} if avail == 0 and to memory of the same lifetime as the pool otherwise. \index{ap\+\_\+varbuf@{ap\+\_\+varbuf}!info@{info}}
\index{info@{info}!ap\+\_\+varbuf@{ap\+\_\+varbuf}}
\subsubsection[{\texorpdfstring{info}{info}}]{\setlength{\rightskip}{0pt plus 5cm}struct {\bf ap\+\_\+varbuf\+\_\+info}$\ast$ ap\+\_\+varbuf\+::info}\hypertarget{structap__varbuf_ae5363fe8061898625080f8a4558890c5}{}\label{structap__varbuf_ae5363fe8061898625080f8a4558890c5}
Opaque info for memory allocation. \index{ap\+\_\+varbuf@{ap\+\_\+varbuf}!pool@{pool}}
\index{pool@{pool}!ap\+\_\+varbuf@{ap\+\_\+varbuf}}
\subsubsection[{\texorpdfstring{pool}{pool}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf apr\+\_\+pool\+\_\+t}$\ast$ ap\+\_\+varbuf\+::pool}\hypertarget{structap__varbuf_a194c9dfb9bd169672dc081d655b4626f}{}\label{structap__varbuf_a194c9dfb9bd169672dc081d655b4626f}
The pool for memory allocations and for registering the cleanup; the buffer memory will be released when this pool is cleared. \index{ap\+\_\+varbuf@{ap\+\_\+varbuf}!strlen@{strlen}}
\index{strlen@{strlen}!ap\+\_\+varbuf@{ap\+\_\+varbuf}}
\subsubsection[{\texorpdfstring{strlen}{strlen}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf apr\+\_\+size\+\_\+t} ap\+\_\+varbuf\+::strlen}\hypertarget{structap__varbuf_a2d592128ff738e2d4d0c5f2afb0d2f83}{}\label{structap__varbuf_a2d592128ff738e2d4d0c5f2afb0d2f83}
Length of string in buffer, or A\+P\+\_\+\+V\+A\+R\+B\+U\+F\+\_\+\+U\+N\+K\+N\+O\+WN. This determines how much memory is copied by ap\+\_\+varbuf\+\_\+grow() and where ap\+\_\+varbuf\+\_\+strmemcat() will append to the buffer. 

The documentation for this struct was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
/usr/local/src/github/\+Codebase/httpd-\/2.\+4.\+29/include/\hyperlink{util__varbuf_8h}{util\+\_\+varbuf.\+h}\end{DoxyCompactItemize}
