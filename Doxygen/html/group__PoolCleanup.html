<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>My Project: Pool Cleanup Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Pool Cleanup Functions<div class="ingroups"><a class="el" href="group__APR.html">Apache Portability Runtime library</a> &raquo; <a class="el" href="group__apr__pools.html">Memory Pool Functions</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Pool Cleanup Functions:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__PoolCleanup.png" border="0" alt="" usemap="#group____PoolCleanup"/>
<map name="group____PoolCleanup" id="group____PoolCleanup">
<area shape="rect" id="node1" href="group__apr__pools.html" title="Memory Pool Functions" alt="" coords="5,5,165,32"/>
</map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga18235426bac93f23261221f9b3733bfd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PoolCleanup.html#ga18235426bac93f23261221f9b3733bfd">APR_DECLARE_NONSTD</a> (<a class="el" href="group__apr__errno.html#gaa5105fa83cc322f09382292db8b47593">apr_status_t</a>) apr_pool_cleanup_null(<a class="el" href="group__MOD__ISAPI.html#gacd6cdbf73df3d9eed42fa493d9b621a6">void</a> *<a class="el" href="structdata.html">data</a>)</td></tr>
<tr class="separator:ga18235426bac93f23261221f9b3733bfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga759cdc4d96e9faaa06ff1cc8ec7962f6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__MOD__ISAPI.html#gacd6cdbf73df3d9eed42fa493d9b621a6">void</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PoolCleanup.html#ga759cdc4d96e9faaa06ff1cc8ec7962f6">data</a></td></tr>
<tr class="separator:ga759cdc4d96e9faaa06ff1cc8ec7962f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga329cbf0c5d8e0c61c40f78cdf67d4471"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__MOD__ISAPI.html#gacd6cdbf73df3d9eed42fa493d9b621a6">void</a> <a class="el" href="group__apr__errno.html#gaa5105fa83cc322f09382292db8b47593">apr_status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PoolCleanup.html#ga329cbf0c5d8e0c61c40f78cdf67d4471">plain_cleanup</a> )(<a class="el" href="group__MOD__ISAPI.html#gacd6cdbf73df3d9eed42fa493d9b621a6">void</a> *)</td></tr>
<tr class="separator:ga329cbf0c5d8e0c61c40f78cdf67d4471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09accdea610fa869f6e853529fd584f1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__MOD__ISAPI.html#gacd6cdbf73df3d9eed42fa493d9b621a6">void</a> <a class="el" href="group__apr__errno.html#gaa5105fa83cc322f09382292db8b47593">apr_status_t</a>(*) <a class="el" href="group__apr__errno.html#gaa5105fa83cc322f09382292db8b47593">apr_status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PoolCleanup.html#ga09accdea610fa869f6e853529fd584f1">child_cleanup</a> )(<a class="el" href="group__MOD__ISAPI.html#gacd6cdbf73df3d9eed42fa493d9b621a6">void</a> *)) <a class="el" href="group__APR__Util__Bucket__Brigades.html#gae0af316ed59541b70389da41aaeef4b6">__attribute__</a>((nonnull(3</td></tr>
<tr class="separator:ga09accdea610fa869f6e853529fd584f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f8e9a6584250688c1f6d72252321b54"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__MOD__ISAPI.html#gacd6cdbf73df3d9eed42fa493d9b621a6">void</a> <a class="el" href="group__apr__errno.html#gaa5105fa83cc322f09382292db8b47593">apr_status_t</a>(*) <a class="el" href="group__apr__errno.html#gaa5105fa83cc322f09382292db8b47593">apr_status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PoolCleanup.html#ga8f8e9a6584250688c1f6d72252321b54">APR_DECLARE</a> )(<a class="el" href="group__MOD__ISAPI.html#gacd6cdbf73df3d9eed42fa493d9b621a6">void</a>) apr_pool_pre_cleanup_register(<a class="el" href="structapr__pool__t.html">apr_pool_t</a> *<a class="el" href="group__APACHE__CORE__MPM.html#ga5cd91701e5c167f2b1a38e70ab57817e">p</a></td></tr>
<tr class="separator:ga8f8e9a6584250688c1f6d72252321b54"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Cleanups are performed in the reverse order they were registered. That is: Last In, First Out. A cleanup function can safely allocate memory from the pool that is being cleaned up. It can also safely register additional cleanups which will be run LIFO, directly after the current cleanup terminates. Cleanups have to take caution in calling functions that create subpools. Subpools, created during cleanup will NOT automatically be cleaned up. In other words, cleanups are to clean up after themselves. </p>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga18235426bac93f23261221f9b3733bfd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">APR_DECLARE_NONSTD </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pcre_8txt.html#a42dfa4ff673c82d8efe7144098fbc198">int</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An empty cleanup function.</p>
<p>Passed to apr_pool_cleanup_register() when no cleanup is required.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to cleanup, will not be used by this function.</td></tr>
  </table>
  </dd>
</dl>
<p>Write a string to a file using a printf format. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fptr</td><td>The file to write to. </td></tr>
    <tr><td class="paramname">format</td><td>The format string </td></tr>
    <tr><td class="paramname">...</td><td>The values to substitute in the format string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes written</dd></dl>
<p>snprintf routine based on apr_vformatter. This means it understands the same extensions. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The buffer to write to </td></tr>
    <tr><td class="paramname">len</td><td>The size of the buffer </td></tr>
    <tr><td class="paramname">format</td><td>The format string </td></tr>
    <tr><td class="paramname">...</td><td>The arguments to use to fill out the format string.</td></tr>
  </table>
  </dd>
</dl>
<p>Iterate over a table running the provided function once for every element in the table. The varargs array must be a list of zero or more (char *) keys followed by a NULL pointer. If zero keys are given, the </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comp</td><td>function will be invoked for every element in the table. Otherwise, the function is invoked only for those elements matching the keys specified.</td></tr>
  </table>
  </dd>
</dl>
<p>If an invocation of the comp function returns zero, iteration will continue using the next specified key, if any.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comp</td><td>The function to run </td></tr>
    <tr><td class="paramname">rec</td><td>The data to pass as the first argument to the function </td></tr>
    <tr><td class="paramname">t</td><td>The table to iterate over </td></tr>
    <tr><td class="paramname">...</td><td>A varargs array of zero or more (char *) keys followed by NULL </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>FALSE if one of the <a class="el" href="group__apr__skiplist.html#ga4c81b1eebdb8efeefcadd27cb3fe1c31">comp()</a> iterations returned zero; TRUE if all iterations returned non-zero </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__apr__tables.html#gabac50c7b2bae5f8cef6245d1959f8b06">apr_table_do_callback_fn_t</a> </dd>
<dd>
apr_table_vdo </dd></dl>
<div class="fragment"><div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;{</div><div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;    <span class="keywordtype">int</span> cc;</div><div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;    va_list <a class="code" href="group__APR__Strings__Snprintf.html#ga21ecbc810cd93b85a818c96ca2f92f1a">ap</a>;</div><div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;    <span class="keywordtype">char</span> *<a class="code" href="group__APACHE__CORE__PROTO.html#ga17bc47ccf1b618ed082a4ff4f2cc7f7e">buf</a>;</div><div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;    <span class="keywordtype">int</span> <a class="code" href="group__APACHE__CORE__LOG.html#gab5a43233d60ef05c5b5bf5cba3d74468">len</a>;</div><div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;</div><div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;    buf = <a class="code" href="util__expr__parse_8c.html#a5faf6a2d99f50a4655dd390199a8db7b">malloc</a>(<a class="code" href="group__APACHE__CORE__DAEMON.html#ga0c9dd98f46b90b5bcd4cbf75e252d0da">HUGE_STRING_LEN</a>);</div><div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;    <span class="keywordflow">if</span> (buf == <a class="code" href="pcre_8txt.html#ad7f989d16aa8ca809a36bc392c07fba1">NULL</a>) {</div><div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;        <span class="keywordflow">return</span> 0;</div><div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;    }</div><div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;    va_start(ap, <a class="code" href="group__apr__file__io.html#ga34332e75afdd7ed8d280f2a09b4329ea">format</a>);</div><div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;    len = apr_vsnprintf(buf, <a class="code" href="group__APACHE__CORE__DAEMON.html#ga0c9dd98f46b90b5bcd4cbf75e252d0da">HUGE_STRING_LEN</a>, <a class="code" href="group__apr__file__io.html#ga34332e75afdd7ed8d280f2a09b4329ea">format</a>, ap);</div><div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;    cc = apr_file_puts(buf, fptr);</div><div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;    va_end(ap);</div><div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;    <a class="code" href="util__expr__parse_8c.html#af07d89f5ceaea0c7c8252cc41fd75f37">free</a>(buf);</div><div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;    <span class="keywordflow">return</span> (cc == <a class="code" href="group__apr__errno.html#ga9ee311b7bf1c691dc521d721339ee2a6">APR_SUCCESS</a>) ? len : -1;</div><div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;}</div><div class="ttc" id="group__APACHE__CORE__DAEMON_html_ga0c9dd98f46b90b5bcd4cbf75e252d0da"><div class="ttname"><a href="group__APACHE__CORE__DAEMON.html#ga0c9dd98f46b90b5bcd4cbf75e252d0da">HUGE_STRING_LEN</a></div><div class="ttdeci">#define HUGE_STRING_LEN</div><div class="ttdef"><b>Definition:</b> httpd.h:302</div></div>
<div class="ttc" id="group__APACHE__CORE__LOG_html_gab5a43233d60ef05c5b5bf5cba3d74468"><div class="ttname"><a href="group__APACHE__CORE__LOG.html#gab5a43233d60ef05c5b5bf5cba3d74468">len</a></div><div class="ttdeci">const char apr_size_t len</div><div class="ttdef"><b>Definition:</b> ap_regex.h:140</div></div>
<div class="ttc" id="group__apr__file__io_html_ga34332e75afdd7ed8d280f2a09b4329ea"><div class="ttname"><a href="group__apr__file__io.html#ga34332e75afdd7ed8d280f2a09b4329ea">format</a></div><div class="ttdeci">const char * format</div><div class="ttdef"><b>Definition:</b> apr_file_io.h:873</div></div>
<div class="ttc" id="group__APR__Strings__Snprintf_html_ga21ecbc810cd93b85a818c96ca2f92f1a"><div class="ttname"><a href="group__APR__Strings__Snprintf.html#ga21ecbc810cd93b85a818c96ca2f92f1a">ap</a></div><div class="ttdeci">provider ap</div><div class="ttdef"><b>Definition:</b> apache_probes.d:1</div></div>
<div class="ttc" id="util__expr__parse_8c_html_a5faf6a2d99f50a4655dd390199a8db7b"><div class="ttname"><a href="util__expr__parse_8c.html#a5faf6a2d99f50a4655dd390199a8db7b">malloc</a></div><div class="ttdeci">void * malloc(YYSIZE_T)</div></div>
<div class="ttc" id="pcre_8txt_html_ad7f989d16aa8ca809a36bc392c07fba1"><div class="ttname"><a href="pcre_8txt.html#ad7f989d16aa8ca809a36bc392c07fba1">NULL</a></div><div class="ttdeci">this is a typedef for a structure whose contents are not externally defined It is up to the caller to free the that it does not depend on memory the complete pcre data block is not fully because it may contain a copy of the tableptr argu which is an those that are compatible with but some others as well can also be set and unset from within the the contents of the options argument specifies their settings at the start of compilation and execution The and PCRE_NO_START_OPTIMIZE options can be set at the time of matching as well as at compile time If errptr is NULL</div><div class="ttdef"><b>Definition:</b> pcre.txt:2065</div></div>
<div class="ttc" id="group__APACHE__CORE__PROTO_html_ga17bc47ccf1b618ed082a4ff4f2cc7f7e"><div class="ttname"><a href="group__APACHE__CORE__PROTO.html#ga17bc47ccf1b618ed082a4ff4f2cc7f7e">buf</a></div><div class="ttdeci">int const char * buf</div><div class="ttdef"><b>Definition:</b> http_protocol.h:974</div></div>
<div class="ttc" id="util__expr__parse_8c_html_af07d89f5ceaea0c7c8252cc41fd75f37"><div class="ttname"><a href="util__expr__parse_8c.html#af07d89f5ceaea0c7c8252cc41fd75f37">free</a></div><div class="ttdeci">void free(void *)</div></div>
<div class="ttc" id="group__apr__errno_html_ga9ee311b7bf1c691dc521d721339ee2a6"><div class="ttname"><a href="group__apr__errno.html#ga9ee311b7bf1c691dc521d721339ee2a6">APR_SUCCESS</a></div><div class="ttdeci">#define APR_SUCCESS</div><div class="ttdef"><b>Definition:</b> apr_errno.h:225</div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__PoolCleanup_ga18235426bac93f23261221f9b3733bfd_cgraph.png" border="0" usemap="#group__PoolCleanup_ga18235426bac93f23261221f9b3733bfd_cgraph" alt=""/></div>
<map name="group__PoolCleanup_ga18235426bac93f23261221f9b3733bfd_cgraph" id="group__PoolCleanup_ga18235426bac93f23261221f9b3733bfd_cgraph">
<area shape="rect" id="node2" href="util__expr__parse_8c.html#a5faf6a2d99f50a4655dd390199a8db7b" title="malloc" alt="" coords="408,26,468,53"/>
<area shape="rect" id="node3" href="util__expr__parse_8c.html#af07d89f5ceaea0c7c8252cc41fd75f37" title="free" alt="" coords="277,26,321,53"/>
<area shape="rect" id="node4" href="group__apr__allocator.html#ga9cb19a118179bbd8625eacfec66a9ab8" title="APR_DECLARE" alt="" coords="239,77,360,103"/>
<area shape="rect" id="node5" href="group__MOD__ISAPI.html#gacd6cdbf73df3d9eed42fa493d9b621a6" title="void" alt="" coords="276,127,323,154"/>
<area shape="rect" id="node6" href="apr__cpystrn_8c.html#a4a00fc29b96a953fed9e0107a9c4548a" title="strcasecmp" alt="" coords="254,178,345,205"/>
</map>
</div>
</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="ga8f8e9a6584250688c1f6d72252321b54"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">APR_DECLARE</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register a function to be called when a pool is cleared or destroyed.</p>
<p>Unlike apr_pool_cleanup_register which registers a cleanup that is called AFTER all subpools are destroyed, this function registers a function that will be called before any of the subpools are destroyed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The pool to register the cleanup with </td></tr>
    <tr><td class="paramname">data</td><td>The data to pass to the cleanup function. </td></tr>
    <tr><td class="paramname">plain_cleanup</td><td>The function to call when the pool is cleared or destroyed</td></tr>
  </table>
  </dd>
</dl>
<p>Run the specified cleanup function immediately and unregister it.</p>
<p>The cleanup most recently registered with <em>p</em> having the same values of <em>data</em> and <em>cleanup</em> will be removed and <em>cleanup</em> will be called with <em>data</em> as the argument.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The pool to remove the cleanup from </td></tr>
    <tr><td class="paramname">data</td><td>The data to remove from cleanup </td></tr>
    <tr><td class="paramname">cleanup</td><td>The function to remove from cleanup</td></tr>
  </table>
  </dd>
</dl>
<p>Free a list of blocks of mem, giving them back to the allocator. The list is typically terminated by a memnode with its next field set to NULL. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td>The allocator to give the mem back to </td></tr>
    <tr><td class="paramname">memnode</td><td>The memory node to return</td></tr>
  </table>
  </dd>
</dl>
<p>Set the owner of the allocator </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td>The allocator to set the owner for </td></tr>
    <tr><td class="paramname">pool</td><td>The pool that is to own the allocator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Typically pool is the highest level pool using the allocator</dd></dl>
<p>Set the current threshold at which the allocator should start giving blocks back to the system. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td>The allocator to set the threshold on </td></tr>
    <tr><td class="paramname">size</td><td>The threshold. 0 == unlimited.</td></tr>
  </table>
  </dd>
</dl>
<p>Set a mutex for the allocator to use </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td>The allocator to set the mutex for </td></tr>
    <tr><td class="paramname">mutex</td><td>The mutex</td></tr>
  </table>
  </dd>
</dl>
<p>atomically add 'val' to an apr_uint32_t </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mem</td><td>pointer to the object </td></tr>
    <tr><td class="paramname">val</td><td>amount to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>old value pointed to by mem</dd></dl>
<p>atomically subtract 'val' from an apr_uint32_t </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mem</td><td>pointer to the object </td></tr>
    <tr><td class="paramname">val</td><td>amount to subtract</td></tr>
  </table>
  </dd>
</dl>
<p>atomically increment an apr_uint32_t by 1 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mem</td><td>pointer to the object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>old value pointed to by mem</dd></dl>
<p>atomically decrement an apr_uint32_t by 1 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mem</td><td>pointer to the atomic value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero if the value becomes zero on decrement, otherwise non-zero</dd></dl>
<p>compare an apr_uint32_t's value with 'cmp'. If they are the same swap the value with 'with' </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mem</td><td>pointer to the value </td></tr>
    <tr><td class="paramname">with</td><td>what to swap it with </td></tr>
    <tr><td class="paramname">cmp</td><td>the value to compare it to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the old value of *mem</dd></dl>
<p>exchange an apr_uint32_t's value with 'val'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mem</td><td>pointer to the value </td></tr>
    <tr><td class="paramname">val</td><td>what to swap it with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the old value of *mem</dd></dl>
<p>exchange a pair of pointer values </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mem</td><td>pointer to the pointer </td></tr>
    <tr><td class="paramname">with</td><td>what to swap it with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the old value of the pointer</dd></dl>
<p>Return <code>TRUE</code> iff <em>str</em> exactly matches any of the elements of <em>list</em>.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.6</dd></dl>
<p>Return the number of line breaks in <em>msg</em>, allowing any kind of newline termination (CR, LF, CRLF, or LFCR), even inconsistent.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.6.</dd></dl>
<p>Perform a case-insensitive comparison of two strings <em>atr1</em> and <em>atr2</em>, treating upper and lower case values of the 26 standard C/POSIX alphabetic characters as equivalent. Extended latin characters outside of this set are treated as unique octets, irrespective of the current locale.</p>
<p>Returns in integer greater than, equal to, or less than 0, according to whether <em>str1</em> is considered greater than, equal to, or less than <em>str2</em>.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.6.</dd></dl>
<p>Parse the C string <em>str</em> into a 64 bit number, and return it in <em>*n</em>. Assume that the number is represented in base <em>base</em>. Raise an error if conversion fails (e.g. due to overflow), or if the converted number is smaller than <em>minval</em> or larger than <em>maxval</em>.</p>
<p>Leading whitespace in <em>str</em> is skipped in a locale-dependent way. After that, the string may contain an optional '+' (positive, default) or '-' (negative) character, followed by an optional '0x' prefix if <em>base</em> is 0 or 16, followed by numeric digits appropriate for the base. If there are any more characters after the numeric digits, an error is returned.</p>
<p>If <em>base</em> is zero, then a leading '0x' or '0X' prefix means hexadecimal, else a leading '0' means octal (implemented, though not documented, in apr_strtoi64() in APR 0.9.0 through 1.5.0), else use base ten.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.6.</dd></dl>
<p>Parse the C string <em>str</em> into a 64 bit number, and return it in <em>*n</em>. Assume that the number is represented in base 10. Raise an error if conversion fails (e.g. due to overflow).</p>
<p>The behaviour otherwise is as described for apr_cstr_strtoi64().</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.6.</dd></dl>
<p>Parse the C string <em>str</em> into a 32 bit number, and return it in <em>*n</em>. Assume that the number is represented in base 10. Raise an error if conversion fails (e.g. due to overflow).</p>
<p>The behaviour otherwise is as described for apr_cstr_strtoi64().</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.6.</dd></dl>
<p>Parse the C string <em>str</em> into an unsigned 64 bit number, and return it in <em>*n</em>. Assume that the number is represented in base <em>base</em>. Raise an error if conversion fails (e.g. due to overflow), or if the converted number is smaller than <em>minval</em> or larger than <em>maxval</em>.</p>
<p>Leading whitespace in <em>str</em> is skipped in a locale-dependent way. After that, the string may contain an optional '+' (positive, default) or '-' (negative) character, followed by an optional '0x' prefix if <em>base</em> is 0 or 16, followed by numeric digits appropriate for the base. If there are any more characters after the numeric digits, an error is returned.</p>
<p>If <em>base</em> is zero, then a leading '0x' or '0X' prefix means hexadecimal, else a leading '0' means octal (as implemented, though not documented, in apr_strtoi64(), else use base ten.</p>
<dl class="section warning"><dt>Warning</dt><dd>The implementation returns APR_ERANGE if the parsed number is greater than APR_INT64_MAX, even if it is not greater than <em>maxval</em>.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>New in 1.6.</dd></dl>
<p>Parse the C string <em>str</em> into an unsigned 64 bit number, and return it in <em>*n</em>. Assume that the number is represented in base 10. Raise an error if conversion fails (e.g. due to overflow).</p>
<p>The behaviour otherwise is as described for apr_cstr_strtoui64(), including the upper limit of APR_INT64_MAX.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.6.</dd></dl>
<p>Parse the C string <em>str</em> into an unsigned 32 bit number, and return it in <em>*n</em>. Assume that the number is represented in base 10. Raise an error if conversion fails (e.g. due to overflow).</p>
<p>The behaviour otherwise is as described for apr_cstr_strtoui64(), including the upper limit of APR_INT64_MAX.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.6.</dd></dl>
<p>Close a DSO library. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>handle to close.</td></tr>
  </table>
  </dd>
</dl>
<p>Load a symbol from a DSO handle. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ressym</td><td>Location to store the loaded symbol </td></tr>
    <tr><td class="paramname">handle</td><td>handle to load the symbol from. </td></tr>
    <tr><td class="paramname">symname</td><td>Name of the symbol to load.</td></tr>
  </table>
  </dd>
</dl>
<p>Set the value of an environment variable </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">envvar</td><td>the name of the environment variable </td></tr>
    <tr><td class="paramname">value</td><td>the value to set </td></tr>
    <tr><td class="paramname">pool</td><td>where to allocate temporary storage from</td></tr>
  </table>
  </dd>
</dl>
<p>Delete a variable from the environment </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">envvar</td><td>the name of the environment variable </td></tr>
    <tr><td class="paramname">pool</td><td>where to allocate temporary storage from</td></tr>
  </table>
  </dd>
</dl>
<p>Unescapes a URL, leaving reserved characters intact. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">escaped</td><td>Optional buffer to write the encoded string, can be NULL </td></tr>
    <tr><td class="paramname">url</td><td>String to be unescaped </td></tr>
    <tr><td class="paramname">slen</td><td>The length of the original url, or APR_ESCAPE_STRING </td></tr>
    <tr><td class="paramname">forbid</td><td>Optional list of forbidden characters, in addition to 0x00 </td></tr>
    <tr><td class="paramname">reserved</td><td>Optional list of reserved characters that will be left unescaped </td></tr>
    <tr><td class="paramname">plus</td><td>If non zero, '+' is converted to ' ' as per application/x-www-form-urlencoded encoding </td></tr>
    <tr><td class="paramname">len</td><td>If set, the length of the escaped string will be returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>APR_SUCCESS on success, APR_NOTFOUND if no characters are decoded or the string is NULL, APR_EINVAL if a bad escape sequence is found, APR_BADCH if a character on the forbid list is found.</dd></dl>
<p>Unescapes a URL, leaving reserved characters intact, returning the result from a pool. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pool to allocate from </td></tr>
    <tr><td class="paramname">url</td><td>String to be unescaped in place </td></tr>
    <tr><td class="paramname">forbid</td><td>Optional list of forbidden characters, in addition to 0x00 </td></tr>
    <tr><td class="paramname">reserved</td><td>Optional list of reserved characters that will be left unescaped </td></tr>
    <tr><td class="paramname">plus</td><td>If non zero, '+' is converted to ' ' as per application/x-www-form-urlencoded encoding </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string allocated from the pool on success, the original string if no characters are decoded, or NULL if a bad escape sequence is found or if a character on the forbid list is found, or if the original string was NULL.</dd></dl>
<p>Escape a path segment, as defined in RFC1808. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">escaped</td><td>Optional buffer to write the encoded string, can be NULL </td></tr>
    <tr><td class="paramname">str</td><td>The original string </td></tr>
    <tr><td class="paramname">slen</td><td>The length of the original string, or APR_ESCAPE_STRING </td></tr>
    <tr><td class="paramname">len</td><td>If present, returns the length of the string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>APR_SUCCESS, or APR_NOTFOUND if no changes to the string were detected or the string was NULL</dd></dl>
<p>Escape a path segment, as defined in RFC1808, returning the result from a pool. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pool to allocate from </td></tr>
    <tr><td class="paramname">str</td><td>String to be escaped </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string allocated from the pool on success, the original string if no characters are encoded or the string is NULL.</dd></dl>
<p>Converts an OS path to a URL, in an OS dependent way, as defined in RFC1808. In all cases if a ':' occurs before the first '/' in the URL, the URL should be prefixed with "./" (or the ':' escaped). In the case of Unix, this means leaving '/' alone, but otherwise doing what escape_path_segment() does. For efficiency reasons, we don't use escape_path_segment(), which is provided for reference. Again, RFC 1808 is where this stuff is defined.</p>
<p>If partial is set, os_escape_path() assumes that the path will be appended to something with a '/' in it (and thus does not prefix "./"). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">escaped</td><td>Optional buffer to write the encoded string, can be NULL </td></tr>
    <tr><td class="paramname">path</td><td>The original string </td></tr>
    <tr><td class="paramname">slen</td><td>The length of the original string, or APR_ESCAPE_STRING </td></tr>
    <tr><td class="paramname">partial</td><td>If non zero, suppresses the prepending of "./" </td></tr>
    <tr><td class="paramname">len</td><td>If present, returns the length of the string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>APR_SUCCESS, or APR_NOTFOUND if no changes to the string were detected or if the string was NULL</dd></dl>
<p>Converts an OS path to a URL, in an OS dependent way, as defined in RFC1808, returning the result from a pool.</p>
<p>In all cases if a ':' occurs before the first '/' in the URL, the URL should be prefixed with "./" (or the ':' escaped). In the case of Unix, this means leaving '/' alone, but otherwise doing what escape_path_segment() does. For efficiency reasons, we don't use escape_path_segment(), which is provided for reference. Again, RFC 1808 is where this stuff is defined.</p>
<p>If partial is set, os_escape_path() assumes that the path will be appended to something with a '/' in it (and thus does not prefix "./"). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pool to allocate from </td></tr>
    <tr><td class="paramname">str</td><td>The original string </td></tr>
    <tr><td class="paramname">partial</td><td>If non zero, suppresses the prepending of "./" </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string allocated from the pool on success, the original string if no characters are encoded or if the string was NULL.</dd></dl>
<p>Urlencode a string, as defined in <a href="http://www.w3.org/TR/html401/interact/forms.html#h-17.13.4.1">http://www.w3.org/TR/html401/interact/forms.html#h-17.13.4.1</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">escaped</td><td>Optional buffer to write the encoded string, can be NULL </td></tr>
    <tr><td class="paramname">str</td><td>The original string </td></tr>
    <tr><td class="paramname">slen</td><td>The length of the original string, or APR_ESCAPE_STRING </td></tr>
    <tr><td class="paramname">len</td><td>If present, returns the length of the string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>APR_SUCCESS, or APR_NOTFOUND if no changes to the string were detected or if the stirng was NULL</dd></dl>
<p>Urlencode a string, as defined in <a href="http://www.w3.org/TR/html401/interact/forms.html#h-17.13.4.1,">http://www.w3.org/TR/html401/interact/forms.html#h-17.13.4.1,</a> returning the result from a pool. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pool to allocate from </td></tr>
    <tr><td class="paramname">str</td><td>String to be escaped </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string allocated from the pool on success, the original string if no characters are encoded or if the string was NULL.</dd></dl>
<p>Apply entity encoding to a string. Characters are replaced as follows: '&lt;' becomes '&lt;', '&gt;' becomes '&gt;', '&amp;' becomes '&amp;', the double quote becomes '&quot;" and the single quote becomes '''.</p>
<p>If toasc is not zero, any non ascii character will be encoded as '%#ddd;', where ddd is the decimal code of the character. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">escaped</td><td>Optional buffer to write the encoded string, can be NULL </td></tr>
    <tr><td class="paramname">str</td><td>The original string </td></tr>
    <tr><td class="paramname">slen</td><td>The length of the original string, or APR_ESCAPE_STRING </td></tr>
    <tr><td class="paramname">toasc</td><td>If non zero, encode non ascii characters </td></tr>
    <tr><td class="paramname">len</td><td>If present, returns the length of the string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>APR_SUCCESS, or APR_NOTFOUND if no changes to the string were detected or the string was NULL</dd></dl>
<p>Apply entity encoding to a string, returning the result from a pool. Characters are replaced as follows: '&lt;' becomes '&lt;', '&gt;' becomes '&gt;', '&amp;' becomes '&amp;', the double quote becomes '&quot;" and the single quote becomes '''. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pool to allocate from </td></tr>
    <tr><td class="paramname">str</td><td>The original string </td></tr>
    <tr><td class="paramname">toasc</td><td>If non zero, encode non ascii characters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string allocated from the pool on success, the original string if no characters are encoded or the string is NULL.</dd></dl>
<p>Decodes html entities or numeric character references in a string. If the string to be unescaped is syntactically incorrect, then the following fixups will be made: unknown entities will be left undecoded; references to unused numeric characters will be deleted. In particular, &amp;#00; will not be decoded, but will be deleted. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">unescaped</td><td>Optional buffer to write the encoded string, can be NULL </td></tr>
    <tr><td class="paramname">str</td><td>The original string </td></tr>
    <tr><td class="paramname">slen</td><td>The length of the original string, or APR_ESCAPE_STRING </td></tr>
    <tr><td class="paramname">len</td><td>If present, returns the length of the string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>APR_SUCCESS, or APR_NOTFOUND if no changes to the string were detected or the string was NULL</dd></dl>
<p>Decodes html entities or numeric character references in a string. If the string to be unescaped is syntactically incorrect, then the following fixups will be made: unknown entities will be left undecoded; references to unused numeric characters will be deleted. In particular, &amp;#00; will not be decoded, but will be deleted. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pool to allocate from </td></tr>
    <tr><td class="paramname">str</td><td>The original string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string allocated from the pool on success, the original string if no characters are encoded or the string is NULL.</dd></dl>
<p>Escape control characters in a string, as performed by the shell's 'echo' command. Characters are replaced as follows: \a alert (bell), \b backspace, \f form feed, \n new line, \r carriage return, \t horizontal tab, \v vertical tab, \ backslash.</p>
<p>Any non ascii character will be encoded as '\xHH', where HH is the hex code of the character.</p>
<p>If quote is not zero, the double quote character will also be escaped. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">escaped</td><td>Optional buffer to write the encoded string, can be NULL </td></tr>
    <tr><td class="paramname">str</td><td>The original string </td></tr>
    <tr><td class="paramname">slen</td><td>The length of the original string, or APR_ESCAPE_STRING </td></tr>
    <tr><td class="paramname">quote</td><td>If non zero, encode double quotes </td></tr>
    <tr><td class="paramname">len</td><td>If present, returns the length of the string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>APR_SUCCESS, or APR_NOTFOUND if no changes to the string were detected or the string was NULL</dd></dl>
<p>Escape control characters in a string, as performed by the shell's 'echo' command, and return the results from a pool. Characters are replaced as follows: \a alert (bell), \b backspace, \f form feed, \n new line, \r carriage return, \t horizontal tab, \v vertical tab, \ backslash.</p>
<p>Any non ascii character will be encoded as '\xHH', where HH is the hex code of the character.</p>
<p>If quote is not zero, the double quote character will also be escaped. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pool to allocate from </td></tr>
    <tr><td class="paramname">str</td><td>The original string </td></tr>
    <tr><td class="paramname">quote</td><td>If non zero, encode double quotes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string allocated from the pool on success, the original string if no characters are encoded or the string is NULL.</dd></dl>
<p>Convert binary data to a hex encoding. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The destination buffer, can be NULL </td></tr>
    <tr><td class="paramname">src</td><td>The original buffer </td></tr>
    <tr><td class="paramname">srclen</td><td>The length of the original buffer </td></tr>
    <tr><td class="paramname">colon</td><td>If not zero, insert colon characters between hex digits. </td></tr>
    <tr><td class="paramname">len</td><td>If present, returns the length of the string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>APR_SUCCESS, or APR_NOTFOUND if the string was NULL</dd></dl>
<p>Convert binary data to a hex encoding, and return the results from a pool. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pool to allocate from </td></tr>
    <tr><td class="paramname">src</td><td>The original buffer </td></tr>
    <tr><td class="paramname">slen</td><td>The length of the original buffer </td></tr>
    <tr><td class="paramname">colon</td><td>If not zero, insert colon characters between hex digits. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A zero padded buffer allocated from the pool on success, or NULL if src was NULL.</dd></dl>
<p>Convert hex encoded string to binary data. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The destination buffer, can be NULL </td></tr>
    <tr><td class="paramname">str</td><td>The original buffer </td></tr>
    <tr><td class="paramname">slen</td><td>The length of the original buffer </td></tr>
    <tr><td class="paramname">colon</td><td>If not zero, ignore colon characters between hex digits. </td></tr>
    <tr><td class="paramname">len</td><td>If present, returns the length of the string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>APR_SUCCESS, or APR_NOTFOUND if the string was NULL, or APR_BADCH if a non hex character is present.</dd></dl>
<p>Apply LDAP escaping to binary data. Characters from RFC4514 and RFC4515 are escaped with their hex equivalents. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The destination buffer, can be NULL </td></tr>
    <tr><td class="paramname">src</td><td>The original buffer </td></tr>
    <tr><td class="paramname">srclen</td><td>The length of the original buffer </td></tr>
    <tr><td class="paramname">flags</td><td>APR_ESCAPE_LDAP_DN for RFC4514, APR_ESCAPE_LDAP_FILTER for RFC4515, APR_ESCAPE_LDAP_ALL for both </td></tr>
    <tr><td class="paramname">len</td><td>If present, returns the length of the string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>APR_SUCCESS, or APR_NOTFOUND if the string was NULL</dd></dl>
<p>Apply LDAP escaping to binary data, and return the results from a pool. Characters from RFC4514 and RFC4515 are escaped with their hex equivalents. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pool to allocate from </td></tr>
    <tr><td class="paramname">src</td><td>The original buffer </td></tr>
    <tr><td class="paramname">slen</td><td>The length of the original buffer </td></tr>
    <tr><td class="paramname">flags</td><td>APR_ESCAPE_LDAP_DN for RFC4514, APR_ESCAPE_LDAP_FILTER for RFC4515, APR_ESCAPE_LDAP_ALL for both </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A zero padded buffer allocated from the pool on success, or NULL if src was NULL.</dd></dl>
<p>Open the specified directory. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_dir</td><td>The opened directory descriptor. </td></tr>
    <tr><td class="paramname">dirname</td><td>The full path to the directory (use / on all systems) </td></tr>
    <tr><td class="paramname">pool</td><td>The pool to use.</td></tr>
  </table>
  </dd>
</dl>
<p>close the specified directory. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thedir</td><td>the directory descriptor to close.</td></tr>
  </table>
  </dd>
</dl>
<p>Read the next entry from the specified directory. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">finfo</td><td>the file info structure and filled in by apr_dir_read </td></tr>
    <tr><td class="paramname">wanted</td><td>The desired <a class="el" href="structapr__finfo__t.html">apr_finfo_t</a> fields, as a bit flag of APR_FINFO_ values </td></tr>
    <tr><td class="paramname">thedir</td><td>the directory descriptor returned from apr_dir_open </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>No ordering is guaranteed for the entries read.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If <code>APR_INCOMPLETE</code> is returned all the fields in <em>finfo</em> may not be filled in, and you need to check the <code>finfo-&gt;valid</code> bitmask to verify that what you're looking for is there. When no more entries are available, APR_ENOENT is returned.</dd></dl>
<p>Rewind the directory to the first entry. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thedir</td><td>the directory descriptor to rewind.</td></tr>
  </table>
  </dd>
</dl>
<p>Extract the rootpath from the given filepath </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rootpath</td><td>the root file path returned with APR_SUCCESS or APR_EINCOMPLETE </td></tr>
    <tr><td class="paramname">filepath</td><td>the pathname to parse for its root component </td></tr>
    <tr><td class="paramname">flags</td><td>the desired rules to apply, from <pre>
     APR_FILEPATH_NATIVE    Use native path separators (e.g. '\' on Win32)
     APR_FILEPATH_TRUENAME  Tests that the root exists, and makes it proper
</pre> </td></tr>
    <tr><td class="paramname">p</td><td>the pool to allocate the new path string from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>on return, filepath points to the first non-root character in the given filepath. In the simplest example, given a filepath of "/foo", returns the rootpath of "/" and filepath points at "foo". This is far more complex on other platforms, which will canonicalize the root form to a consistant format, given the APR_FILEPATH_TRUENAME flag, and also test for the validity of that root (e.g., that a drive d:/ or network share //machine/foovol/). The function returns APR_ERELATIVE if filepath isn't rooted (an error), APR_EINCOMPLETE if the root path is ambiguous (but potentially legitimate, e.g. "/" on Windows is incomplete because it doesn't specify the drive letter), or APR_EBADPATH if the root is simply invalid. APR_SUCCESS is returned if filepath is an absolute path.</dd></dl>
<p>Merge additional file path onto the previously processed rootpath </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newpath</td><td>the merged paths returned </td></tr>
    <tr><td class="paramname">rootpath</td><td>the root file path (NULL uses the current working path) </td></tr>
    <tr><td class="paramname">addpath</td><td>the path to add to the root path </td></tr>
    <tr><td class="paramname">flags</td><td>the desired APR_FILEPATH_ rules to apply when merging </td></tr>
    <tr><td class="paramname">p</td><td>the pool to allocate the new path string from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>if the flag APR_FILEPATH_TRUENAME is given, and the addpath contains wildcard characters ('*', '?') on platforms that don't support such characters within filenames, the paths will be merged, but the result code will be APR_EPATHWILD, and all further segments will not reflect the true filenames including the wildcard and following segments.</dd></dl>
<p>Split a search path into separate components </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pathelts</td><td>the returned components of the search path </td></tr>
    <tr><td class="paramname">liststr</td><td>the search path (e.g., <code>getenv("PATH")</code>) </td></tr>
    <tr><td class="paramname">p</td><td>the pool to allocate the array and path components from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>empty path components do not become part of <em>pathelts</em>. </dd>
<dd>
the path separator in <em>liststr</em> is system specific; e.g., ':' on Unix, ';' on Windows, etc.</dd></dl>
<p>Merge a list of search path components into a single search path </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">liststr</td><td>the returned search path; may be NULL if <em>pathelts</em> is empty </td></tr>
    <tr><td class="paramname">pathelts</td><td>the components of the search path </td></tr>
    <tr><td class="paramname">p</td><td>the pool to allocate the search path from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>emtpy strings in the source array are ignored. </dd>
<dd>
the path separator in <em>liststr</em> is system specific; e.g., ':' on Unix, ';' on Windows, etc.</dd></dl>
<p>Return the default file path (for relative file names) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>the default path string returned </td></tr>
    <tr><td class="paramname">flags</td><td>optional flag APR_FILEPATH_NATIVE to retrieve the default file path in os-native format. </td></tr>
    <tr><td class="paramname">p</td><td>the pool to allocate the default path string from</td></tr>
  </table>
  </dd>
</dl>
<p>Set the default file path (for relative file names) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>the default path returned </td></tr>
    <tr><td class="paramname">p</td><td>the pool to allocate any working storage</td></tr>
  </table>
  </dd>
</dl>
<p>Determine the encoding used internally by the FilePath functions </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">style</td><td>points to a variable which receives the encoding style flag </td></tr>
    <tr><td class="paramname">p</td><td>the pool to allocate any working storage </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Use <code>apr_os_locale_encoding</code> and/or <code>apr_os_default_encoding</code> to get the name of the path encoding if it's not UTF-8.</dd></dl>
<p>Close the specified file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>The file descriptor to close.</td></tr>
  </table>
  </dd>
</dl>
<p>Delete the specified file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The full path to the file (using / on all systems) </td></tr>
    <tr><td class="paramname">pool</td><td>The pool to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the file is open, it won't be removed until all instances are closed.</dd></dl>
<p>Rename the specified file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from_path</td><td>The full path to the original file (using / on all systems) </td></tr>
    <tr><td class="paramname">to_path</td><td>The full path to the new file (using / on all systems) </td></tr>
    <tr><td class="paramname">pool</td><td>The pool to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>If a file exists at the new location, then it will be overwritten. Moving files or directories across devices may not be possible.</dd></dl>
<p>Create a hard link to the specified file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from_path</td><td>The full path to the original file (using / on all systems) </td></tr>
    <tr><td class="paramname">to_path</td><td>The full path to the new file (using / on all systems) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Both files must reside on the same device.</dd></dl>
<p>Copy the specified file to another file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from_path</td><td>The full path to the original file (using / on all systems) </td></tr>
    <tr><td class="paramname">to_path</td><td>The full path to the new file (using / on all systems) </td></tr>
    <tr><td class="paramname">perms</td><td>Access permissions for the new file if it is created. In place of the usual or'd combination of file permissions, the value <a class="el" href="group__apr__file__permissions.html#gac08d4e868c7c9532f7c97c70556663dc">APR_FPROT_FILE_SOURCE_PERMS</a> may be given, in which case the source file's permissions are copied. </td></tr>
    <tr><td class="paramname">pool</td><td>The pool to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The new file does not need to exist, it will be created if required. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If the new file already exists, its contents will be overwritten.</dd></dl>
<p>Append the specified file to another file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from_path</td><td>The full path to the source file (use / on all systems) </td></tr>
    <tr><td class="paramname">to_path</td><td>The full path to the destination file (use / on all systems) </td></tr>
    <tr><td class="paramname">perms</td><td>Access permissions for the destination file if it is created. In place of the usual or'd combination of file permissions, the value <a class="el" href="group__apr__file__permissions.html#gac08d4e868c7c9532f7c97c70556663dc">APR_FPROT_FILE_SOURCE_PERMS</a> may be given, in which case the source file's permissions are copied. </td></tr>
    <tr><td class="paramname">pool</td><td>The pool to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The new file does not need to exist, it will be created if required. </dd>
<dd>
Note that advanced filesystem permissions such as ACLs are not duplicated by this API. The target permissions (including duplicating the source file permissions) are assigned only when the target file does not yet exist.</dd></dl>
<p>Are we at the end of the file </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fptr</td><td>The apr file we are testing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Returns <a class="el" href="group__APR__Error.html#ga35d9dca2514c522a2840aca0f3e2ebd3">APR_EOF</a> if we are at the end of file, <a class="el" href="group__apr__errno.html#ga9ee311b7bf1c691dc521d721339ee2a6">APR_SUCCESS</a> otherwise.</dd></dl>
<p>Open standard error as an apr file pointer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thefile</td><td>The apr file to use as stderr. </td></tr>
    <tr><td class="paramname">pool</td><td>The pool to allocate the file out of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The only reason that the apr_file_open_std* functions exist is that you may not always have a stderr/out/in on Windows. This is generally a problem with newer versions of Windows and services.</dd>
<dd>
The other problem is that the C library functions generally work differently on Windows and Unix. So, by using apr_file_open_std* functions, you can get a handle to an APR struct that works with the APR functions which are supposed to work identically on all platforms.</dd></dl>
<p>open standard output as an apr file pointer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thefile</td><td>The apr file to use as stdout. </td></tr>
    <tr><td class="paramname">pool</td><td>The pool to allocate the file out of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>See remarks for apr_file_open_stderr().</dd></dl>
<p>open standard input as an apr file pointer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thefile</td><td>The apr file to use as stdin. </td></tr>
    <tr><td class="paramname">pool</td><td>The pool to allocate the file out of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>See remarks for apr_file_open_stderr().</dd></dl>
<p>open standard error as an apr file pointer, with flags. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thefile</td><td>The apr file to use as stderr. </td></tr>
    <tr><td class="paramname">flags</td><td>The flags to open the file with. Only the <ul>
<li><a class="el" href="group__apr__file__open__flags.html#gabb7fb062cdf1d58faee8c7ea518496f1">APR_FOPEN_EXCL</a> </li>
<li><a class="el" href="group__apr__file__open__flags.html#gac48fd4c853c9f561632a2e8aaf5d8d97">APR_FOPEN_BUFFERED</a> </li>
<li><a class="el" href="group__apr__file__open__flags.html#ga435cd9b2604b11796779c23ffa00a3dd">APR_FOPEN_XTHREAD</a> </li>
<li><a class="el" href="group__apr__file__open__flags.html#ga426f6e2a8457ab410d99248269059a18">APR_FOPEN_SHARELOCK</a> </li>
<li><a class="el" href="group__apr__file__open__flags.html#ga60c21e28e4a612d58a874fe2cc71a6e4">APR_FOPEN_SENDFILE_ENABLED</a> </li>
<li><a class="el" href="group__apr__file__open__flags.html#gaf6cfaa4789e6264afd186235f0adbc22">APR_FOPEN_LARGEFILE</a></li>
</ul>
flags should be used. The <a class="el" href="group__apr__file__open__flags.html#gac598bb95fc9476b0bf2ed0b1c308842c">APR_FOPEN_WRITE</a> flag will be set unconditionally. </td></tr>
    <tr><td class="paramname">pool</td><td>The pool to allocate the file out of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>See remarks for apr_file_open_stderr().</dd></dl>
<p>open standard output as an apr file pointer, with flags. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thefile</td><td>The apr file to use as stdout. </td></tr>
    <tr><td class="paramname">flags</td><td>The flags to open the file with. Only the <ul>
<li><a class="el" href="group__apr__file__open__flags.html#gabb7fb062cdf1d58faee8c7ea518496f1">APR_FOPEN_EXCL</a> </li>
<li><a class="el" href="group__apr__file__open__flags.html#gac48fd4c853c9f561632a2e8aaf5d8d97">APR_FOPEN_BUFFERED</a> </li>
<li><a class="el" href="group__apr__file__open__flags.html#ga435cd9b2604b11796779c23ffa00a3dd">APR_FOPEN_XTHREAD</a> </li>
<li><a class="el" href="group__apr__file__open__flags.html#ga426f6e2a8457ab410d99248269059a18">APR_FOPEN_SHARELOCK</a> </li>
<li><a class="el" href="group__apr__file__open__flags.html#ga60c21e28e4a612d58a874fe2cc71a6e4">APR_FOPEN_SENDFILE_ENABLED</a> </li>
<li><a class="el" href="group__apr__file__open__flags.html#gaf6cfaa4789e6264afd186235f0adbc22">APR_FOPEN_LARGEFILE</a></li>
</ul>
flags should be used. The <a class="el" href="group__apr__file__open__flags.html#gac598bb95fc9476b0bf2ed0b1c308842c">APR_FOPEN_WRITE</a> flag will be set unconditionally. </td></tr>
    <tr><td class="paramname">pool</td><td>The pool to allocate the file out of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>See remarks for apr_file_open_stderr().</dd></dl>
<p>open standard input as an apr file pointer, with flags. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thefile</td><td>The apr file to use as stdin. </td></tr>
    <tr><td class="paramname">flags</td><td>The flags to open the file with. Only the <ul>
<li><a class="el" href="group__apr__file__open__flags.html#gabb7fb062cdf1d58faee8c7ea518496f1">APR_FOPEN_EXCL</a> </li>
<li><a class="el" href="group__apr__file__open__flags.html#gac48fd4c853c9f561632a2e8aaf5d8d97">APR_FOPEN_BUFFERED</a> </li>
<li><a class="el" href="group__apr__file__open__flags.html#ga435cd9b2604b11796779c23ffa00a3dd">APR_FOPEN_XTHREAD</a> </li>
<li><a class="el" href="group__apr__file__open__flags.html#ga426f6e2a8457ab410d99248269059a18">APR_FOPEN_SHARELOCK</a> </li>
<li><a class="el" href="group__apr__file__open__flags.html#ga60c21e28e4a612d58a874fe2cc71a6e4">APR_FOPEN_SENDFILE_ENABLED</a> </li>
<li><a class="el" href="group__apr__file__open__flags.html#gaf6cfaa4789e6264afd186235f0adbc22">APR_FOPEN_LARGEFILE</a></li>
</ul>
flags should be used. The <a class="el" href="group__apr__file__open__flags.html#gac598bb95fc9476b0bf2ed0b1c308842c">APR_FOPEN_WRITE</a> flag will be set unconditionally. </td></tr>
    <tr><td class="paramname">pool</td><td>The pool to allocate the file out of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>See remarks for apr_file_open_stderr().</dd></dl>
<p>Read data from the specified file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thefile</td><td>The file descriptor to read from. </td></tr>
    <tr><td class="paramname">buf</td><td>The buffer to store the data to. </td></tr>
    <tr><td class="paramname">nbytes</td><td>On entry, the number of bytes to read; on exit, the number of bytes read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>apr_file_read() will read up to the specified number of bytes, but never more. If there isn't enough data to fill that number of bytes, all of the available data is read. The third argument is modified to reflect the number of bytes read. If a char was put back into the stream via ungetc, it will be the first character returned.</dd>
<dd>
It is not possible for both bytes to be read and an <a class="el" href="group__APR__Error.html#ga35d9dca2514c522a2840aca0f3e2ebd3">APR_EOF</a> or other error to be returned. <a class="el" href="group__APR__Error.html#gaee1ce306c0ebf1701b34172310aa1bd5">APR_EINTR</a> is never returned.</dd></dl>
<p>Write data to the specified file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thefile</td><td>The file descriptor to write to. </td></tr>
    <tr><td class="paramname">buf</td><td>The buffer which contains the data. </td></tr>
    <tr><td class="paramname">nbytes</td><td>On entry, the number of bytes to write; on exit, the number of bytes written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>apr_file_write() will write up to the specified number of bytes, but never more. If the OS cannot write that many bytes, it will write as many as it can. The third argument is modified to reflect the * number of bytes written.</dd>
<dd>
It is possible for both bytes to be written and an error to be returned. <a class="el" href="group__APR__Error.html#gaee1ce306c0ebf1701b34172310aa1bd5">APR_EINTR</a> is never returned.</dd></dl>
<p>Write data from iovec array to the specified file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thefile</td><td>The file descriptor to write to. </td></tr>
    <tr><td class="paramname">vec</td><td>The array from which to get the data to write to the file. </td></tr>
    <tr><td class="paramname">nvec</td><td>The number of elements in the struct iovec array. This must be smaller than <a class="el" href="group__apr__file__writev.html#gae04a4721139b2b252ea20e68883da4b4">APR_MAX_IOVEC_SIZE</a>. If it isn't, the function will fail with <a class="el" href="group__APR__Error.html#gae3ffc41994444e71ce522c036ca1d9a4">APR_EINVAL</a>. </td></tr>
    <tr><td class="paramname">nbytes</td><td>The number of bytes written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>It is possible for both bytes to be written and an error to be returned. <a class="el" href="group__APR__Error.html#gaee1ce306c0ebf1701b34172310aa1bd5">APR_EINTR</a> is never returned.</dd>
<dd>
apr_file_writev() is available even if the underlying operating system doesn't provide <a class="el" href="apr__arch__os2calls_8h.html#a3d0f3996136a9b5ab46431c60c746efd">writev()</a>.</dd></dl>
<p>Read data from the specified file, ensuring that the buffer is filled before returning. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thefile</td><td>The file descriptor to read from. </td></tr>
    <tr><td class="paramname">buf</td><td>The buffer to store the data to. </td></tr>
    <tr><td class="paramname">nbytes</td><td>The number of bytes to read. </td></tr>
    <tr><td class="paramname">bytes_read</td><td>If non-NULL, this will contain the number of bytes read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>apr_file_read_full() will read up to the specified number of bytes, but never more. If there isn't enough data to fill that number of bytes, then the process/thread will block until it is available or EOF is reached. If a char was put back into the stream via ungetc, it will be the first character returned.</dd>
<dd>
It is possible for both bytes to be read and an error to be returned. And if *bytes_read is less than nbytes, an accompanying error is <em>always</em> returned.</dd>
<dd>
<a class="el" href="group__APR__Error.html#gaee1ce306c0ebf1701b34172310aa1bd5">APR_EINTR</a> is never returned.</dd></dl>
<p>Write data to the specified file, ensuring that all of the data is written before returning. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thefile</td><td>The file descriptor to write to. </td></tr>
    <tr><td class="paramname">buf</td><td>The buffer which contains the data. </td></tr>
    <tr><td class="paramname">nbytes</td><td>The number of bytes to write. </td></tr>
    <tr><td class="paramname">bytes_written</td><td>If non-NULL, set to the number of bytes written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>apr_file_write_full() will write up to the specified number of bytes, but never more. If the OS cannot write that many bytes, the process/thread will block until they can be written. Exceptional error such as "out of space" or "pipe closed" will terminate with an error.</dd>
<dd>
It is possible for both bytes to be written and an error to be returned. And if *bytes_written is less than nbytes, an accompanying error is <em>always</em> returned.</dd>
<dd>
<a class="el" href="group__APR__Error.html#gaee1ce306c0ebf1701b34172310aa1bd5">APR_EINTR</a> is never returned.</dd></dl>
<p>Write data from iovec array to the specified file, ensuring that all of the data is written before returning. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thefile</td><td>The file descriptor to write to. </td></tr>
    <tr><td class="paramname">vec</td><td>The array from which to get the data to write to the file. </td></tr>
    <tr><td class="paramname">nvec</td><td>The number of elements in the struct iovec array. This must be smaller than <a class="el" href="group__apr__file__writev.html#gae04a4721139b2b252ea20e68883da4b4">APR_MAX_IOVEC_SIZE</a>. If it isn't, the function will fail with <a class="el" href="group__APR__Error.html#gae3ffc41994444e71ce522c036ca1d9a4">APR_EINVAL</a>. </td></tr>
    <tr><td class="paramname">nbytes</td><td>The number of bytes written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>apr_file_writev_full() is available even if the underlying operating system doesn't provide <a class="el" href="apr__arch__os2calls_8h.html#a3d0f3996136a9b5ab46431c60c746efd">writev()</a>.</dd></dl>
<p>Write a character into the specified file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to write. </td></tr>
    <tr><td class="paramname">thefile</td><td>The file descriptor to write to</td></tr>
  </table>
  </dd>
</dl>
<p>Read a character from the specified file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to read into </td></tr>
    <tr><td class="paramname">thefile</td><td>The file descriptor to read from</td></tr>
  </table>
  </dd>
</dl>
<p>Put a character back onto a specified stream. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to write. </td></tr>
    <tr><td class="paramname">thefile</td><td>The file descriptor to write to</td></tr>
  </table>
  </dd>
</dl>
<p>Read a line from the specified file </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The buffer to store the string in. </td></tr>
    <tr><td class="paramname">len</td><td>The length of the string </td></tr>
    <tr><td class="paramname">thefile</td><td>The file descriptor to read from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The buffer will be NUL-terminated if any characters are stored. The newline at the end of the line will not be stripped.</dd></dl>
<p>Write the string into the specified file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to write. </td></tr>
    <tr><td class="paramname">thefile</td><td>The file descriptor to write to</td></tr>
  </table>
  </dd>
</dl>
<p>Flush the file's buffer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thefile</td><td>The file descriptor to flush</td></tr>
  </table>
  </dd>
</dl>
<p>Transfer all file modified data and metadata to disk. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thefile</td><td>The file descriptor to sync</td></tr>
  </table>
  </dd>
</dl>
<p>Transfer all file modified data to disk. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thefile</td><td>The file descriptor to sync</td></tr>
  </table>
  </dd>
</dl>
<p>Duplicate the specified file descriptor. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_file</td><td>The structure to duplicate into. </td></tr>
    <tr><td class="paramname">old_file</td><td>The file to duplicate. </td></tr>
    <tr><td class="paramname">p</td><td>The pool to use for the new file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>*new_file must point to a valid <a class="el" href="structapr__file__t.html">apr_file_t</a>, or point to NULL.</dd></dl>
<p>Duplicate the specified file descriptor and close the original </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_file</td><td>The old file that is to be closed and reused </td></tr>
    <tr><td class="paramname">old_file</td><td>The file to duplicate </td></tr>
    <tr><td class="paramname">p</td><td>The pool to use for the new file</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>new_file MUST point at a valid <a class="el" href="structapr__file__t.html">apr_file_t</a>. It cannot be NULL.</dd></dl>
<p>Move the specified file descriptor to a new pool </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_file</td><td>Pointer in which to return the new <a class="el" href="structapr__file__t.html">apr_file_t</a> </td></tr>
    <tr><td class="paramname">old_file</td><td>The file to move </td></tr>
    <tr><td class="paramname">p</td><td>The pool to which the descriptor is to be moved </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Unlike apr_file_dup2(), this function doesn't do an OS dup() operation on the underlying descriptor; it just moves the descriptor's <a class="el" href="structapr__file__t.html">apr_file_t</a> wrapper to a new pool. </dd>
<dd>
The new pool need not be an ancestor of old_file's pool. </dd>
<dd>
After calling this function, old_file may not be used</dd></dl>
<p>Give the specified apr file handle a new buffer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thefile</td><td>The file handle that is to be modified </td></tr>
    <tr><td class="paramname">buffer</td><td>The buffer </td></tr>
    <tr><td class="paramname">bufsize</td><td>The size of the buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>It is possible to add a buffer to previously unbuffered file handles, the <a class="el" href="group__apr__file__open__flags.html#gac48fd4c853c9f561632a2e8aaf5d8d97">APR_FOPEN_BUFFERED</a> flag will be added to the file handle's flags. Likewise, with buffer=NULL and bufsize=0 arguments it is possible to make a previously buffered file handle unbuffered.</dd></dl>
<p>Move the read/write file offset to a specified byte within a file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thefile</td><td>The file descriptor </td></tr>
    <tr><td class="paramname">where</td><td>How to move the pointer, one of: <ul>
<li><a class="el" href="group__apr__file__seek__flags.html#ga2fdf78845c897f69451d49e1e2b90ac9">APR_SET</a> &ndash; set the offset to offset </li>
<li><a class="el" href="group__apr__file__seek__flags.html#gae17abc53fea00bfd51e184017113e250">APR_CUR</a> &ndash; add the offset to the current position </li>
<li><a class="el" href="group__apr__file__seek__flags.html#ga438f3568be799d1e4bbd19492ca47d22">APR_END</a> &ndash; add the offset to the current file size </li>
</ul>
</td></tr>
    <tr><td class="paramname">offset</td><td>The offset to move the pointer to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The third argument is modified to be the offset the pointer was actually moved to.</dd></dl>
<p>Create an anonymous pipe. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The newly created pipe's file for reading. </td></tr>
    <tr><td class="paramname">out</td><td>The newly created pipe's file for writing. </td></tr>
    <tr><td class="paramname">pool</td><td>The pool to operate on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>By default, the returned file descriptors will be inherited by child processes created using apr_proc_create(). This can be changed using apr_file_inherit_unset(). </dd></dl>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000012">Bug:</a></b></dt><dd>Some platforms cannot toggle between blocking and nonblocking, and when passing a pipe as a standard handle to an application which does not expect it, a non-blocking stream will fluxor the client app. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000038">Deprecated:</a></b></dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd>apr_file_pipe_create_pools()</dd></dl>
<p>Create an anonymous pipe which portably supports async timeout options. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The newly created pipe's file for reading. </td></tr>
    <tr><td class="paramname">out</td><td>The newly created pipe's file for writing. </td></tr>
    <tr><td class="paramname">blocking</td><td>one of these values defined in apr_thread_proc.h; <ul>
<li><a class="el" href="group__apr__thread__proc.html#ga646af57314e71f4647243f36dd03e5ea">APR_FULL_BLOCK</a> </li>
<li><a class="el" href="group__apr__thread__proc.html#gaf8295548cb0821ee02249d6de8336bcb">APR_READ_BLOCK</a> </li>
<li><a class="el" href="group__apr__thread__proc.html#ga36ff2de9664ad6995bd488b4ac715c9c">APR_WRITE_BLOCK</a> </li>
<li><a class="el" href="group__apr__thread__proc.html#gae0707f76da785490830fc3491093767c">APR_FULL_NONBLOCK</a> </li>
</ul>
</td></tr>
    <tr><td class="paramname">pool</td><td>The pool to operate on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>By default, the returned file descriptors will be inherited by child processes created using apr_proc_create(). This can be changed using apr_file_inherit_unset(). </dd>
<dd>
Some platforms cannot toggle between blocking and nonblocking, and when passing a pipe as a standard handle to an application which does not expect it, a non-blocking stream will fluxor the client app. Use this function rather than apr_file_pipe_create() to create pipes where one or both ends require non-blocking semantics. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000039">Deprecated:</a></b></dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd>apr_file_pipe_create_pools()</dd></dl>
<p>Create an anonymous pipe which portably supports async timeout options, placing each side of the pipe in a different pool. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The newly created pipe's file for reading. </td></tr>
    <tr><td class="paramname">out</td><td>The newly created pipe's file for writing. </td></tr>
    <tr><td class="paramname">blocking</td><td>one of these values defined in apr_thread_proc.h; <ul>
<li><a class="el" href="group__apr__thread__proc.html#ga646af57314e71f4647243f36dd03e5ea">APR_FULL_BLOCK</a> </li>
<li><a class="el" href="group__apr__thread__proc.html#gaf8295548cb0821ee02249d6de8336bcb">APR_READ_BLOCK</a> </li>
<li><a class="el" href="group__apr__thread__proc.html#ga36ff2de9664ad6995bd488b4ac715c9c">APR_WRITE_BLOCK</a> </li>
<li><a class="el" href="group__apr__thread__proc.html#gae0707f76da785490830fc3491093767c">APR_FULL_NONBLOCK</a> </li>
</ul>
</td></tr>
    <tr><td class="paramname">pool_in</td><td>The pool for the reading pipe. </td></tr>
    <tr><td class="paramname">pool_out</td><td>The pool for the writing pipe. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>By default, the returned file descriptors will be inherited by child processes created using apr_proc_create(). This can be changed using apr_file_inherit_unset(). </dd>
<dd>
Some platforms cannot toggle between blocking and nonblocking, and when passing a pipe as a standard handle to an application which does not expect it, a non-blocking stream will fluxor the client app. Use this function rather than apr_file_pipe_create() to create pipes where one or both ends require non-blocking semantics.</dd></dl>
<p>Create a named pipe. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The filename of the named pipe </td></tr>
    <tr><td class="paramname">perm</td><td>The permissions for the newly created pipe. </td></tr>
    <tr><td class="paramname">pool</td><td>The pool to operate on.</td></tr>
  </table>
  </dd>
</dl>
<p>Get the timeout value for a pipe or manipulate the blocking state. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thepipe</td><td>The pipe we are getting a timeout for. </td></tr>
    <tr><td class="paramname">timeout</td><td>The current timeout value in microseconds.</td></tr>
  </table>
  </dd>
</dl>
<p>Set the timeout value for a pipe or manipulate the blocking state. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thepipe</td><td>The pipe we are setting a timeout on. </td></tr>
    <tr><td class="paramname">timeout</td><td>The timeout value in microseconds. Values &lt; 0 mean wait forever, 0 means do not wait at all.</td></tr>
  </table>
  </dd>
</dl>
<p>file (un)locking functions. Establish a lock on the specified, open file. The lock may be advisory or mandatory, at the discretion of the platform. The lock applies to the file as a whole, rather than a specific range. Locks are established on a per-thread/process basis; a second lock by the same thread will not block. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thefile</td><td>The file to lock. </td></tr>
    <tr><td class="paramname">type</td><td>The type of lock to establish on the file.</td></tr>
  </table>
  </dd>
</dl>
<p>Remove any outstanding locks on the file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thefile</td><td>The file to unlock.</td></tr>
  </table>
  </dd>
</dl>
<p>accessor and general file_io functions. return the file name of the current file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_path</td><td>The path of the file. </td></tr>
    <tr><td class="paramname">thefile</td><td>The currently open file.</td></tr>
  </table>
  </dd>
</dl>
<p>Return the data associated with the current file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The user data associated with the file. </td></tr>
    <tr><td class="paramname">key</td><td>The key to use for retrieving data associated with this file. </td></tr>
    <tr><td class="paramname">file</td><td>The currently open file.</td></tr>
  </table>
  </dd>
</dl>
<p>Set the data associated with the current file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>The currently open file. </td></tr>
    <tr><td class="paramname">data</td><td>The user data to associate with the file. </td></tr>
    <tr><td class="paramname">key</td><td>The key to use for associating data with the file. </td></tr>
    <tr><td class="paramname">cleanup</td><td>The cleanup routine to use when the file is destroyed.</td></tr>
  </table>
  </dd>
</dl>
<p>set the specified file's permission bits. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fname</td><td>The file (name) to apply the permissions to. </td></tr>
    <tr><td class="paramname">perms</td><td>The permission bits to apply to the file.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Some platforms may not be able to apply all of the available permission bits; <a class="el" href="group__APR__Error.html#ga64dff43b83bcefd3f3c751be6b864ca1">APR_INCOMPLETE</a> will be returned if some permissions are specified which could not be set.</dd>
<dd>
Platforms which do not implement this feature will return <a class="el" href="group__APR__Error.html#ga939ddb834a30bc9a5a0a329b13000161">APR_ENOTIMPL</a>.</dd></dl>
<p>Set attributes of the specified file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fname</td><td>The full path to the file (using / on all systems) </td></tr>
    <tr><td class="paramname">attributes</td><td>Or'd combination of <ul>
<li><a class="el" href="group__apr__file__attrs__set__flags.html#ga333f2c798495cfb95ee624e11c862e38">APR_FILE_ATTR_READONLY</a> - make the file readonly </li>
<li><a class="el" href="group__apr__file__attrs__set__flags.html#ga51346f433e354f0bc8722388b6b275fd">APR_FILE_ATTR_EXECUTABLE</a> - make the file executable </li>
<li><a class="el" href="group__apr__file__attrs__set__flags.html#ga68c188c0e56b9abdef3c97ffd913c5aa">APR_FILE_ATTR_HIDDEN</a> - make the file hidden </li>
</ul>
</td></tr>
    <tr><td class="paramname">attr_mask</td><td>Mask of valid bits in attributes. </td></tr>
    <tr><td class="paramname">pool</td><td>the pool to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function should be used in preference to explicit manipulation of the file permissions, because the operations to provide these attributes are platform specific and may involve more than simply setting permission bits. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Platforms which do not implement this feature will return <a class="el" href="group__APR__Error.html#ga939ddb834a30bc9a5a0a329b13000161">APR_ENOTIMPL</a>.</dd></dl>
<p>Set the mtime of the specified file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fname</td><td>The full path to the file (using / on all systems) </td></tr>
    <tr><td class="paramname">mtime</td><td>The mtime to apply to the file. </td></tr>
    <tr><td class="paramname">pool</td><td>The pool to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Platforms which do not implement this feature will return <a class="el" href="group__APR__Error.html#ga939ddb834a30bc9a5a0a329b13000161">APR_ENOTIMPL</a>.</dd></dl>
<p>Create a new directory on the file system. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>the path for the directory to be created. (use / on all systems) </td></tr>
    <tr><td class="paramname">perm</td><td>Permissions for the new directory. </td></tr>
    <tr><td class="paramname">pool</td><td>the pool to use.</td></tr>
  </table>
  </dd>
</dl>
<p>Creates a new directory on the file system, but behaves like 'mkdir -p'. Creates intermediate directories as required. No error will be reported if PATH already exists. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>the path for the directory to be created. (use / on all systems) </td></tr>
    <tr><td class="paramname">perm</td><td>Permissions for the new directory. </td></tr>
    <tr><td class="paramname">pool</td><td>the pool to use.</td></tr>
  </table>
  </dd>
</dl>
<p>Remove directory from the file system. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>the path for the directory to be removed. (use / on all systems) </td></tr>
    <tr><td class="paramname">pool</td><td>the pool to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Removing a directory which is in-use (e.g., the current working directory, or during apr_dir_read, or with an open file) is not portable.</dd></dl>
<p>get the specified file's stats. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">finfo</td><td>Where to store the information about the file. </td></tr>
    <tr><td class="paramname">wanted</td><td>The desired <a class="el" href="structapr__finfo__t.html">apr_finfo_t</a> fields, as a bit flag of APR_FINFO_* values </td></tr>
    <tr><td class="paramname">thefile</td><td>The file to get information about.</td></tr>
  </table>
  </dd>
</dl>
<p>Truncate the file's length to the specified offset </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fp</td><td>The file to truncate </td></tr>
    <tr><td class="paramname">offset</td><td>The offset to truncate to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The read/write file offset is repositioned to offset.</dd></dl>
<p>Retrieve the flags that were passed into apr_file_open() when the file was opened. </p><dl class="section return"><dt>Returns</dt><dd>apr_int32_t the flags</dd></dl>
<p>Open a temporary file </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fp</td><td>The apr file to use as a temporary file. </td></tr>
    <tr><td class="paramname">templ</td><td>The template to use when creating a temp file. </td></tr>
    <tr><td class="paramname">flags</td><td>The flags to open the file with. If this is zero, the file is opened with <a class="el" href="group__apr__file__open__flags.html#gafe94f21ccbf411172e70e7f473af251a">APR_FOPEN_CREATE</a> | <a class="el" href="group__apr__file__open__flags.html#gaf9e7303f028b130ff7d4b209d6662d7d">APR_FOPEN_READ</a> | <a class="el" href="group__apr__file__open__flags.html#gac598bb95fc9476b0bf2ed0b1c308842c">APR_FOPEN_WRITE</a> | <a class="el" href="group__apr__file__open__flags.html#gabb7fb062cdf1d58faee8c7ea518496f1">APR_FOPEN_EXCL</a> | <a class="el" href="group__apr__file__open__flags.html#ga5d3756f6d242c667ed1d3f54af4916eb">APR_FOPEN_DELONCLOSE</a> </td></tr>
    <tr><td class="paramname">p</td><td>The pool to allocate the file out of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function generates a unique temporary file name from template. The last six characters of template must be XXXXXX and these are replaced with a string that makes the filename unique. Since it will be modified, template must not be a string constant, but should be declared as a character array.</dd></dl>
<p>Find an existing directory suitable as a temporary storage location. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">temp_dir</td><td>The temp directory. </td></tr>
    <tr><td class="paramname">p</td><td>The pool to use for any necessary allocations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function uses an algorithm to search for a directory that an an application can use for temporary storage.</dd></dl>
<p>Determine if the given pattern is a regular expression. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>The pattern to search for glob characters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-zero if pattern has any glob characters in it</dd></dl>
<p>Find all files that match a specified pattern in a directory. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dir_pattern</td><td>The pattern to use for finding files, appended to the search directory. The pattern is anything following the final forward or backward slash in the parameter. If no slash is found, the current directory is searched. </td></tr>
    <tr><td class="paramname">result</td><td>Array to use when storing the results </td></tr>
    <tr><td class="paramname">p</td><td>The pool to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>APR_SUCCESS if no processing errors occurred, APR error code otherwise </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The returned array may be empty even if APR_SUCCESS was returned.</dd></dl>
<p>Set up an application with normalized argc, argv (and optionally env) in order to deal with platform-specific oddities, such as Win32 services, code pages and signals. This must be the first function called for any APR program. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">argc</td><td>Pointer to the argc that may be corrected </td></tr>
    <tr><td class="paramname">argv</td><td>Pointer to the argv that may be corrected </td></tr>
    <tr><td class="paramname">env</td><td>Pointer to the env that may be corrected, may be NULL </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>See apr_initialize if this is a library consumer of apr. Otherwise, this call is identical to apr_initialize, and must be closed with a call to apr_terminate at the end of program execution.</dd></dl>
<p>Generate random bytes. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Buffer to fill with random bytes </td></tr>
    <tr><td class="paramname">length</td><td>Length of buffer in bytes</td></tr>
  </table>
  </dd>
</dl>
<p>Parse the options initialized by apr_getopt_init(). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>The apr_opt_t structure returned by apr_getopt_init() </td></tr>
    <tr><td class="paramname">opts</td><td>A string of characters that are acceptable options to the program. Characters followed by ":" are required to have an option associated </td></tr>
    <tr><td class="paramname">option_ch</td><td>The next option character parsed </td></tr>
    <tr><td class="paramname">option_arg</td><td>The argument following the option character: </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>There are four potential status values on exit. They are: <pre>
            APR_EOF      &ndash;  No more options to parse
            APR_BADCH    &ndash;  Found a bad option character
            APR_BADARG   &ndash;  No argument followed the option flag
            APR_SUCCESS  &ndash;  The next option was found.
</pre></dd></dl>
<p>Parse the options initialized by apr_getopt_init(), accepting long options beginning with "--" in addition to single-character options beginning with "-". </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>The <a class="el" href="structapr__getopt__t.html">apr_getopt_t</a> structure created by apr_getopt_init() </td></tr>
    <tr><td class="paramname">opts</td><td>A pointer to a list of <a class="el" href="structapr__getopt__option__t.html">apr_getopt_option_t</a> structures, which can be initialized with { "name", optch, has_args }. has_args is nonzero if the option requires an argument. A structure with an optch value of 0 terminates the list. </td></tr>
    <tr><td class="paramname">option_ch</td><td>Receives the value of "optch" from the <a class="el" href="structapr__getopt__option__t.html">apr_getopt_option_t</a> structure corresponding to the next option matched. </td></tr>
    <tr><td class="paramname">option_arg</td><td>Receives the argument following the option, if any. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>There are four potential status values on exit. They are: <pre>
            APR_EOF      --  No more options to parse
            APR_BADCH    --  Found a bad option character
            APR_BADARG   --  No argument followed the option flag
            APR_SUCCESS  --  The next option was found.
</pre> When APR_SUCCESS is returned, os-&gt;ind gives the index of the first non-option argument. On error, a message will be printed to stdout unless os-&gt;err is set to 0. If os-&gt;interleave is set to nonzero, options can come after arguments, and os-&gt;argv will be permuted to leave non-option arguments at the end (the original argv is unaffected).</dd></dl>
<p>Re-open a mutex in a child process. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>The newly re-opened mutex structure. </td></tr>
    <tr><td class="paramname">fname</td><td>A file name to use if the mutex mechanism requires one. This argument should always be provided. The mutex code itself will determine if it should be used. This filename should be the same one that was passed to apr_global_mutex_create(). </td></tr>
    <tr><td class="paramname">pool</td><td>The pool to operate on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function must be called to maintain portability, even if the underlying lock mechanism does not require it.</dd></dl>
<p>Acquire the lock for the given mutex. If the mutex is already locked, the current thread will be put to sleep until the lock becomes available. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>the mutex on which to acquire the lock.</td></tr>
  </table>
  </dd>
</dl>
<p>Attempt to acquire the lock for the given mutex. If the mutex has already been acquired, the call returns immediately with APR_EBUSY. Note: it is important that the <a class="el" href="group__APR__STATUS__IS.html#gabb92ad7b6ef304132de70e9e5cbaa896">APR_STATUS_IS_EBUSY(s)</a> macro be used to determine if the return value was APR_EBUSY, for portability reasons. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>the mutex on which to attempt the lock acquiring.</td></tr>
  </table>
  </dd>
</dl>
<p>Release the lock for the given mutex. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>the mutex from which to release the lock.</td></tr>
  </table>
  </dd>
</dl>
<p>Destroy the mutex and free the memory associated with the lock. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>the mutex to destroy.</td></tr>
  </table>
  </dd>
</dl>
<p>Get the mechanism's name of the mutex, as it relates to the actual method used for the underlying <a class="el" href="structapr__proc__mutex__t.html">apr_proc_mutex_t</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>the mutex to get the mechanism's name from.</td></tr>
  </table>
  </dd>
</dl>
<p>Create a hash table with a custom hash function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td>The pool to allocate the hash table out of </td></tr>
    <tr><td class="paramname">hash_func</td><td>A custom hash function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The hash table just created</dd></dl>
<p>Make a copy of a hash table </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td>The pool from which to allocate the new hash table </td></tr>
    <tr><td class="paramname">h</td><td>The hash table to clone </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The hash table just created </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>Makes a shallow copy</dd></dl>
<p>Continue iterating over the entries in a hash table. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hi</td><td>The iteration state </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the updated iteration state. NULL if there are no more entries.</dd></dl>
<p>Get the current entry's details from the iteration state. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hi</td><td>The iteration state </td></tr>
    <tr><td class="paramname">key</td><td>Return pointer for the pointer to the key. </td></tr>
    <tr><td class="paramname">klen</td><td>Return pointer for the key length. </td></tr>
    <tr><td class="paramname">val</td><td>Return pointer for the associated value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The return pointers should point to a variable that will be set to the corresponding data, or they may be NULL if the data isn't interesting.</dd></dl>
<p>Get the current entry's value from the iteration state. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hi</td><td>The iteration state </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pointer to the value</dd></dl>
<p>Clear any key/value pairs in the hash table. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ht</td><td>The hash table</td></tr>
  </table>
  </dd>
</dl>
<p>Merge two hash tables into one new hash table. The values of the overlay hash override the values of the base if both have the same key. Both hash tables must use the same hash function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The pool to use for the new hash table </td></tr>
    <tr><td class="paramname">overlay</td><td>The table to add to the initial table </td></tr>
    <tr><td class="paramname">base</td><td>The table that represents the initial values of the new table </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new hash table containing all of the data from the two passed in</dd></dl>
<p>Merge two hash tables into one new hash table. If the same key is present in both tables, call the supplied merge function to produce a merged value for the key in the new table. Both hash tables must use the same hash function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The pool to use for the new hash table </td></tr>
    <tr><td class="paramname">h1</td><td>The first of the tables to merge </td></tr>
    <tr><td class="paramname">h2</td><td>The second of the tables to merge </td></tr>
    <tr><td class="paramname">merger</td><td>A callback function to merge values, or NULL to make values from h1 override values from h2 (same semantics as apr_hash_overlay()) </td></tr>
    <tr><td class="paramname">data</td><td>Client data to pass to the merger function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new hash table containing all of the data from the two passed in</dd></dl>
<p>Display a prompt and read in the password from stdin. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prompt</td><td>The prompt to display </td></tr>
    <tr><td class="paramname">pwbuf</td><td>Buffer to store the password </td></tr>
    <tr><td class="paramname">bufsize</td><td>The length of the password buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the password entered must be truncated to fit in the provided buffer, APR_ENAMETOOLONG will be returned. Note that the bufsize paramater is passed by reference for no reason; its value will never be modified by the apr_password_get() function.</dd></dl>
<p>Duplicate the specified MMAP. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_mmap</td><td>The structure to duplicate into. </td></tr>
    <tr><td class="paramname">old_mmap</td><td>The mmap to duplicate. </td></tr>
    <tr><td class="paramname">p</td><td>The pool to use for new_mmap.</td></tr>
  </table>
  </dd>
</dl>
<p>Remove a mmap'ed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mm</td><td>The mmap'ed file.</td></tr>
  </table>
  </dd>
</dl>
<p>Move the pointer into the mmap'ed file to the specified offset. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>The pointer to the offset specified. </td></tr>
    <tr><td class="paramname">mm</td><td>The mmap'ed file. </td></tr>
    <tr><td class="paramname">offset</td><td>The offset to move to.</td></tr>
  </table>
  </dd>
</dl>
<p>Shutdown either reading, writing, or both sides of a socket. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thesocket</td><td>The socket to close </td></tr>
    <tr><td class="paramname">how</td><td>How to shutdown the socket. One of: <pre>
           APR_SHUTDOWN_READ         no longer allow read requests
           APR_SHUTDOWN_WRITE        no longer allow write requests
           APR_SHUTDOWN_READWRITE    no longer allow read or write requests 
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__apr__network__io.html#gae2130f1fa2d0db58c5c3c9c73d9b4009">apr_shutdown_how_e</a> </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This does not actually close the socket descriptor, it just controls which calls are still valid on the socket.</dd></dl>
<p>Close a socket. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thesocket</td><td>The socket to close</td></tr>
  </table>
  </dd>
</dl>
<p>Bind the socket to its associated port </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket to bind </td></tr>
    <tr><td class="paramname">sa</td><td>The socket address to bind to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This may be where we will find out if there is any other process using the selected port.</dd></dl>
<p>Listen to a bound socket for connections. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket to listen on </td></tr>
    <tr><td class="paramname">backlog</td><td>The number of outstanding connections allowed in the sockets listen queue. If this value is less than zero, the listen queue size is set to zero.</td></tr>
  </table>
  </dd>
</dl>
<p>Accept a new connection request </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_sock</td><td>A copy of the socket that is connected to the socket that made the connection request. This is the socket which should be used for all future communication. </td></tr>
    <tr><td class="paramname">sock</td><td>The socket we are listening on. </td></tr>
    <tr><td class="paramname">connection_pool</td><td>The pool for the new socket. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The pool will be used by various functions that operate on the socket. The caller must ensure that it is not used by other threads at the same time.</dd></dl>
<p>Issue a connection request to a socket either on the same machine or a different one. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket we wish to use for our side of the connection </td></tr>
    <tr><td class="paramname">sa</td><td>The address of the machine we wish to connect to.</td></tr>
  </table>
  </dd>
</dl>
<p>Determine whether the receive part of the socket has been closed by the peer (such that a subsequent call to apr_socket_read would return APR_EOF), if the socket's receive buffer is empty. This function does not block waiting for I/O.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket to check </td></tr>
    <tr><td class="paramname">atreadeof</td><td>If APR_SUCCESS is returned, *atreadeof is set to non-zero if a subsequent read would return APR_EOF </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an error is returned if it was not possible to determine the status, in which case *atreadeof is not changed.</dd></dl>
<p>Create <a class="el" href="structapr__sockaddr__t.html">apr_sockaddr_t</a> from hostname, address family, and port. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sa</td><td>The new <a class="el" href="structapr__sockaddr__t.html">apr_sockaddr_t</a>. </td></tr>
    <tr><td class="paramname">hostname</td><td>The hostname or numeric address string to resolve/parse, or NULL to build an address that corresponds to 0.0.0.0 or :: or in case of APR_UNIX family it is absolute socket filename. </td></tr>
    <tr><td class="paramname">family</td><td>The address family to use, or APR_UNSPEC if the system should decide. </td></tr>
    <tr><td class="paramname">port</td><td>The port number. </td></tr>
    <tr><td class="paramname">flags</td><td>Special processing flags: <pre>
      APR_IPV4_ADDR_OK          first query for IPv4 addresses; only look
                                for IPv6 addresses if the first query failed;
                                only valid if family is APR_UNSPEC and hostname
                                isn't NULL; mutually exclusive with
                                APR_IPV6_ADDR_OK
      APR_IPV6_ADDR_OK          first query for IPv6 addresses; only look
                                for IPv4 addresses if the first query failed;
                                only valid if family is APR_UNSPEC and hostname
                                isn't NULL and APR_HAVE_IPV6; mutually exclusive
                                with APR_IPV4_ADDR_OK
</pre> </td></tr>
    <tr><td class="paramname">p</td><td>The pool for the <a class="el" href="structapr__sockaddr__t.html">apr_sockaddr_t</a> and associated storage.</td></tr>
  </table>
  </dd>
</dl>
<p>Copy <a class="el" href="structapr__sockaddr__t.html">apr_sockaddr_t</a> src to dst on pool p. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>The destination <a class="el" href="structapr__sockaddr__t.html">apr_sockaddr_t</a>. </td></tr>
    <tr><td class="paramname">src</td><td>The source <a class="el" href="structapr__sockaddr__t.html">apr_sockaddr_t</a>. </td></tr>
    <tr><td class="paramname">p</td><td>The pool for the <a class="el" href="structapr__sockaddr__t.html">apr_sockaddr_t</a> and associated storage.</td></tr>
  </table>
  </dd>
</dl>
<p>Look up the host name from an <a class="el" href="structapr__sockaddr__t.html">apr_sockaddr_t</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hostname</td><td>The hostname. </td></tr>
    <tr><td class="paramname">sa</td><td>The <a class="el" href="structapr__sockaddr__t.html">apr_sockaddr_t</a>. </td></tr>
    <tr><td class="paramname">flags</td><td>Special processing flags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Results can vary significantly between platforms when processing wildcard socket addresses.</dd></dl>
<p>Parse hostname/IP address with scope id and port.</p>
<p>Any of the following strings are accepted: 8080 (just the port number) www.apache.org (just the hostname) www.apache.org:8080 (hostname and port number)</p>
<p>[fe80::1eth0] (IPv6 numeric address string and scope id)</p>
<p>Invalid strings: (empty string) [abc] (not valid IPv6 numeric address string) abc:65536 (invalid port number)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>The new buffer containing just the hostname. On output, *addr will be NULL if no hostname/IP address was specfied. </td></tr>
    <tr><td class="paramname">scope_id</td><td>The new buffer containing just the scope id. On output, *scope_id will be NULL if no scope id was specified. </td></tr>
    <tr><td class="paramname">port</td><td>The port number. On output, *port will be 0 if no port was specified. <h3>FIXME: 0 is a legal port (per RFC 1700). this should</h3>
</td></tr>
  </table>
  </dd>
</dl>
<h3>return something besides zero if the port is missing.</h3>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The input string to be parsed. </td></tr>
    <tr><td class="paramname">p</td><td>The pool from which *addr and *scope_id are allocated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If scope id shouldn't be allowed, check for scope_id != NULL in addition to checking the return code. If addr/hostname should be required, check for addr == NULL in addition to checking the return code.</dd></dl>
<p>Get name of the current machine </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>A buffer to store the hostname in. </td></tr>
    <tr><td class="paramname">len</td><td>The maximum length of the hostname that can be stored in the buffer provided. The suggested length is APRMAXHOSTLEN + 1. </td></tr>
    <tr><td class="paramname">cont</td><td>The pool to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the buffer was not large enough, an error will be returned.</dd></dl>
<p>Return the data associated with the current socket </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The user data associated with the socket. </td></tr>
    <tr><td class="paramname">key</td><td>The key to associate with the user data. </td></tr>
    <tr><td class="paramname">sock</td><td>The currently open socket.</td></tr>
  </table>
  </dd>
</dl>
<p>Set the data associated with the current socket. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The currently open socket. </td></tr>
    <tr><td class="paramname">data</td><td>The user data to associate with the socket. </td></tr>
    <tr><td class="paramname">key</td><td>The key to associate with the data. </td></tr>
    <tr><td class="paramname">cleanup</td><td>The cleanup to call when the socket is destroyed.</td></tr>
  </table>
  </dd>
</dl>
<p>Send data over a network. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket to send the data over. </td></tr>
    <tr><td class="paramname">buf</td><td>The buffer which contains the data to be sent. </td></tr>
    <tr><td class="paramname">len</td><td>On entry, the number of bytes to send; on exit, the number of bytes sent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd><pre>
This functions acts like a blocking write by default.  To change 
this behavior, use <a class="el" href="unix_2sockopt_8c.html#a945bdbe807ec5635d65a6fd9ddb78c29">apr_socket_timeout_set()</a> or the APR_SO_NONBLOCK
socket option.</pre></dd></dl>
<p>It is possible for both bytes to be sent and an error to be returned.</p>
<pre>APR_EINTR is never returned.
</pre><p>Send multiple buffers over a network. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket to send the data over. </td></tr>
    <tr><td class="paramname">vec</td><td>The array of iovec structs containing the data to send </td></tr>
    <tr><td class="paramname">nvec</td><td>The number of iovec structs in the array </td></tr>
    <tr><td class="paramname">len</td><td>Receives the number of bytes actually written </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd><pre>
This functions acts like a blocking write by default.  To change 
this behavior, use <a class="el" href="unix_2sockopt_8c.html#a945bdbe807ec5635d65a6fd9ddb78c29">apr_socket_timeout_set()</a> or the APR_SO_NONBLOCK
socket option.
The number of bytes actually sent is stored in argument 4.</pre></dd></dl>
<p>It is possible for both bytes to be sent and an error to be returned.</p>
<pre>APR_EINTR is never returned.
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket to send from </td></tr>
    <tr><td class="paramname">where</td><td>The <a class="el" href="structapr__sockaddr__t.html">apr_sockaddr_t</a> describing where to send the data </td></tr>
    <tr><td class="paramname">flags</td><td>The flags to use </td></tr>
    <tr><td class="paramname">buf</td><td>The data to send </td></tr>
    <tr><td class="paramname">len</td><td>The length of the data to send</td></tr>
  </table>
  </dd>
</dl>
<p>Read data from a socket. On success, the address of the peer from which the data was sent is copied into the <em>from</em> parameter, and the <em>len</em> parameter is updated to give the number of bytes written to <em>buf</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>Updated with the address from which the data was received </td></tr>
    <tr><td class="paramname">sock</td><td>The socket to use </td></tr>
    <tr><td class="paramname">flags</td><td>The flags to use </td></tr>
    <tr><td class="paramname">buf</td><td>The buffer to use </td></tr>
    <tr><td class="paramname">len</td><td>The length of the available buffer</td></tr>
  </table>
  </dd>
</dl>
<p>Send a file from an open file descriptor to a socket, along with optional headers and trailers </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket to which we're writing </td></tr>
    <tr><td class="paramname">file</td><td>The open file from which to read </td></tr>
    <tr><td class="paramname">hdtr</td><td>A structure containing the headers and trailers to send </td></tr>
    <tr><td class="paramname">offset</td><td>Offset into the file where we should begin writing </td></tr>
    <tr><td class="paramname">len</td><td>(input) - Number of bytes to send from the file (output) - Number of bytes actually sent, including headers, file, and trailers </td></tr>
    <tr><td class="paramname">flags</td><td>APR flags that are mapped to OS specific flags </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This functions acts like a blocking write by default. To change this behavior, use <a class="el" href="unix_2sockopt_8c.html#a945bdbe807ec5635d65a6fd9ddb78c29">apr_socket_timeout_set()</a> or the APR_SO_NONBLOCK socket option. The number of bytes actually sent is stored in the len parameter. The offset parameter is passed by reference for no reason; its value will never be modified by the apr_socket_sendfile() function.</dd></dl>
<p>Read data from a network. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket to read the data from. </td></tr>
    <tr><td class="paramname">buf</td><td>The buffer to store the data in. </td></tr>
    <tr><td class="paramname">len</td><td>On entry, the number of bytes to receive; on exit, the number of bytes received. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd><pre>
This functions acts like a blocking read by default.  To change 
this behavior, use <a class="el" href="unix_2sockopt_8c.html#a945bdbe807ec5635d65a6fd9ddb78c29">apr_socket_timeout_set()</a> or the APR_SO_NONBLOCK
socket option.
The number of bytes actually received is stored in argument 3.</pre></dd></dl>
<p>It is possible for both bytes to be received and an APR_EOF or other error to be returned.</p>
<pre>APR_EINTR is never returned.
</pre><p>Setup socket options for the specified socket </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket to set up. </td></tr>
    <tr><td class="paramname">opt</td><td>The option we would like to configure. One of: <pre>
           APR_SO_DEBUG      --  turn on debugging information 
           APR_SO_KEEPALIVE  --  keep connections active
           APR_SO_LINGER     --  lingers on close if data is present
           APR_SO_NONBLOCK   --  Turns blocking on/off for socket
                                 When this option is enabled, use
                                 the <a class="el" href="group__APR__STATUS__IS.html#ga9dd578bfcd76a2d997395608ae5b3a4e">APR_STATUS_IS_EAGAIN()</a> macro to
                                 see if a send or receive function
                                 could not transfer data without
                                 blocking.
           APR_SO_REUSEADDR  --  The rules used in validating addresses
                                 supplied to bind should allow reuse
                                 of local addresses.
           APR_SO_SNDBUF     --  Set the SendBufferSize
           APR_SO_RCVBUF     --  Set the ReceiveBufferSize
           APR_SO_FREEBIND   --  Allow binding to non-local IP address.
</pre> </td></tr>
    <tr><td class="paramname">on</td><td>Value for the option.</td></tr>
  </table>
  </dd>
</dl>
<p>Setup socket timeout for the specified socket </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket to set up. </td></tr>
    <tr><td class="paramname">t</td><td>Value for the timeout. <pre>
  t &gt; 0  &ndash; read and write calls return APR_TIMEUP if specified time
            elapsess with no data read or written
  t == 0 &ndash; read and write calls never block
  t &lt; 0  &ndash; read and write calls block
</pre></td></tr>
  </table>
  </dd>
</dl>
<p>Query socket options for the specified socket </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket to query </td></tr>
    <tr><td class="paramname">opt</td><td>The option we would like to query. One of: <pre>
           APR_SO_DEBUG      --  turn on debugging information 
           APR_SO_KEEPALIVE  --  keep connections active
           APR_SO_LINGER     --  lingers on close if data is present
           APR_SO_NONBLOCK   --  Turns blocking on/off for socket
           APR_SO_REUSEADDR  --  The rules used in validating addresses
                                 supplied to bind should allow reuse
                                 of local addresses.
           APR_SO_SNDBUF     --  Set the SendBufferSize
           APR_SO_RCVBUF     --  Set the ReceiveBufferSize
           APR_SO_DISCONNECTED -- Query the disconnected state of the socket.
                                 (Currently only used on Windows)
</pre> </td></tr>
    <tr><td class="paramname">on</td><td>Socket option returned on the call.</td></tr>
  </table>
  </dd>
</dl>
<p>Query socket timeout for the specified socket </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket to query </td></tr>
    <tr><td class="paramname">t</td><td>Socket timeout returned from the query.</td></tr>
  </table>
  </dd>
</dl>
<p>Query the specified socket if at the OOB/Urgent data mark </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket to query </td></tr>
    <tr><td class="paramname">atmark</td><td>Is set to true if socket is at the OOB/urgent mark, otherwise is set to false.</td></tr>
  </table>
  </dd>
</dl>
<p>Return an address associated with a socket; either the address to which the socket is bound locally or the address of the peer to which the socket is connected. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sa</td><td>The returned <a class="el" href="structapr__sockaddr__t.html">apr_sockaddr_t</a>. </td></tr>
    <tr><td class="paramname">which</td><td>Whether to retrieve the local or remote address </td></tr>
    <tr><td class="paramname">sock</td><td>The socket to use</td></tr>
  </table>
  </dd>
</dl>
<p>Return the IP address (in numeric address string format) in an APR socket address. APR will allocate storage for the IP address string from the pool of the <a class="el" href="structapr__sockaddr__t.html">apr_sockaddr_t</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>The IP address. </td></tr>
    <tr><td class="paramname">sockaddr</td><td>The socket address to reference.</td></tr>
  </table>
  </dd>
</dl>
<p>Write the IP address (in numeric address string format) of the APR socket address <em>sockaddr</em> into the buffer <em>buf</em> (of size <em>buflen</em>). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sockaddr</td><td>The socket address to reference.</td></tr>
  </table>
  </dd>
</dl>
<p>See if the IP addresses in two APR socket addresses are equivalent. Appropriate logic is present for comparing IPv4-mapped IPv6 addresses with IPv4 addresses.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr1</td><td>One of the APR socket addresses. </td></tr>
    <tr><td class="paramname">addr2</td><td>The other APR socket address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The return value will be non-zero if the addresses are equivalent.</dd></dl>
<p>See if the IP address in an APR socket address refers to the wildcard address for the protocol family (e.g., INADDR_ANY for IPv4).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>The APR socket address to examine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The return value will be non-zero if the address is initialized and is the wildcard address.</dd></dl>
<p>Return the type of the socket. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket to query. </td></tr>
    <tr><td class="paramname">type</td><td>The returned type (e.g., SOCK_STREAM).</td></tr>
  </table>
  </dd>
</dl>
<p>Given an <a class="el" href="structapr__sockaddr__t.html">apr_sockaddr_t</a> and a service name, set the port for the service </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sockaddr</td><td>The <a class="el" href="structapr__sockaddr__t.html">apr_sockaddr_t</a> that will have its port set </td></tr>
    <tr><td class="paramname">servname</td><td>The name of the service you wish to use</td></tr>
  </table>
  </dd>
</dl>
<p>Build an ip-subnet representation from an IP address and optional netmask or number-of-bits. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ipsub</td><td>The new ip-subnet representation </td></tr>
    <tr><td class="paramname">ipstr</td><td>The input IP address string </td></tr>
    <tr><td class="paramname">mask_or_numbits</td><td>The input netmask or number-of-bits string, or NULL </td></tr>
    <tr><td class="paramname">p</td><td>The pool to allocate from</td></tr>
  </table>
  </dd>
</dl>
<p>Test the IP address in an <a class="el" href="structapr__sockaddr__t.html">apr_sockaddr_t</a> against a pre-built ip-subnet representation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ipsub</td><td>The ip-subnet representation </td></tr>
    <tr><td class="paramname">sa</td><td>The socket address to test </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-zero if the socket address is within the subnet, 0 otherwise</dd></dl>
<p>Return the protocol of the socket. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket to query. </td></tr>
    <tr><td class="paramname">protocol</td><td>The returned protocol (e.g., APR_PROTO_TCP).</td></tr>
  </table>
  </dd>
</dl>
<p>Join a Multicast Group </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket to join a multicast group </td></tr>
    <tr><td class="paramname">join</td><td>The address of the multicast group to join </td></tr>
    <tr><td class="paramname">iface</td><td>Address of the interface to use. If NULL is passed, the default multicast interface will be used. (OS Dependent) </td></tr>
    <tr><td class="paramname">source</td><td>Source Address to accept transmissions from (non-NULL implies Source-Specific Multicast)</td></tr>
  </table>
  </dd>
</dl>
<p>Leave a Multicast Group. All arguments must be the same as apr_mcast_join. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket to leave a multicast group </td></tr>
    <tr><td class="paramname">addr</td><td>The address of the multicast group to leave </td></tr>
    <tr><td class="paramname">iface</td><td>Address of the interface to use. If NULL is passed, the default multicast interface will be used. (OS Dependent) </td></tr>
    <tr><td class="paramname">source</td><td>Source Address to accept transmissions from (non-NULL implies Source-Specific Multicast)</td></tr>
  </table>
  </dd>
</dl>
<p>Set the Multicast Time to Live (ttl) for a multicast transmission. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket to set the multicast ttl </td></tr>
    <tr><td class="paramname">ttl</td><td>Time to live to Assign. 0-255, default=1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the TTL is 0, packets will only be seen by sockets on the local machine, and only when multicast loopback is enabled.</dd></dl>
<p>Toggle IP Multicast Loopback </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket to set multicast loopback </td></tr>
    <tr><td class="paramname">opt</td><td>0=disable, 1=enable</td></tr>
  </table>
  </dd>
</dl>
<p>Set the Interface to be used for outgoing Multicast Transmissions. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket to set the multicast interface on </td></tr>
    <tr><td class="paramname">iface</td><td>Address of the interface to use for Multicast</td></tr>
  </table>
  </dd>
</dl>
<p>Set up a pollset object </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pollset</td><td>The pointer in which to return the newly created object </td></tr>
    <tr><td class="paramname">size</td><td>The maximum number of descriptors that this pollset can hold </td></tr>
    <tr><td class="paramname">p</td><td>The pool from which to allocate the pollset </td></tr>
    <tr><td class="paramname">flags</td><td>Optional flags to modify the operation of the pollset. </td></tr>
    <tr><td class="paramname">method</td><td>Poll method to use. See <a class="el" href="group__apr__poll.html#gabe6f1238ea45e9425fa052e2788e4a29">apr_pollset_method_e</a>. If this method cannot be used, the default method will be used unless the APR_POLLSET_NODEFAULT flag has been specified.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If flags contains APR_POLLSET_THREADSAFE, then a pollset is created on which it is safe to make concurrent calls to apr_pollset_add(), apr_pollset_remove() and apr_pollset_poll() from separate threads. This feature is only supported on some platforms; the apr_pollset_create_ex() call will fail with APR_ENOTIMPL on platforms where it is not supported. </dd>
<dd>
If flags contains APR_POLLSET_WAKEABLE, then a pollset is created with additional internal pipe object used for the apr_pollset_wakeup() call. The actual size of pollset is in that case size + 1. This feature is only supported on some platforms; the apr_pollset_create_ex() call will fail with APR_ENOTIMPL on platforms where it is not supported. </dd>
<dd>
If flags contains APR_POLLSET_NOCOPY, then the <a class="el" href="structapr__pollfd__t.html">apr_pollfd_t</a> structures passed to apr_pollset_add() are not copied and must have a lifetime at least as long as the pollset. </dd>
<dd>
Some poll methods (including APR_POLLSET_KQUEUE, APR_POLLSET_PORT, and APR_POLLSET_EPOLL) do not have a fixed limit on the size of the pollset. For these methods, the size parameter controls the maximum number of descriptors that will be returned by a single call to apr_pollset_poll().</dd></dl>
<p>Destroy a pollset object </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pollset</td><td>The pollset to destroy</td></tr>
  </table>
  </dd>
</dl>
<p>Add a socket or file descriptor to a pollset </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pollset</td><td>The pollset to which to add the descriptor </td></tr>
    <tr><td class="paramname">descriptor</td><td>The descriptor to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If you set client_data in the descriptor, that value will be returned in the client_data field whenever this descriptor is signalled in apr_pollset_poll(). </dd>
<dd>
If the pollset has been created with APR_POLLSET_THREADSAFE and thread T1 is blocked in a call to apr_pollset_poll() for this same pollset that is being modified via apr_pollset_add() in thread T2, the currently executing apr_pollset_poll() call in T1 will either: (1) automatically include the newly added descriptor in the set of descriptors it is watching or (2) return immediately with APR_EINTR. Option (1) is recommended, but option (2) is allowed for implementations where option (1) is impossible or impractical. </dd>
<dd>
If the pollset has been created with APR_POLLSET_NOCOPY, the <a class="el" href="structapr__pollfd__t.html">apr_pollfd_t</a> structure referenced by descriptor will not be copied and must have a lifetime at least as long as the pollset. </dd>
<dd>
Do not add the same socket or file descriptor to the same pollset multiple times, even if the requested events differ for the different calls to apr_pollset_add(). If the events of interest for a descriptor change, you must first remove the descriptor from the pollset with apr_pollset_remove(), then add it again specifying all requested events.</dd></dl>
<p>Remove a descriptor from a pollset </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pollset</td><td>The pollset from which to remove the descriptor </td></tr>
    <tr><td class="paramname">descriptor</td><td>The descriptor to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the descriptor is not found, APR_NOTFOUND is returned. </dd>
<dd>
If the pollset has been created with APR_POLLSET_THREADSAFE and thread T1 is blocked in a call to apr_pollset_poll() for this same pollset that is being modified via apr_pollset_remove() in thread T2, the currently executing apr_pollset_poll() call in T1 will either: (1) automatically exclude the newly added descriptor in the set of descriptors it is watching or (2) return immediately with APR_EINTR. Option (1) is recommended, but option (2) is allowed for implementations where option (1) is impossible or impractical. </dd>
<dd>
apr_pollset_remove() cannot be used to remove a subset of requested events for a descriptor. The reqevents field in the <a class="el" href="structapr__pollfd__t.html">apr_pollfd_t</a> parameter must contain the same value when removing as when adding.</dd></dl>
<p>Block for activity on the descriptor(s) in a pollset </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pollset</td><td>The pollset to use </td></tr>
    <tr><td class="paramname">timeout</td><td>The amount of time in microseconds to wait. This is a maximum, not a minimum. If a descriptor is signalled, the function will return before this time. If timeout is negative, the function will block until a descriptor is signalled or until apr_pollset_wakeup() has been called. </td></tr>
    <tr><td class="paramname">num</td><td>Number of signalled descriptors (output parameter) </td></tr>
    <tr><td class="paramname">descriptors</td><td>Array of signalled descriptors (output parameter) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>APR_EINTR will be returned if the pollset has been created with APR_POLLSET_WAKEABLE, apr_pollset_wakeup() has been called while waiting for activity, and there were no signalled descriptors at the time of the wakeup call. </dd>
<dd>
Multiple signalled conditions for the same descriptor may be reported in one or more returned <a class="el" href="structapr__pollfd__t.html">apr_pollfd_t</a> structures, depending on the implementation.</dd></dl>
<p>Interrupt the blocked apr_pollset_poll() call. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pollset</td><td>The pollset to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the pollset was not created with APR_POLLSET_WAKEABLE the return value is APR_EINIT.</dd></dl>
<p>Poll the descriptors in the poll structure </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aprset</td><td>The poll structure we will be using. </td></tr>
    <tr><td class="paramname">numsock</td><td>The number of descriptors we are polling </td></tr>
    <tr><td class="paramname">nsds</td><td>The number of descriptors signalled (output parameter) </td></tr>
    <tr><td class="paramname">timeout</td><td>The amount of time in microseconds to wait. This is a maximum, not a minimum. If a descriptor is signalled, the function will return before this time. If timeout is negative, the function will block until a descriptor is signalled or until apr_pollset_wakeup() has been called. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The number of descriptors signalled is returned in the third argument. This is a blocking call, and it will not return until either a descriptor has been signalled or the timeout has expired. </dd>
<dd>
The rtnevents field in the <a class="el" href="structapr__pollfd__t.html">apr_pollfd_t</a> array will only be filled- in if the return value is APR_SUCCESS.</dd></dl>
<p>Return a printable representation of the default pollset method (APR_POLLSET_DEFAULT).</p>
<p>Set up a pollcb object </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pollcb</td><td>The pointer in which to return the newly created object </td></tr>
    <tr><td class="paramname">size</td><td>The maximum number of descriptors that a single _poll can return. </td></tr>
    <tr><td class="paramname">p</td><td>The pool from which to allocate the pollcb </td></tr>
    <tr><td class="paramname">flags</td><td>Optional flags to modify the operation of the pollcb.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If flags contains APR_POLLSET_WAKEABLE, then a pollcb is created with an additional internal pipe object used for the apr_pollcb_wakeup() call. The actual size of pollcb is in that case <em>size</em> + 1. </dd>
<dd>
Pollcb is only supported on some platforms; the apr_pollcb_create() call will fail with APR_ENOTIMPL on platforms where it is not supported.</dd></dl>
<p>Set up a pollcb object </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pollcb</td><td>The pointer in which to return the newly created object </td></tr>
    <tr><td class="paramname">size</td><td>The maximum number of descriptors that a single _poll can return. </td></tr>
    <tr><td class="paramname">p</td><td>The pool from which to allocate the pollcb </td></tr>
    <tr><td class="paramname">flags</td><td>Optional flags to modify the operation of the pollcb. </td></tr>
    <tr><td class="paramname">method</td><td>Poll method to use. See <a class="el" href="group__apr__poll.html#gabe6f1238ea45e9425fa052e2788e4a29">apr_pollset_method_e</a>. If this method cannot be used, the default method will be used unless the APR_POLLSET_NODEFAULT flag has been specified.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If flags contains APR_POLLSET_WAKEABLE, then a pollcb is created with an additional internal pipe object used for the apr_pollcb_wakeup() call. The actual size of pollcb is in that case <em>size</em> + 1. </dd>
<dd>
Pollcb is only supported on some platforms; the apr_pollcb_create_ex() call will fail with APR_ENOTIMPL on platforms where it is not supported.</dd></dl>
<p>Add a socket or file descriptor to a pollcb </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pollcb</td><td>The pollcb to which to add the descriptor </td></tr>
    <tr><td class="paramname">descriptor</td><td>The descriptor to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If you set client_data in the descriptor, that value will be returned in the client_data field whenever this descriptor is signalled in apr_pollcb_poll(). </dd>
<dd>
Unlike the apr_pollset API, the descriptor is not copied, and users must retain the memory used by descriptor, as the same pointer will be returned to them from apr_pollcb_poll. </dd>
<dd>
Do not add the same socket or file descriptor to the same pollcb multiple times, even if the requested events differ for the different calls to apr_pollcb_add(). If the events of interest for a descriptor change, you must first remove the descriptor from the pollcb with apr_pollcb_remove(), then add it again specifying all requested events.</dd></dl>
<p>Remove a descriptor from a pollcb </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pollcb</td><td>The pollcb from which to remove the descriptor </td></tr>
    <tr><td class="paramname">descriptor</td><td>The descriptor to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the descriptor is not found, APR_NOTFOUND is returned. </dd>
<dd>
apr_pollcb_remove() cannot be used to remove a subset of requested events for a descriptor. The reqevents field in the <a class="el" href="structapr__pollfd__t.html">apr_pollfd_t</a> parameter must contain the same value when removing as when adding.</dd></dl>
<p>Block for activity on the descriptor(s) in a pollcb </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pollcb</td><td>The pollcb to use </td></tr>
    <tr><td class="paramname">timeout</td><td>The amount of time in microseconds to wait. This is a maximum, not a minimum. If a descriptor is signalled, the function will return before this time. If timeout is negative, the function will block until a descriptor is signalled or until apr_pollcb_wakeup() has been called. </td></tr>
    <tr><td class="paramname">func</td><td>Callback function to call for each active descriptor. </td></tr>
    <tr><td class="paramname">baton</td><td>Opaque baton passed to the callback function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Multiple signalled conditions for the same descriptor may be reported in one or more calls to the callback function, depending on the implementation. </dd>
<dd>
APR_EINTR will be returned if the pollset has been created with APR_POLLSET_WAKEABLE and apr_pollcb_wakeup() has been called while waiting for activity.</dd></dl>
<p>Interrupt the blocked apr_pollcb_poll() call. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pollcb</td><td>The pollcb to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the pollcb was not created with APR_POLLSET_WAKEABLE the return value is APR_EINIT.</dd></dl>
<p>Return a printable representation of the pollcb method. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pollcb</td><td>The pollcb to use</td></tr>
  </table>
  </dd>
</dl>
<p>Create a new pool. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newpool</td><td>The pool we have just created. </td></tr>
    <tr><td class="paramname">parent</td><td>The parent pool. If this is NULL, the new pool is a root pool. If it is non-NULL, the new pool will inherit all of its parent pool's attributes, except the <a class="el" href="structapr__pool__t.html">apr_pool_t</a> will be a sub-pool. </td></tr>
    <tr><td class="paramname">abort_fn</td><td>A function to use if the pool cannot allocate more memory. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use with the new pool. If NULL the allocator of the parent pool will be used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function is thread-safe, in the sense that multiple threads can safely create subpools of the same parent pool concurrently. Similarly, a subpool can be created by one thread at the same time that another thread accesses the parent pool.</dd></dl>
<p>Create a new pool. </p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000041">Deprecated:</a></b></dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd>apr_pool_create_unmanaged_ex.</dd></dl>
<p>Create a new unmanaged pool. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newpool</td><td>The pool we have just created. </td></tr>
    <tr><td class="paramname">abort_fn</td><td>A function to use if the pool cannot allocate more memory. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use with the new pool. If NULL a new allocator will be created with the new pool as owner. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>An unmanaged pool is a special pool without a parent; it will NOT be destroyed upon apr_terminate. It must be explicitly destroyed by calling apr_pool_destroy, to prevent memory leaks. Use of this function is discouraged, think twice about whether you really really need it. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Any child cleanups registered against the new pool, or against sub-pools thereof, will not be executed during an invocation of apr_proc_create(), so resources created in an "unmanaged" pool hierarchy will leak to child processes.</dd></dl>
<p>Debug version of apr_pool_create_ex. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newpool</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__apr__pools.html#gaa7c40921aae156b665e82b0a66991a39">apr_pool_create</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__apr__pools.html#gaa7c40921aae156b665e82b0a66991a39">apr_pool_create</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">abort_fn</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__apr__pools.html#gaa7c40921aae156b665e82b0a66991a39">apr_pool_create</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__apr__pools.html#gaa7c40921aae156b665e82b0a66991a39">apr_pool_create</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file_line</td><td>Where the function is called from. This is usually APR_POOL__FILE_LINE__. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Only available when APR_POOL_DEBUG is defined. Call this directly if you have your apr_pool_create_ex calls in a wrapper function and wish to override the file_line argument to reflect the caller of your wrapper function. If you do not have apr_pool_create_ex in a wrapper, trust the macro and don't call apr_pool_create_ex_debug directly.</dd></dl>
<p>Debug version of apr_pool_create_core_ex. </p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000042">Deprecated:</a></b></dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd>apr_pool_create_unmanaged_ex_debug.</dd></dl>
<p>Debug version of apr_pool_create_unmanaged_ex. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newpool</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__apr__pools.html#ga03a06feb239bed9edd79a4f59679d56b">apr_pool_create_unmanaged</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">abort_fn</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__apr__pools.html#ga03a06feb239bed9edd79a4f59679d56b">apr_pool_create_unmanaged</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__apr__pools.html#ga03a06feb239bed9edd79a4f59679d56b">apr_pool_create_unmanaged</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file_line</td><td>Where the function is called from. This is usually APR_POOL__FILE_LINE__. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Only available when APR_POOL_DEBUG is defined. Call this directly if you have your apr_pool_create_unmanaged_ex calls in a wrapper function and wish to override the file_line argument to reflect the caller of your wrapper function. If you do not have apr_pool_create_core_ex in a wrapper, trust the macro and don't call apr_pool_create_core_ex_debug directly.</dd></dl>
<p>Clear all memory in the pool and run all the cleanups. This also destroys all subpools. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The pool to clear </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This does not actually free the memory, it just allows the pool to re-use this memory for the next allocation. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>apr_pool_destroy()</dd></dl>
<p>Debug version of apr_pool_clear. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>See: apr_pool_clear. </td></tr>
    <tr><td class="paramname">file_line</td><td>Where the function is called from. This is usually APR_POOL__FILE_LINE__. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Only available when APR_POOL_DEBUG is defined. Call this directly if you have your apr_pool_clear calls in a wrapper function and wish to override the file_line argument to reflect the caller of your wrapper function. If you do not have apr_pool_clear in a wrapper, trust the macro and don't call apr_pool_destroy_clear directly.</dd></dl>
<p>Destroy the pool. This takes similar action as apr_pool_clear() and then frees all the memory. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The pool to destroy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This will actually free the memory</dd></dl>
<p>Debug version of apr_pool_destroy. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>See: apr_pool_destroy. </td></tr>
    <tr><td class="paramname">file_line</td><td>Where the function is called from. This is usually APR_POOL__FILE_LINE__. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Only available when APR_POOL_DEBUG is defined. Call this directly if you have your apr_pool_destroy calls in a wrapper function and wish to override the file_line argument to reflect the caller of your wrapper function. If you do not have apr_pool_destroy in a wrapper, trust the macro and don't call apr_pool_destroy_debug directly.</dd></dl>
<p>Debug version of apr_palloc </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>See: apr_palloc </td></tr>
    <tr><td class="paramname">size</td><td>See: apr_palloc </td></tr>
    <tr><td class="paramname">file_line</td><td>Where the function is called from. This is usually APR_POOL__FILE_LINE__. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See: apr_palloc</dd></dl>
<p>Debug version of apr_pcalloc </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>See: apr_pcalloc </td></tr>
    <tr><td class="paramname">size</td><td>See: apr_pcalloc </td></tr>
    <tr><td class="paramname">file_line</td><td>Where the function is called from. This is usually APR_POOL__FILE_LINE__. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See: apr_pcalloc</dd></dl>
<p>Set the function to be called when an allocation failure occurs. </p><dl class="section remark"><dt>Remarks</dt><dd>If the program wants APR to exit on a memory allocation error, then this function can be called to set the callback to use (for performing cleanup and then exiting). If this function is not called, then APR will return an error and expect the calling program to deal with the error accordingly.</dd></dl>
<p>Determine if pool a is an ancestor of pool b. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The pool to search </td></tr>
    <tr><td class="paramname">b</td><td>The pool to search for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if a is an ancestor of b, NULL is considered an ancestor of all pools. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>if compiled with APR_POOL_DEBUG, this function will also return true if A is a pool which has been guaranteed by the caller (using apr_pool_join) to have a lifetime at least as long as some ancestor of pool B.</dd></dl>
<p>Tag a pool (give it a name) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td>The pool to tag </td></tr>
    <tr><td class="paramname">tag</td><td>The tag</td></tr>
  </table>
  </dd>
</dl>
<p>Set the data associated with the current pool </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The user data associated with the pool. </td></tr>
    <tr><td class="paramname">key</td><td>The key to use for association </td></tr>
    <tr><td class="paramname">cleanup</td><td>The cleanup program to use to cleanup the data (NULL if none) </td></tr>
    <tr><td class="paramname">pool</td><td>The current pool </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>The data to be attached to the pool should have a life span at least as long as the pool it is being attached to.</dd></dl>
<p>Users of APR must take EXTREME care when choosing a key to use for their data. It is possible to accidentally overwrite data by choosing a key that another part of the program is using. Therefore it is advised that steps are taken to ensure that unique keys are used for all of the userdata objects in a particular pool (the same key in two different pools or a pool and one of its subpools is okay) at all times. Careful namespace prefixing of key names is a typical way to help ensure this uniqueness.</p>
<p>Set the data associated with the current pool </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The user data associated with the pool. </td></tr>
    <tr><td class="paramname">key</td><td>The key to use for association </td></tr>
    <tr><td class="paramname">cleanup</td><td>The cleanup program to use to cleanup the data (NULL if none) </td></tr>
    <tr><td class="paramname">pool</td><td>The current pool </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>same as apr_pool_userdata_set(), except that this version doesn't make a copy of the key (this function is useful, for example, when the key is a string literal) </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This should NOT be used if the key could change addresses by any means between the apr_pool_userdata_setn() call and a subsequent apr_pool_userdata_get() on that key, such as if a static string is used as a userdata key in a DSO and the DSO could be unloaded and reloaded between the _setn() and the _get(). You MUST use apr_pool_userdata_set() in such cases. </dd>
<dd>
More generally, the key and the data to be attached to the pool should have a life span at least as long as the pool itself.</dd></dl>
<p>Return the data associated with the current pool. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The user data associated with the pool. </td></tr>
    <tr><td class="paramname">key</td><td>The key for the data to retrieve </td></tr>
    <tr><td class="paramname">pool</td><td>The current pool.</td></tr>
  </table>
  </dd>
</dl>
<p>Register a function to be called when a pool is cleared or destroyed </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The pool to register the cleanup with </td></tr>
    <tr><td class="paramname">data</td><td>The data to pass to the cleanup function. </td></tr>
    <tr><td class="paramname">plain_cleanup</td><td>The function to call when the pool is cleared or destroyed </td></tr>
    <tr><td class="paramname">child_cleanup</td><td>The function to call when a child process is about to exec - this function is called in the child, obviously!</td></tr>
  </table>
  </dd>
</dl>
<p>Remove a previously registered cleanup function.</p>
<p>The cleanup most recently registered with <em>p</em> having the same values of <em>data</em> and <em>cleanup</em> will be removed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The pool to remove the cleanup from </td></tr>
    <tr><td class="paramname">data</td><td>The data of the registered cleanup </td></tr>
    <tr><td class="paramname">cleanup</td><td>The function to remove from cleanup </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>For some strange reason only the plain_cleanup is handled by this function</dd></dl>
<p>Replace the child cleanup function of a previously registered cleanup.</p>
<p>The cleanup most recently registered with <em>p</em> having the same values of <em>data</em> and <em>plain_cleanup</em> will have the registered child cleanup function replaced with <em>child_cleanup</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The pool of the registered cleanup </td></tr>
    <tr><td class="paramname">data</td><td>The data of the registered cleanup </td></tr>
    <tr><td class="paramname">plain_cleanup</td><td>The plain cleanup function of the registered cleanup </td></tr>
    <tr><td class="paramname">child_cleanup</td><td>The function to register as the child cleanup</td></tr>
  </table>
  </dd>
</dl>
<p>Run all registered child cleanups, in preparation for an exec() call in a forked child &ndash; close files, etc., but <em>don't</em> flush I/O buffers, <em>don't</em> wait for subprocesses, and <em>don't</em> free any memory.</p>
<p>convert the file from apr type to os specific type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thefile</td><td>The os specific file we are converting to </td></tr>
    <tr><td class="paramname">file</td><td>The apr file to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>On Unix, it is only possible to get a file descriptor from an apr file type.</dd></dl>
<p>convert the dir from apr type to os specific type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thedir</td><td>The os specific dir we are converting to </td></tr>
    <tr><td class="paramname">dir</td><td>The apr dir to convert.</td></tr>
  </table>
  </dd>
</dl>
<p>Convert the socket from an apr type to an OS specific socket </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thesock</td><td>The socket to convert. </td></tr>
    <tr><td class="paramname">sock</td><td>The os specific equivalent of the apr socket..</td></tr>
  </table>
  </dd>
</dl>
<p>Convert the proc mutex from apr type to os specific type </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ospmutex</td><td>The os specific proc mutex we are converting to. </td></tr>
    <tr><td class="paramname">pmutex</td><td>The apr proc mutex to convert.</td></tr>
  </table>
  </dd>
</dl>
<p>Convert the proc mutex from apr type to os specific type, also providing the mechanism used by the apr mutex. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ospmutex</td><td>The os specific proc mutex we are converting to. </td></tr>
    <tr><td class="paramname">pmutex</td><td>The apr proc mutex to convert. </td></tr>
    <tr><td class="paramname">mech</td><td>The mechanism used by the apr proc mutex (if not NULL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Allows for disambiguation for platforms with multiple mechanisms available.</dd></dl>
<p>Get the exploded time in the platforms native format. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ostime</td><td>the native time format </td></tr>
    <tr><td class="paramname">aprtime</td><td>the time to convert</td></tr>
  </table>
  </dd>
</dl>
<p>Get the imploded time in the platforms native format. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ostime</td><td>the native time format </td></tr>
    <tr><td class="paramname">aprtime</td><td>the time to convert</td></tr>
  </table>
  </dd>
</dl>
<p>convert the shm from apr type to os specific type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">osshm</td><td>The os specific shm representation </td></tr>
    <tr><td class="paramname">shm</td><td>The apr shm to convert.</td></tr>
  </table>
  </dd>
</dl>
<p>convert the thread to os specific type from apr type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thethd</td><td>The apr thread to convert </td></tr>
    <tr><td class="paramname">thd</td><td>The os specific thread we are converting to</td></tr>
  </table>
  </dd>
</dl>
<p>convert the thread private memory key to os specific type from an apr type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thekey</td><td>The apr handle we are converting from. </td></tr>
    <tr><td class="paramname">key</td><td>The os specific handle we are converting to.</td></tr>
  </table>
  </dd>
</dl>
<p>convert the thread from os specific type to apr type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>The apr thread we are converting to. </td></tr>
    <tr><td class="paramname">thethd</td><td>The os specific thread to convert </td></tr>
    <tr><td class="paramname">cont</td><td>The pool to use if it is needed.</td></tr>
  </table>
  </dd>
</dl>
<p>convert the thread private memory key from os specific type to apr type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The apr handle we are converting to. </td></tr>
    <tr><td class="paramname">thekey</td><td>The os specific handle to convert </td></tr>
    <tr><td class="paramname">cont</td><td>The pool to use if it is needed.</td></tr>
  </table>
  </dd>
</dl>
<p>Compare two thread id's </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tid1</td><td>1st Thread ID to compare </td></tr>
    <tr><td class="paramname">tid2</td><td>2nd Thread ID to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-zero if the two threads are equal, zero otherwise</dd></dl>
<p>convert the file from os specific type to apr type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>The apr file we are converting to. </td></tr>
    <tr><td class="paramname">thefile</td><td>The os specific file to convert </td></tr>
    <tr><td class="paramname">flags</td><td>The flags that were used to open this file. </td></tr>
    <tr><td class="paramname">cont</td><td>The pool to use if it is needed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>On Unix, it is only possible to put a file descriptor into an apr file type.</dd></dl>
<p>convert the file from os specific type to apr type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>The apr file we are converting to. </td></tr>
    <tr><td class="paramname">thefile</td><td>The os specific pipe to convert </td></tr>
    <tr><td class="paramname">cont</td><td>The pool to use if it is needed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>On Unix, it is only possible to put a file descriptor into an apr file type.</dd></dl>
<p>convert the file from os specific type to apr type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>The apr file we are converting to. </td></tr>
    <tr><td class="paramname">thefile</td><td>The os specific pipe to convert </td></tr>
    <tr><td class="paramname">register_cleanup</td><td>A cleanup will be registered on the <a class="el" href="structapr__file__t.html">apr_file_t</a> to issue apr_file_close(). </td></tr>
    <tr><td class="paramname">cont</td><td>The pool to use if it is needed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>On Unix, it is only possible to put a file descriptor into an apr file type.</dd></dl>
<p>convert the dir from os specific type to apr type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dir</td><td>The apr dir we are converting to. </td></tr>
    <tr><td class="paramname">thedir</td><td>The os specific dir to convert </td></tr>
    <tr><td class="paramname">cont</td><td>The pool to use when creating to apr directory.</td></tr>
  </table>
  </dd>
</dl>
<p>Convert a socket from the os specific type to the APR type. If sock points to NULL, a socket will be created from the pool provided. If **sock does not point to NULL, the structure pointed to by sock will be reused and updated with the given socket. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The pool to use. </td></tr>
    <tr><td class="paramname">thesock</td><td>The socket to convert to. </td></tr>
    <tr><td class="paramname">cont</td><td>The socket we are converting to an apr type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If it is a true socket, it is best to call <a class="el" href="unix_2sockets_8c.html#a5df9f6b1b9c07bfeca3685118760eefc">apr_os_sock_make()</a> and provide APR with more information about the socket.</dd></dl>
<p>Create a socket from an existing descriptor and local and remote socket addresses. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">apr_sock</td><td>The new socket that has been set up </td></tr>
    <tr><td class="paramname">os_sock_info</td><td>The os representation of the socket handle and other characteristics of the socket </td></tr>
    <tr><td class="paramname">cont</td><td>The pool to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If you only know the descriptor/handle or if it isn't really a true socket, use <a class="el" href="unix_2sockets_8c.html#a729bd6825dfadd814de2aa602462d838">apr_os_sock_put()</a> instead.</dd></dl>
<p>Convert the proc mutex from os specific type to apr type </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pmutex</td><td>The apr proc mutex we are converting to. </td></tr>
    <tr><td class="paramname">ospmutex</td><td>The os specific proc mutex to convert. </td></tr>
    <tr><td class="paramname">cont</td><td>The pool to use if it is needed.</td></tr>
  </table>
  </dd>
</dl>
<p>Convert the proc mutex from os specific type to apr type, using the specified mechanism. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pmutex</td><td>The apr proc mutex we are converting to. </td></tr>
    <tr><td class="paramname">ospmutex</td><td>The os specific proc mutex to convert. </td></tr>
    <tr><td class="paramname">mech</td><td>The apr mutex locking mechanism </td></tr>
    <tr><td class="paramname">register_cleanup</td><td>Whether to destroy the os mutex with the apr one (either on explicit destroy or pool cleanup). </td></tr>
    <tr><td class="paramname">cont</td><td>The pool to use if it is needed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Allows for disambiguation for platforms with multiple mechanisms available.</dd></dl>
<p>Put the imploded time in the APR format. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aprtime</td><td>the APR time format </td></tr>
    <tr><td class="paramname">ostime</td><td>the time to convert </td></tr>
    <tr><td class="paramname">cont</td><td>the pool to use if necessary</td></tr>
  </table>
  </dd>
</dl>
<p>Put the exploded time in the APR format. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aprtime</td><td>the APR time format </td></tr>
    <tr><td class="paramname">ostime</td><td>the time to convert </td></tr>
    <tr><td class="paramname">cont</td><td>the pool to use if necessary</td></tr>
  </table>
  </dd>
</dl>
<p>convert the shared memory from os specific type to apr type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shm</td><td>The apr shm representation of osshm </td></tr>
    <tr><td class="paramname">osshm</td><td>The os specific shm identity </td></tr>
    <tr><td class="paramname">cont</td><td>The pool to use if it is needed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>On fork()ed architectures, this is typically nothing more than the memory block mapped. On non-fork architectures, this is typically some internal handle to pass the mapping from process to process.</dd></dl>
<p>convert the dso handle from os specific to apr </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dso</td><td>The apr handle we are converting to </td></tr>
    <tr><td class="paramname">thedso</td><td>the os specific handle to convert </td></tr>
    <tr><td class="paramname">pool</td><td>the pool to use if it is needed</td></tr>
  </table>
  </dd>
</dl>
<p>convert the apr dso handle into an os specific one </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aprdso</td><td>The apr dso handle to convert </td></tr>
    <tr><td class="paramname">dso</td><td>The os specific dso to return</td></tr>
  </table>
  </dd>
</dl>
<p>Private: apr-util's apr_uuid module when supported by the platform</p>
<p>Get the name of the current locale character set. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td>the pool to allocate the name from, if needed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Defers to apr_os_default_encoding if the current locale's data can't be retrieved on this system.</dd></dl>
<p>Re-open a mutex in a child process. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>The newly re-opened mutex structure. </td></tr>
    <tr><td class="paramname">fname</td><td>A file name to use if the mutex mechanism requires one. This argument should always be provided. The mutex code itself will determine if it should be used. This filename should be the same one that was passed to apr_proc_mutex_create(). </td></tr>
    <tr><td class="paramname">pool</td><td>The pool to operate on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function must be called to maintain portability, even if the underlying lock mechanism does not require it.</dd></dl>
<p>Destroy the mutex and free the memory associated with the lock. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>the mutex to destroy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is generally used to kill a cleanup on an already created mutex</dd></dl>
<p>Display the name of the default mutex: APR_LOCK_DEFAULT</p>
<p>Mix the randomness pools. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>The PRNG state </td></tr>
    <tr><td class="paramname">entropy_</td><td>Entropy buffer </td></tr>
    <tr><td class="paramname">bytes</td><td>Length of entropy_ in bytes</td></tr>
  </table>
  </dd>
</dl>
<p>Generate cryptographically secure random bytes. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>The RNG state </td></tr>
    <tr><td class="paramname">random</td><td>Buffer to fill with random bytes </td></tr>
    <tr><td class="paramname">bytes</td><td>Length of buffer in bytes</td></tr>
  </table>
  </dd>
</dl>
<p>Ensures that E bits of conditional entropy are mixed into the PRNG before any further randomness is extracted. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>The RNG state</td></tr>
  </table>
  </dd>
</dl>
<p>Return APR_SUCCESS if the cryptographic PRNG has been seeded with enough data, APR_ENOTENOUGHENTROPY otherwise. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>The RNG state</td></tr>
  </table>
  </dd>
</dl>
<p>Return APR_SUCCESS if the PRNG has been seeded with enough data, APR_ENOTENOUGHENTROPY otherwise. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>The PRNG state</td></tr>
  </table>
  </dd>
</dl>
<p>Mix the randomness pools after forking. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proc</td><td>The resulting process handle from apr_proc_fork() </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Call this in the child after forking to mix the randomness pools. Note that its generally a bad idea to fork a process with a real PRNG in it - better to have the PRNG externally and get the randomness from there. However, if you really must do it, then you should supply all your entropy to all the PRNGs - don't worry, they won't produce the same output. </dd>
<dd>
Note that apr_proc_fork() calls this for you, so only weird applications need ever call it themselves.</dd></dl>
<p>Create and make accessible a shared memory segment with platform- specific processing. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The shared memory structure to create. </td></tr>
    <tr><td class="paramname">reqsize</td><td>The desired size of the segment. </td></tr>
    <tr><td class="paramname">filename</td><td>The file to use for shared memory on platforms that require it. </td></tr>
    <tr><td class="paramname">pool</td><td>the pool from which to allocate the shared memory structure. </td></tr>
    <tr><td class="paramname">flags</td><td>mask of APR_SHM_* (defined above) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>A note about Anonymous vs. Named shared memory segments: Not all plaforms support anonymous shared memory segments, but in some cases it is prefered over other types of shared memory implementations. Passing a NULL 'file' parameter to this function will cause the subsystem to use anonymous shared memory segments. If such a system is not available, APR_ENOTIMPL is returned. </dd>
<dd>
A note about allocation sizes: On some platforms it is necessary to store some metainformation about the segment within the actual segment. In order to supply the caller with the requested size it may be necessary for the implementation to request a slightly greater segment length from the subsystem. In all cases, the apr_shm_baseaddr_get() function will return the first usable byte of memory.</dd></dl>
<p>Remove named resource associated with a shared memory segment, preventing attachments to the resource, but not destroying it. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The filename associated with shared-memory segment which needs to be removed </td></tr>
    <tr><td class="paramname">pool</td><td>The pool used for file operations </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function is only supported on platforms which support name-based shared memory segments, and will return APR_ENOTIMPL on platforms without such support. Removing the file while the shm is in use is not entirely portable, caller may use this to enhance obscurity of the resource, but be prepared for the call to fail, and for concurrent attempts to create a resource of the same name to also fail. The pool cleanup of apr_shm_create (apr_shm_destroy) also removes the named resource.</dd></dl>
<p>Delete named resource associated with a shared memory segment, preventing attachments to the resource. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The shared memory segment structure to delete. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function is only supported on platforms which support name-based shared memory segments, and will return APR_ENOTIMPL on platforms without such support. Removing the file while the shm is in use is not entirely portable, caller may use this to enhance obscurity of the resource, but be prepared for the call to fail, and for concurrent attempts to create a resource of the same name to also fail. The pool cleanup of apr_shm_create (apr_shm_destroy) also removes the named resource.</dd></dl>
<p>Destroy a shared memory segment and associated memory. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The shared memory segment structure to destroy.</td></tr>
  </table>
  </dd>
</dl>
<p>Attach to a shared memory segment that was created by another process. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The shared memory structure to create. </td></tr>
    <tr><td class="paramname">filename</td><td>The file used to create the original segment. (This MUST match the original filename.) </td></tr>
    <tr><td class="paramname">pool</td><td>the pool from which to allocate the shared memory structure for this process.</td></tr>
  </table>
  </dd>
</dl>
<p>Attach to a shared memory segment that was created by another process, with platform-specific processing. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The shared memory structure to create. </td></tr>
    <tr><td class="paramname">filename</td><td>The file used to create the original segment. (This MUST match the original filename.) </td></tr>
    <tr><td class="paramname">pool</td><td>the pool from which to allocate the shared memory structure for this process. </td></tr>
    <tr><td class="paramname">flags</td><td>mask of APR_SHM_* (defined above)</td></tr>
  </table>
  </dd>
</dl>
<p>Detach from a shared memory segment without destroying it. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The shared memory structure representing the segment to detach from.</td></tr>
  </table>
  </dd>
</dl>
<p>Enable the delivery of a particular signal </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">signum</td><td>The signal number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status</dd></dl>
<p>Set the comparison functions to be used for searching the skip list. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sl</td><td>The skip list </td></tr>
    <tr><td class="paramname">XXX1</td><td>FIXME </td></tr>
    <tr><td class="paramname">XXX2</td><td>FIXME</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If existing comparison functions are being replaced, the index will be replaced during this call. That is a potentially expensive operation.</dd></dl>
<p>Set the indexing functions to the specified comparison functions and rebuild the index. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sl</td><td>The skip list </td></tr>
    <tr><td class="paramname">XXX1</td><td>FIXME </td></tr>
    <tr><td class="paramname">XXX2</td><td>FIXME</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If an index already exists, it will not be replaced and the comparison functions will not be changed.</dd></dl>
<p>Return the next matching element in the skip list using the specified comparison function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sl</td><td>The skip list </td></tr>
    <tr><td class="paramname">data</td><td>The value to search for </td></tr>
    <tr><td class="paramname">iter</td><td>A pointer to the returned skip list node representing the element found </td></tr>
    <tr><td class="paramname">func</td><td>The comparison function to use</td></tr>
  </table>
  </dd>
</dl>
<p>Return the next matching element in the skip list using the current comparison function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sl</td><td>The skip list </td></tr>
    <tr><td class="paramname">data</td><td>The value to search for </td></tr>
    <tr><td class="paramname">iter</td><td>A pointer to the returned skip list node representing the element found</td></tr>
  </table>
  </dd>
</dl>
<p>Return the last matching element in the skip list using the specified comparison function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sl</td><td>The skip list </td></tr>
    <tr><td class="paramname">data</td><td>The value to search for </td></tr>
    <tr><td class="paramname">iter</td><td>A pointer to the returned skip list node representing the element found </td></tr>
    <tr><td class="paramname">func</td><td>The comparison function to use</td></tr>
  </table>
  </dd>
</dl>
<p>Return the last matching element in the skip list using the current comparison function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sl</td><td>The skip list </td></tr>
    <tr><td class="paramname">data</td><td>The value to search for </td></tr>
    <tr><td class="paramname">iter</td><td>A pointer to the returned skip list node representing the element found</td></tr>
  </table>
  </dd>
</dl>
<p>Return the next element in the skip list. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sl</td><td>The skip list </td></tr>
    <tr><td class="paramname">iter</td><td>On entry, a pointer to the skip list node to start with; on return, a pointer to the skip list node representing the element returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If iter points to a NULL value on entry, NULL will be returned.</dd></dl>
<p>Return the previous element in the skip list. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sl</td><td>The skip list </td></tr>
    <tr><td class="paramname">iter</td><td>On entry, a pointer to the skip list node to start with; on return, a pointer to the skip list node representing the element returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If iter points to a NULL value on entry, NULL will be returned.</dd></dl>
<p>Return the element of the skip list node </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>The skip list node</td></tr>
  </table>
  </dd>
</dl>
<p>Insert an element into the skip list using the specified comparison function if it does not already exist. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sl</td><td>The skip list </td></tr>
    <tr><td class="paramname">data</td><td>The element to insert </td></tr>
    <tr><td class="paramname">comp</td><td>The comparison function to use for placement into the skip list</td></tr>
  </table>
  </dd>
</dl>
<p>Insert an element into the skip list using the existing comparison function if it does not already exist. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sl</td><td>The skip list </td></tr>
    <tr><td class="paramname">data</td><td>The element to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If no comparison function has been set for the skip list, the element will not be inserted and NULL will be returned.</dd></dl>
<p>Add an element into the skip list using the specified comparison function allowing for duplicates. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sl</td><td>The skip list </td></tr>
    <tr><td class="paramname">data</td><td>The element to add </td></tr>
    <tr><td class="paramname">comp</td><td>The comparison function to use for placement into the skip list</td></tr>
  </table>
  </dd>
</dl>
<p>Add an element into the skip list using the existing comparison function allowing for duplicates. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sl</td><td>The skip list </td></tr>
    <tr><td class="paramname">data</td><td>The element to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If no comparison function has been set for the skip list, the element will not be inserted and NULL will be returned.</dd></dl>
<p>Add an element into the skip list using the specified comparison function removing the existing duplicates. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sl</td><td>The skip list </td></tr>
    <tr><td class="paramname">data</td><td>The element to insert </td></tr>
    <tr><td class="paramname">comp</td><td>The comparison function to use for placement into the skip list </td></tr>
    <tr><td class="paramname">myfree</td><td>A function to be called for each removed duplicate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If no comparison function has been set for the skip list, the element will not be inserted, none will be replaced, and NULL will be returned.</dd></dl>
<p>Add an element into the skip list using the existing comparison function removing the existing duplicates. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sl</td><td>The skip list </td></tr>
    <tr><td class="paramname">data</td><td>The element to insert </td></tr>
    <tr><td class="paramname">myfree</td><td>A function to be called for each removed duplicate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If no comparison function has been set for the skip list, the element will not be inserted, none will be replaced, and NULL will be returned.</dd></dl>
<p>Remove a node from the skip list. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sl</td><td>The skip list </td></tr>
    <tr><td class="paramname">iter</td><td>The skip list node to remove </td></tr>
    <tr><td class="paramname">myfree</td><td>A function to be called for the removed element</td></tr>
  </table>
  </dd>
</dl>
<p>Remove an element from the skip list using the specified comparison function for locating the element. In the case of duplicates, the 1st entry will be removed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sl</td><td>The skip list </td></tr>
    <tr><td class="paramname">data</td><td>The element to remove </td></tr>
    <tr><td class="paramname">myfree</td><td>A function to be called for each removed element </td></tr>
    <tr><td class="paramname">comp</td><td>The comparison function to use for placement into the skip list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the element is not found, 0 will be returned. Otherwise, the heightXXX will be returned.</dd></dl>
<p>Remove an element from the skip list using the existing comparison function for locating the element. In the case of duplicates, the 1st entry will be removed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sl</td><td>The skip list </td></tr>
    <tr><td class="paramname">data</td><td>The element to remove </td></tr>
    <tr><td class="paramname">myfree</td><td>A function to be called for each removed element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the element is not found, 0 will be returned. Otherwise, the heightXXX will be returned. </dd>
<dd>
If no comparison function has been set for the skip list, the element will not be removed and 0 will be returned.</dd></dl>
<p>Remove all elements from the skip list. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sl</td><td>The skip list </td></tr>
    <tr><td class="paramname">myfree</td><td>A function to be called for each removed element</td></tr>
  </table>
  </dd>
</dl>
<p>Remove each element from the skip list. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sl</td><td>The skip list </td></tr>
    <tr><td class="paramname">myfree</td><td>A function to be called for each removed element</td></tr>
  </table>
  </dd>
</dl>
<p>Return the first element in the skip list, removing the element from the skip list. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sl</td><td>The skip list </td></tr>
    <tr><td class="paramname">myfree</td><td>A function to be called for the removed element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>NULL will be returned if there are no elements</dd></dl>
<p>Return the first element in the skip list, leaving the element in the skip list. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sl</td><td>The skip list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>NULL will be returned if there are no elements</dd></dl>
<p>Return the height of the list (number of skip paths), in O(1). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sl</td><td>The skip list</td></tr>
  </table>
  </dd>
</dl>
<p>Return the predefined maximum height of the skip list. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sl</td><td>The skip list</td></tr>
  </table>
  </dd>
</dl>
<p>Set a predefined maximum height for the skip list. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sl</td><td>The skip list </td></tr>
    <tr><td class="paramname">to</td><td>The preheight to set, or a nul/negative value to disable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>When a preheight is used, the height of each inserted element is computed randomly up to this preheight instead of the current skip list's height plus one used by the default implementation. Using a preheight can probably ensure more fairness with long living elements (since with an adaptative height, former elements may have been created with a low height, hence a longest path to reach them while the skip list grows). On the other hand, the default behaviour (preheight &lt;= 0) with a growing and decreasing maximum height is more adaptative/suitable for short living values. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Should be called before any insertion/add.</dd></dl>
<p>Do a natural order comparison of two strings ignoring the case of the strings. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first string to compare </td></tr>
    <tr><td class="paramname">b</td><td>The second string to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Either &lt;0, 0, or &gt;0. If the first string is less than the second this returns &lt;0, if they are equivalent it returns 0, and if the first string is greater than second string it retuns &gt;0.</dd></dl>
<p>Create a null-terminated string by making a copy of a sequence of characters and appending a null byte </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The pool to allocate out of </td></tr>
    <tr><td class="paramname">s</td><td>The block of characters to duplicate </td></tr>
    <tr><td class="paramname">n</td><td>The number of characters to duplicate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new string or NULL if s == NULL </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This is a faster alternative to apr_pstrndup, for use when you know that the string being duplicated really has 'n' or more characters. If the string might contain fewer characters, use apr_pstrndup.</dd></dl>
<p>Duplicate at most n characters of a string into memory allocated out of a pool; the new string will be NUL-terminated </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The pool to allocate out of </td></tr>
    <tr><td class="paramname">s</td><td>The string to duplicate </td></tr>
    <tr><td class="paramname">n</td><td>The maximum number of characters to duplicate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new string or NULL if s == NULL </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The amount of memory allocated from the pool is the length of the returned string including the NUL terminator</dd></dl>
<p>Concatenate multiple strings specified in a writev-style vector </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The pool from which to allocate </td></tr>
    <tr><td class="paramname">vec</td><td>The strings to concatenate </td></tr>
    <tr><td class="paramname">nvec</td><td>The number of strings to concatenate </td></tr>
    <tr><td class="paramname">nbytes</td><td>(output) strlen of new string (pass in NULL to omit) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new string</dd></dl>
<p>printf-style style printing routine. The data is output to a string allocated from a pool </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The pool to allocate out of </td></tr>
    <tr><td class="paramname">fmt</td><td>The format of the string </td></tr>
    <tr><td class="paramname">ap</td><td>The arguments to use while printing the data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new string</dd></dl>
<p>Copy up to dst_size characters from src to dst; does not copy past a NUL terminator in src, but always terminates dst with a NUL regardless. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>The destination string </td></tr>
    <tr><td class="paramname">src</td><td>The source string </td></tr>
    <tr><td class="paramname">dst_size</td><td>The space available in dst; dst always receives NUL termination, so if src is longer than dst_size, the actual number of characters copied is dst_size - 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the NUL terminator of the destination string, dst </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd><pre>
Note the differences between this function and strncpy():
 1) strncpy() doesn't always NUL terminate; apr_cpystrn() does.
 2) strncpy() pads the destination string with NULs, which is often 
    unnecessary; apr_cpystrn() does not.
 3) strncpy() returns a pointer to the beginning of the dst string;
    apr_cpystrn() returns a pointer to the NUL terminator of dst, 
    to allow a check for truncation.
</pre></dd></dl>
<p>Remove all whitespace from a string </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The destination string. It is okay to modify the string in place. Namely dest == src </td></tr>
    <tr><td class="paramname">src</td><td>The string to rid the spaces from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the destination string's null terminator.</dd></dl>
<p>Convert the arguments to a program from one string to an array of strings terminated by a NULL pointer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg_str</td><td>The arguments to convert </td></tr>
    <tr><td class="paramname">argv_out</td><td>Output location. This is a pointer to an array of strings. </td></tr>
    <tr><td class="paramname">token_context</td><td>Pool to use.</td></tr>
  </table>
  </dd>
</dl>
<p>Split a string into separate null-terminated tokens. The tokens are delimited in the string by one or more characters from the sep argument. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to separate; this should be specified on the first call to apr_strtok() for a given string, and NULL on subsequent calls. </td></tr>
    <tr><td class="paramname">sep</td><td>The set of delimiters </td></tr>
    <tr><td class="paramname">last</td><td>State saved by apr_strtok() between calls. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The next token from the string </dd></dl>
<dl class="section note"><dt>Note</dt><dd>the 'last' state points to the trailing NUL char of the final token, otherwise it points to the character following the current token (all successive or empty occurances of sep are skiped on the subsequent call to apr_strtok). Therefore it is possible to avoid a strlen() determination, with the following logic; toklen = last - retval; if (*last) &ndash;toklen;</dd></dl>
<p>vsnprintf routine based on apr_vformatter. This means it understands the same extensions. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The buffer to write to </td></tr>
    <tr><td class="paramname">len</td><td>The size of the buffer </td></tr>
    <tr><td class="paramname">format</td><td>The format string </td></tr>
    <tr><td class="paramname">ap</td><td>The arguments to use to fill out the format string.</td></tr>
  </table>
  </dd>
</dl>
<p>create a string representation of an int, allocated from a pool </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The pool from which to allocate </td></tr>
    <tr><td class="paramname">n</td><td>The number to format </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The string representation of the number</dd></dl>
<p>create a string representation of a long, allocated from a pool </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The pool from which to allocate </td></tr>
    <tr><td class="paramname">n</td><td>The number to format </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The string representation of the number</dd></dl>
<p>create a string representation of an apr_off_t, allocated from a pool </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The pool from which to allocate </td></tr>
    <tr><td class="paramname">n</td><td>The number to format </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The string representation of the number</dd></dl>
<p>Convert a numeric string into an apr_off_t numeric value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>The value of the parsed string. </td></tr>
    <tr><td class="paramname">buf</td><td>The string to parse. It may contain optional whitespace, followed by an optional '+' (positive, default) or '-' (negative) character, followed by an optional '0x' prefix if base is 0 or 16, followed by numeric digits appropriate for base. </td></tr>
    <tr><td class="paramname">end</td><td>A pointer to the end of the valid character in buf. If not NULL, it is set to the first invalid character in buf. </td></tr>
    <tr><td class="paramname">base</td><td>A numeric base in the range between 2 and 36 inclusive, or 0. If base is zero, buf will be treated as base ten unless its digits are prefixed with '0x', in which case it will be treated as base 16. </td></tr>
  </table>
  </dd>
</dl>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000013">Bug:</a></b></dt><dd>*end breaks type safety; where *buf is const, *end needs to be declared as const in APR 2.0 </dd></dl>
<p>parse a base-10 numeric string into a 64-bit numeric value. Equivalent to apr_strtoi64(buf, (char**)NULL, 10). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The string to parse </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The numeric value of the string. On overflow, errno is set to ERANGE. On success, errno is set to 0.</dd></dl>
<p><a class="el" href="structFormat.html">Format</a> a binary size (magnitiudes are 2^10 rather than 10^3) from an apr_off_t, as bytes, K, M, T, etc, to a four character compacted human readable string. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The size to format </td></tr>
    <tr><td class="paramname">buf</td><td>The 5 byte text buffer (counting the trailing null) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The buf passed to apr_strfsize() </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>All negative sizes report ' - ', apr_strfsize only formats positive values.</dd></dl>
<p>Determine if the array is empty (either NULL or having no elements). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The array to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if empty, False otherwise</dd></dl>
<p>Remove an element from an array (as a first-in, last-out stack). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>The array to remove an element from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Location of the element in the array. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If there are no elements in the array, NULL is returned.</dd></dl>
<p>Concatenate two arrays together. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>The destination array, and the one to go first in the combined array </td></tr>
    <tr><td class="paramname">src</td><td>The source array to add to the destination array</td></tr>
  </table>
  </dd>
</dl>
<p>Copy the entire array. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The pool to allocate the copy of the array out of </td></tr>
    <tr><td class="paramname">arr</td><td>The array to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An exact copy of the array passed in </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The alternate apr_array_copy_hdr copies only the header, and arranges for the elements to be copied if (and only if) the code subsequently does a push or arraycat.</dd></dl>
<p>Copy the headers of the array, and arrange for the elements to be copied if and only if the code subsequently does a push or arraycat. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The pool to allocate the copy of the array out of </td></tr>
    <tr><td class="paramname">arr</td><td>The array to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An exact copy of the array passed in </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The alternate apr_array_copy copies the <em>entire</em> array.</dd></dl>
<p>Append one array to the end of another, creating a new array in the process. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The pool to allocate the new array out of </td></tr>
    <tr><td class="paramname">first</td><td>The array to put first in the new array. </td></tr>
    <tr><td class="paramname">second</td><td>The array to put second in the new array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new array containing the data from the two arrays passed in.</dd></dl>
<p>Create a new table and copy another table into it. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The pool to allocate the new table out of </td></tr>
    <tr><td class="paramname">t</td><td>The table to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A copy of the table passed in </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The table keys and respective values are not copied</dd></dl>
<p>Create a new table whose contents are deep copied from the given table. A deep copy operation copies all fields, and makes copies of dynamically allocated memory pointed to by the fields. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The pool to allocate the new table out of </td></tr>
    <tr><td class="paramname">t</td><td>The table to clone </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A deep copy of the table passed in</dd></dl>
<p>Delete all of the elements from a table. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The table to clear</td></tr>
  </table>
  </dd>
</dl>
<p>Get values associated with a given key from the table. If more than one value exists, return a comma separated list of values. After this call, the data is still in the table. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The pool to allocate the combined value from, if necessary </td></tr>
    <tr><td class="paramname">t</td><td>The table to search for the key </td></tr>
    <tr><td class="paramname">key</td><td>The key to search for (case does not matter) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value associated with the key, or NULL if the key does not exist.</dd></dl>
<p>Add a key/value pair to a table. If another element already exists with the same key, this will overwrite the old data. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The table to add the data to. </td></tr>
    <tr><td class="paramname">key</td><td>The key to use (case does not matter) </td></tr>
    <tr><td class="paramname">val</td><td>The value to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>When adding data, this function makes a copy of both the key and the value.</dd></dl>
<p>Add a key/value pair to a table. If another element already exists with the same key, this will overwrite the old data. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The table to add the data to. </td></tr>
    <tr><td class="paramname">key</td><td>The key to use (case does not matter) </td></tr>
    <tr><td class="paramname">val</td><td>The value to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>When adding data, this function does not make a copy of the key or the value, so care should be taken to ensure that the values will not change after they have been added..</dd></dl>
<p>Remove data from the table. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The table to remove data from </td></tr>
    <tr><td class="paramname">key</td><td>The key of the data being removed (case does not matter)</td></tr>
  </table>
  </dd>
</dl>
<p>Add data to a table by merging the value with data that has already been stored. The merging is done by concatenating the two values, separated by the string ", ". </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The table to search for the data </td></tr>
    <tr><td class="paramname">key</td><td>The key to merge data for (case does not matter) </td></tr>
    <tr><td class="paramname">val</td><td>The data to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the key is not found, then this function acts like apr_table_add</dd></dl>
<p>Add data to a table by merging the value with data that has already been stored. The merging is done by concatenating the two values, separated by the string ", ". </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The table to search for the data </td></tr>
    <tr><td class="paramname">key</td><td>The key to merge data for (case does not matter) </td></tr>
    <tr><td class="paramname">val</td><td>The data to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the key is not found, then this function acts like apr_table_addn</dd></dl>
<p>Add data to a table, regardless of whether there is another element with the same key. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The table to add to </td></tr>
    <tr><td class="paramname">key</td><td>The key to use </td></tr>
    <tr><td class="paramname">val</td><td>The value to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>When adding data, this function makes a copy of both the key and the value.</dd></dl>
<p>Add data to a table, regardless of whether there is another element with the same key. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The table to add to </td></tr>
    <tr><td class="paramname">key</td><td>The key to use </td></tr>
    <tr><td class="paramname">val</td><td>The value to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>When adding data, this function does not make a copy of the key or the value, so care should be taken to ensure that the values will not change after they have been added.</dd></dl>
<p>Merge two tables into one new table. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The pool to use for the new table </td></tr>
    <tr><td class="paramname">overlay</td><td>The first table to put in the new table </td></tr>
    <tr><td class="paramname">base</td><td>The table to add at the end of the new table </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new table containing all of the data from the two passed in</dd></dl>
<p>Iterate over a table running the provided function once for every element in the table. The vp varargs parameter must be a list of zero or more (char *) keys followed by a NULL pointer. If zero keys are given, the </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comp</td><td>function will be invoked for every element in the table. Otherwise, the function is invoked only for those elements matching the keys specified.</td></tr>
  </table>
  </dd>
</dl>
<p>If an invocation of the comp function returns zero, iteration will continue using the next specified key, if any.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comp</td><td>The function to run </td></tr>
    <tr><td class="paramname">rec</td><td>The data to pass as the first argument to the function </td></tr>
    <tr><td class="paramname">t</td><td>The table to iterate over </td></tr>
    <tr><td class="paramname">vp</td><td>List of zero or more (char *) keys followed by NULL </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>FALSE if one of the <a class="el" href="group__apr__skiplist.html#ga4c81b1eebdb8efeefcadd27cb3fe1c31">comp()</a> iterations returned zero; TRUE if all iterations returned non-zero </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__apr__tables.html#gabac50c7b2bae5f8cef6245d1959f8b06">apr_table_do_callback_fn_t</a> </dd>
<dd>
apr_table_do</dd></dl>
<p>For each element in table b, either use setn or mergen to add the data to table a. Which method is used is determined by the flags passed in. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The table to add the data to. </td></tr>
    <tr><td class="paramname">b</td><td>The table to iterate over, adding its data to table a </td></tr>
    <tr><td class="paramname">flags</td><td>How to add the table to table a. One of: APR_OVERLAP_TABLES_SET Use apr_table_setn APR_OVERLAP_TABLES_MERGE Use apr_table_mergen APR_OVERLAP_TABLES_ADD Use apr_table_addn </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>When merging duplicates, the two values are concatenated, separated by the string ", ". </dd>
<dd>
This function is highly optimized, and uses less memory and CPU cycles than a function that just loops through table b calling other functions. Conceptually, apr_table_overlap does this:</dd></dl>
<pre>
 <a class="el" href="structapr__array__header__t.html">apr_array_header_t</a> *barr = apr_table_elts(b);
 <a class="el" href="structapr__table__entry__t.html">apr_table_entry_t</a> *belt = (<a class="el" href="structapr__table__entry__t.html">apr_table_entry_t</a> *)barr-&gt;elts;
 int i;</pre><pre> for (i = 0; i &lt; barr-&gt;nelts; ++i) {
     if (flags &amp; APR_OVERLAP_TABLES_MERGE) {
         apr_table_mergen(a, belt[i].key, belt[i].val);
     }
     else if (flags &amp; APR_OVERLAP_TABLES_ADD) {
         apr_table_addn(a, belt[i].key, belt[i].val);
     }
     else {
         apr_table_setn(a, belt[i].key, belt[i].val);
     }
 }
</pre><p>Except that it is more efficient (less space and cpu-time) especially when b has many elements.</p>
<p>Notice the assumptions on the keys and values in b &ndash; they must be in an ancestor of a's pool. In practice b and a are usually from the same pool.</p>
<p>Eliminate redundant entries in a table by either overwriting or merging duplicates.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Table. </td></tr>
    <tr><td class="paramname">flags</td><td>APR_OVERLAP_TABLES_MERGE to merge, or APR_OVERLAP_TABLES_SET to overwrite, or APR_OVERLAP_TABLES_ADD to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>When merging duplicates, the two values are concatenated, separated by the string ", ".</dd></dl>
<p>Put the active calling thread to sleep until signaled to wake up. Each condition variable must be associated with a mutex, and that mutex must be locked before calling this function, or the behavior will be undefined. As the calling thread is put to sleep, the given mutex will be simultaneously released; and as this thread wakes up the lock is again simultaneously acquired. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cond</td><td>the condition variable on which to block. </td></tr>
    <tr><td class="paramname">mutex</td><td>the mutex that must be locked upon entering this function, is released while the thread is asleep, and is again acquired before returning from this function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Spurious wakeups may occur. Before and after every call to wait on a condition variable, the caller should test whether the condition is already met.</dd></dl>
<p>Put the active calling thread to sleep until signaled to wake up or the timeout is reached. Each condition variable must be associated with a mutex, and that mutex must be locked before calling this function, or the behavior will be undefined. As the calling thread is put to sleep, the given mutex will be simultaneously released; and as this thread wakes up the lock is again simultaneously acquired. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cond</td><td>the condition variable on which to block. </td></tr>
    <tr><td class="paramname">mutex</td><td>the mutex that must be locked upon entering this function, is released while the thread is asleep, and is again acquired before returning from this function. </td></tr>
    <tr><td class="paramname">timeout</td><td>The amount of time in microseconds to wait. This is a maximum, not a minimum. If the condition is signaled, we will wake up before this time, otherwise the error APR_TIMEUP is returned.</td></tr>
  </table>
  </dd>
</dl>
<p>Signals a single thread, if one exists, that is blocking on the given condition variable. That thread is then scheduled to wake up and acquire the associated mutex. Although it is not required, if predictable scheduling is desired, that mutex must be locked while calling this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cond</td><td>the condition variable on which to produce the signal. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If no threads are waiting on the condition variable, nothing happens.</dd></dl>
<p>Signals all threads blocking on the given condition variable. Each thread that was signaled is then scheduled to wake up and acquire the associated mutex. This will happen in a serialized manner. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cond</td><td>the condition variable on which to produce the broadcast. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If no threads are waiting on the condition variable, nothing happens.</dd></dl>
<p>Destroy the condition variable and free the associated memory. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cond</td><td>the condition variable to destroy.</td></tr>
  </table>
  </dd>
</dl>
<p>Set if newly created threads should be created in detached state. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr</td><td>The threadattr to affect </td></tr>
    <tr><td class="paramname">on</td><td>Non-zero if detached threads should be created.</td></tr>
  </table>
  </dd>
</dl>
<p>Get the detach state for this threadattr. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr</td><td>The threadattr to reference </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>APR_DETACH if threads are to be detached, or APR_NOTDETACH if threads are to be joinable.</dd></dl>
<p>Set the stack size of newly created threads. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr</td><td>The threadattr to affect </td></tr>
    <tr><td class="paramname">stacksize</td><td>The stack size in bytes</td></tr>
  </table>
  </dd>
</dl>
<p>Set the stack guard area size of newly created threads. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr</td><td>The threadattr to affect </td></tr>
    <tr><td class="paramname">guardsize</td><td>The stack guard area size in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Thread library implementations commonly use a "guard area" after each thread's stack which is not readable or writable such that stack overflows cause a segfault; this consumes e.g. 4K of memory and increases memory management overhead. Setting the guard area size to zero hence trades off reliable behaviour on stack overflow for performance.</dd></dl>
<p>Create a new thread of execution </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_thread</td><td>The newly created thread handle. </td></tr>
    <tr><td class="paramname">attr</td><td>The threadattr to use to determine how to create the thread </td></tr>
    <tr><td class="paramname">func</td><td>The function to start the new thread in </td></tr>
    <tr><td class="paramname">data</td><td>Any data to be passed to the starting function </td></tr>
    <tr><td class="paramname">cont</td><td>The pool to use</td></tr>
  </table>
  </dd>
</dl>
<p>stop the current thread </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>The thread to stop </td></tr>
    <tr><td class="paramname">retval</td><td>The return value to pass back to any thread that cares</td></tr>
  </table>
  </dd>
</dl>
<p>block until the desired thread stops executing. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">retval</td><td>The return value from the dead thread. </td></tr>
    <tr><td class="paramname">thd</td><td>The thread to join</td></tr>
  </table>
  </dd>
</dl>
<p>Initialize the control variable for apr_thread_once. If this isn't called, apr_initialize won't work. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">control</td><td>The control variable to initialize </td></tr>
    <tr><td class="paramname">p</td><td>The pool to allocate data from.</td></tr>
  </table>
  </dd>
</dl>
<p>Run the specified function one time, regardless of how many threads call it. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">control</td><td>The control variable. The same variable should be passed in each time the function is tried to be called. This is how the underlying functions determine if the function has ever been called before. </td></tr>
    <tr><td class="paramname">func</td><td>The function to call.</td></tr>
  </table>
  </dd>
</dl>
<p>detach a thread </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>The thread to detach</td></tr>
  </table>
  </dd>
</dl>
<p>Return user data associated with the current thread. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The user data associated with the thread. </td></tr>
    <tr><td class="paramname">key</td><td>The key to associate with the data </td></tr>
    <tr><td class="paramname">thread</td><td>The currently open thread.</td></tr>
  </table>
  </dd>
</dl>
<p>Set user data associated with the current thread. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The user data to associate with the thread. </td></tr>
    <tr><td class="paramname">key</td><td>The key to use for associating the data with the thread </td></tr>
    <tr><td class="paramname">cleanup</td><td>The cleanup routine to use when the thread is destroyed. </td></tr>
    <tr><td class="paramname">thread</td><td>The currently open thread.</td></tr>
  </table>
  </dd>
</dl>
<p>Create and initialize a new thread private address space </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The thread private handle. </td></tr>
    <tr><td class="paramname">dest</td><td>The destructor to use when freeing the private memory. </td></tr>
    <tr><td class="paramname">cont</td><td>The pool to use</td></tr>
  </table>
  </dd>
</dl>
<p>Get a pointer to the thread private memory </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_mem</td><td>The data stored in private memory </td></tr>
    <tr><td class="paramname">key</td><td>The handle for the desired thread private memory</td></tr>
  </table>
  </dd>
</dl>
<p>Set the data to be stored in thread private memory </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">priv</td><td>The data to be stored in private memory </td></tr>
    <tr><td class="paramname">key</td><td>The handle for the desired thread private memory</td></tr>
  </table>
  </dd>
</dl>
<p>Free the thread private memory </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The handle for the desired thread private memory</td></tr>
  </table>
  </dd>
</dl>
<p>Return the pool associated with the current threadkey. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The user data associated with the threadkey. </td></tr>
    <tr><td class="paramname">key</td><td>The key associated with the data </td></tr>
    <tr><td class="paramname">threadkey</td><td>The currently open threadkey.</td></tr>
  </table>
  </dd>
</dl>
<p>Return the pool associated with the current threadkey. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to set. </td></tr>
    <tr><td class="paramname">key</td><td>The key to associate with the data. </td></tr>
    <tr><td class="paramname">cleanup</td><td>The cleanup routine to use when the file is destroyed. </td></tr>
    <tr><td class="paramname">threadkey</td><td>The currently open threadkey.</td></tr>
  </table>
  </dd>
</dl>
<p>Create and initialize a new procattr variable </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_attr</td><td>The newly created procattr. </td></tr>
    <tr><td class="paramname">cont</td><td>The pool to use</td></tr>
  </table>
  </dd>
</dl>
<p>Determine if any of stdin, stdout, or stderr should be linked to pipes when starting a child process. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr</td><td>The procattr we care about. </td></tr>
    <tr><td class="paramname">in</td><td>Should stdin be a pipe back to the parent? </td></tr>
    <tr><td class="paramname">out</td><td>Should stdout be a pipe back to the parent? </td></tr>
    <tr><td class="paramname">err</td><td>Should stderr be a pipe back to the parent? </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If APR_NO_PIPE, there will be no special channel, the child inherits the parent's corresponding stdio stream. If APR_NO_FILE is specified, that corresponding stream is closed in the child (and will be INVALID_HANDLE_VALUE when inspected on Win32). This can have ugly side effects, as the next file opened in the child on Unix will fall into the stdio stream fd slot!</dd></dl>
<p>Set the child_in and/or parent_in values to existing <a class="el" href="structapr__file__t.html">apr_file_t</a> values. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr</td><td>The procattr we care about. </td></tr>
    <tr><td class="paramname">child_in</td><td><a class="el" href="structapr__file__t.html">apr_file_t</a> value to use as child_in. Must be a valid file. </td></tr>
    <tr><td class="paramname">parent_in</td><td><a class="el" href="structapr__file__t.html">apr_file_t</a> value to use as parent_in. Must be a valid file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This is NOT a required initializer function. This is useful if you have already opened a pipe (or multiple files) that you wish to use, perhaps persistently across multiple process invocations - such as a log file. You can save some extra function calls by not creating your own pipe since this creates one in the process space for you. </dd></dl>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000014">Bug:</a></b></dt><dd>Note that calling this function with two NULL files on some platforms creates an APR_FULL_BLOCK pipe, but this behavior is neither portable nor is it supported.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>apr_procattr_io_set instead for simple pipes.</dd></dl>
<p>Set the child_out and parent_out values to existing <a class="el" href="structapr__file__t.html">apr_file_t</a> values. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr</td><td>The procattr we care about. </td></tr>
    <tr><td class="paramname">child_out</td><td><a class="el" href="structapr__file__t.html">apr_file_t</a> value to use as child_out. Must be a valid file. </td></tr>
    <tr><td class="paramname">parent_out</td><td><a class="el" href="structapr__file__t.html">apr_file_t</a> value to use as parent_out. Must be a valid file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This is NOT a required initializer function. This is useful if you have already opened a pipe (or multiple files) that you wish to use, perhaps persistently across multiple process invocations - such as a log file. </dd></dl>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000015">Bug:</a></b></dt><dd>Note that calling this function with two NULL files on some platforms creates an APR_FULL_BLOCK pipe, but this behavior is neither portable nor is it supported.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>apr_procattr_io_set instead for simple pipes.</dd></dl>
<p>Set the child_err and parent_err values to existing <a class="el" href="structapr__file__t.html">apr_file_t</a> values. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr</td><td>The procattr we care about. </td></tr>
    <tr><td class="paramname">child_err</td><td><a class="el" href="structapr__file__t.html">apr_file_t</a> value to use as child_err. Must be a valid file. </td></tr>
    <tr><td class="paramname">parent_err</td><td><a class="el" href="structapr__file__t.html">apr_file_t</a> value to use as parent_err. Must be a valid file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This is NOT a required initializer function. This is useful if you have already opened a pipe (or multiple files) that you wish to use, perhaps persistently across multiple process invocations - such as a log file. </dd></dl>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000016">Bug:</a></b></dt><dd>Note that calling this function with two NULL files on some platforms creates an APR_FULL_BLOCK pipe, but this behavior is neither portable nor is it supported.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>apr_procattr_io_set instead for simple pipes.</dd></dl>
<p>Set which directory the child process should start executing in. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr</td><td>The procattr we care about. </td></tr>
    <tr><td class="paramname">dir</td><td>Which dir to start in. By default, this is the same dir as the parent currently resides in, when the createprocess call is made.</td></tr>
  </table>
  </dd>
</dl>
<p>Set what type of command the child process will call. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr</td><td>The procattr we care about. </td></tr>
    <tr><td class="paramname">cmd</td><td>The type of command. One of: <pre>
           APR_SHELLCMD     &ndash;  Anything that the shell can handle
           APR_PROGRAM      &ndash;  Executable program   (default) 
           APR_PROGRAM_ENV  &ndash;  Executable program, copy environment
           APR_PROGRAM_PATH &ndash;  Executable program on PATH, copy env
</pre></td></tr>
  </table>
  </dd>
</dl>
<p>Determine if the child should start in detached state. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr</td><td>The procattr we care about. </td></tr>
    <tr><td class="paramname">detach</td><td>Should the child start in detached state? Default is no.</td></tr>
  </table>
  </dd>
</dl>
<p>Set the Resource Utilization limits when starting a new process. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr</td><td>The procattr we care about. </td></tr>
    <tr><td class="paramname">what</td><td>Which limit to set, one of: <pre>
                APR_LIMIT_CPU
                APR_LIMIT_MEM
                APR_LIMIT_NPROC
                APR_LIMIT_NOFILE
</pre> </td></tr>
    <tr><td class="paramname">limit</td><td>Value to set the limit to.</td></tr>
  </table>
  </dd>
</dl>
<p>Specify an error function to be called in the child process if APR encounters an error in the child prior to running the specified program. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr</td><td>The procattr describing the child process to be created. </td></tr>
    <tr><td class="paramname">errfn</td><td>The function to call in the child process. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>At the present time, it will only be called from apr_proc_create() on platforms where fork() is used. It will never be called on other platforms, on those platforms apr_proc_create() will return the error in the parent process rather than invoke the callback in the now-forked child process.</dd></dl>
<p>Specify that apr_proc_create() should do whatever it can to report failures to the caller of apr_proc_create(), rather than find out in the child. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr</td><td>The procattr describing the child process to be created. </td></tr>
    <tr><td class="paramname">chk</td><td>Flag to indicate whether or not extra work should be done to try to report failures to the caller. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This flag only affects apr_proc_create() on platforms where fork() is used. This leads to extra overhead in the calling process, but that may help the application handle such errors more gracefully.</dd></dl>
<p>Determine if the child should start in its own address space or using the current one from its parent </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr</td><td>The procattr we care about. </td></tr>
    <tr><td class="paramname">addrspace</td><td>Should the child start in its own address space? Default is no on NetWare and yes on other platforms.</td></tr>
  </table>
  </dd>
</dl>
<p>Set the username used for running process </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr</td><td>The procattr we care about. </td></tr>
    <tr><td class="paramname">username</td><td>The username used </td></tr>
    <tr><td class="paramname">password</td><td>User password if needed. Password is needed on WIN32 or any other platform having APR_PROCATTR_USER_SET_REQUIRES_PASSWORD set.</td></tr>
  </table>
  </dd>
</dl>
<p>Set the group used for running process </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr</td><td>The procattr we care about. </td></tr>
    <tr><td class="paramname">groupname</td><td>The group name used</td></tr>
  </table>
  </dd>
</dl>
<p>Register permission set function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr</td><td>The procattr we care about. </td></tr>
    <tr><td class="paramname">perms_set_fn</td><td>Permission set callback </td></tr>
    <tr><td class="paramname">data</td><td>Data to pass to permission callback function </td></tr>
    <tr><td class="paramname">perms</td><td>Permissions to set</td></tr>
  </table>
  </dd>
</dl>
<p>This is currently the only non-portable call in APR. This executes a standard unix fork. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proc</td><td>The resulting process handle. </td></tr>
    <tr><td class="paramname">cont</td><td>The pool to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>returns APR_INCHILD for the child, and APR_INPARENT for the parent or an error.</dd></dl>
<p>Create a new process and execute a new program within that process. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_proc</td><td>The resulting process handle. </td></tr>
    <tr><td class="paramname">progname</td><td>The program to run </td></tr>
    <tr><td class="paramname">args</td><td>the arguments to pass to the new program. The first one should be the program name. </td></tr>
    <tr><td class="paramname">env</td><td>The new environment table for the new process. This should be a list of NULL-terminated strings. This argument is ignored for APR_PROGRAM_ENV, APR_PROGRAM_PATH, and APR_SHELLCMD_ENV types of commands. </td></tr>
    <tr><td class="paramname">attr</td><td>the procattr we should use to determine how to create the new process </td></tr>
    <tr><td class="paramname">pool</td><td>The pool to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function returns without waiting for the new process to terminate; use apr_proc_wait for that.</dd></dl>
<p>Wait for a child process to die </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proc</td><td>The process handle that corresponds to the desired child process </td></tr>
    <tr><td class="paramname">exitcode</td><td>The returned exit status of the child, if a child process dies, or the signal that caused the child to die. On platforms that don't support obtaining this information, the status parameter will be returned as APR_ENOTIMPL. </td></tr>
    <tr><td class="paramname">exitwhy</td><td>Why the child died, the bitwise or of: <pre>
           APR_PROC_EXIT         -- process terminated normally
           APR_PROC_SIGNAL       -- process was killed by a signal
           APR_PROC_SIGNAL_CORE  -- process was killed by a signal, and
                                    generated a core dump.
</pre> </td></tr>
    <tr><td class="paramname">waithow</td><td>How should we wait. One of: <pre>
           APR_WAIT   -- block until the child process dies.
           APR_NOWAIT -- return immediately regardless of if the 
                         child is dead or not.
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The child's status is in the return code to this process. It is one of: <pre>
           APR_CHILD_DONE     &ndash; child is no longer running.
           APR_CHILD_NOTDONE  &ndash; child is still running.
</pre></dd></dl>
<p>Wait for any current child process to die and return information about that child. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proc</td><td>Pointer to NULL on entry, will be filled out with child's information </td></tr>
    <tr><td class="paramname">exitcode</td><td>The returned exit status of the child, if a child process dies, or the signal that caused the child to die. On platforms that don't support obtaining this information, the status parameter will be returned as APR_ENOTIMPL. </td></tr>
    <tr><td class="paramname">exitwhy</td><td>Why the child died, the bitwise or of: <pre>
           APR_PROC_EXIT         -- process terminated normally
           APR_PROC_SIGNAL       -- process was killed by a signal
           APR_PROC_SIGNAL_CORE  -- process was killed by a signal, and
                                    generated a core dump.
</pre> </td></tr>
    <tr><td class="paramname">waithow</td><td>How should we wait. One of: <pre>
           APR_WAIT   -- block until the child process dies.
           APR_NOWAIT -- return immediately regardless of if the 
                         child is dead or not.
</pre> </td></tr>
    <tr><td class="paramname">p</td><td>Pool to allocate child information out of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000017">Bug:</a></b></dt><dd>Passing proc as a *proc rather than **proc was an odd choice for some platforms... this should be revisited in 1.0 </dd></dl>
<p>Detach the process from the controlling terminal. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">daemonize</td><td>set to non-zero if the process should daemonize and become a background process, else it will stay in the foreground.</td></tr>
  </table>
  </dd>
</dl>
<p>Register an other_child &ndash; a child associated to its registered maintence callback. This callback is invoked when the process dies, is disconnected or disappears. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proc</td><td>The child process to register. </td></tr>
    <tr><td class="paramname">maintenance</td><td>maintenance is a function that is invoked with a reason and the data pointer passed here. </td></tr>
    <tr><td class="paramname">data</td><td>Opaque context data passed to the maintenance function. </td></tr>
    <tr><td class="paramname">write_fd</td><td>An fd that is probed for writing. If it is ever unwritable then the maintenance is invoked with reason OC_REASON_UNWRITABLE. </td></tr>
    <tr><td class="paramname">p</td><td>The pool to use for allocating memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000018">Bug:</a></b></dt><dd><p class="startdd">write_fd duplicates the proc-&gt;out stream, it's really redundant and should be replaced in the APR 1.0 API with a bitflag of which proc-&gt;in/out/err handles should be health checked. </p>
<p class="enddd">no platform currently tests the pipes health. </p>
</dd></dl>
<p>Stop watching the specified other child. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to pass to the maintenance function. This is used to find the process to unregister. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Since this can be called by a maintenance function while we're scanning the other_children list, all scanners should protect themself by loading ocr-&gt;next before calling any maintenance function.</dd></dl>
<p>Notify the maintenance callback of a registered other child process that application has detected an event, such as death. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proc</td><td>The process to check </td></tr>
    <tr><td class="paramname">reason</td><td>The reason code to pass to the maintenance function </td></tr>
    <tr><td class="paramname">status</td><td>The status to pass to the maintenance function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>An example of code using this behavior; <pre>
rv = apr_proc_wait_all_procs(&amp;proc, &amp;exitcode, &amp;status, APR_WAIT, p);
if (<a class="el" href="group__APR__STATUS__IS.html#ga1e6539dfa172cef4026105ca33b2b208">APR_STATUS_IS_CHILD_DONE(rv)</a>) {
#if APR_HAS_OTHER_CHILD
    if (apr_proc_other_child_alert(&amp;proc, APR_OC_REASON_DEATH, status)
            == APR_SUCCESS) {
        ;  (already handled)
    }
    else
#endif
        [... handling non-otherchild processes death ...]
</pre></dd></dl>
<p>Test one specific other child processes and invoke the maintenance callback with the appropriate reason code, if still running, or the appropriate reason code if the process is no longer healthy. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ocr</td><td>The registered other child </td></tr>
    <tr><td class="paramname">reason</td><td>The reason code (e.g. APR_OC_REASON_RESTART) if still running</td></tr>
  </table>
  </dd>
</dl>
<p>Test all registered other child processes and invoke the maintenance callback with the appropriate reason code, if still running, or the appropriate reason code if the process is no longer healthy. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reason</td><td>The reason code (e.g. APR_OC_REASON_RESTART) to running processes</td></tr>
  </table>
  </dd>
</dl>
<p>Terminate a process. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proc</td><td>The process to terminate. </td></tr>
    <tr><td class="paramname">sig</td><td>How to kill the process.</td></tr>
  </table>
  </dd>
</dl>
<p>Register a process to be killed when a pool dies. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The pool to use to define the processes lifetime </td></tr>
    <tr><td class="paramname">proc</td><td>The process to register </td></tr>
    <tr><td class="paramname">how</td><td>How to kill the process, one of: <pre>
        APR_KILL_NEVER         &ndash; process is never sent any signals
        APR_KILL_ALWAYS        &ndash; process is sent SIGKILL on <a class="el" href="structapr__pool__t.html">apr_pool_t</a> cleanup
        APR_KILL_AFTER_TIMEOUT &ndash; SIGTERM, wait 3 seconds, SIGKILL
        APR_JUST_WAIT          &ndash; wait forever for the process to complete
        APR_KILL_ONLY_ONCE     &ndash; send SIGTERM and then wait
</pre></td></tr>
  </table>
  </dd>
</dl>
<p>Setup the process for a single thread to be used for all signal handling. </p><dl class="section warning"><dt>Warning</dt><dd>This must be called before any threads are created</dd></dl>
<p>Make the current thread listen for signals. This thread will loop forever, calling a provided function whenever it receives a signal. That functions should return 1 if the signal has been handled, 0 otherwise. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">signal_handler</td><td>The function to call when a signal is received apr_status_t apr_signal_thread((int)(*signal_handler)(int signum))</td></tr>
  </table>
  </dd>
</dl>
<p>Acquire a shared-read lock on the given read-write lock. This will allow multiple threads to enter the same critical section while they have acquired the read lock. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rwlock</td><td>the read-write lock on which to acquire the shared read.</td></tr>
  </table>
  </dd>
</dl>
<p>Attempt to acquire the shared-read lock on the given read-write lock. This is the same as apr_thread_rwlock_rdlock(), only that the function fails if there is another thread holding the write lock, or if there are any write threads blocking on the lock. If the function fails for this case, APR_EBUSY will be returned. Note: it is important that the <a class="el" href="group__APR__STATUS__IS.html#gabb92ad7b6ef304132de70e9e5cbaa896">APR_STATUS_IS_EBUSY(s)</a> macro be used to determine if the return value was APR_EBUSY, for portability reasons. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rwlock</td><td>the rwlock on which to attempt the shared read.</td></tr>
  </table>
  </dd>
</dl>
<p>Acquire an exclusive-write lock on the given read-write lock. This will allow only one single thread to enter the critical sections. If there are any threads currently holding the read-lock, this thread is put to sleep until it can have exclusive access to the lock. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rwlock</td><td>the read-write lock on which to acquire the exclusive write.</td></tr>
  </table>
  </dd>
</dl>
<p>Attempt to acquire the exclusive-write lock on the given read-write lock. This is the same as apr_thread_rwlock_wrlock(), only that the function fails if there is any other thread holding the lock (for reading or writing), in which case the function will return APR_EBUSY. Note: it is important that the <a class="el" href="group__APR__STATUS__IS.html#gabb92ad7b6ef304132de70e9e5cbaa896">APR_STATUS_IS_EBUSY(s)</a> macro be used to determine if the return value was APR_EBUSY, for portability reasons. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rwlock</td><td>the rwlock on which to attempt the exclusive write.</td></tr>
  </table>
  </dd>
</dl>
<p>Release either the read or write lock currently held by the calling thread associated with the given read-write lock. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rwlock</td><td>the read-write lock to be released (unlocked).</td></tr>
  </table>
  </dd>
</dl>
<p>Destroy the read-write lock and free the associated memory. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rwlock</td><td>the rwlock to destroy.</td></tr>
  </table>
  </dd>
</dl>
<p>Convert a time to its human readable components using an offset from GMT. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>the exploded time </td></tr>
    <tr><td class="paramname">input</td><td>the time to explode </td></tr>
    <tr><td class="paramname">offs</td><td>the number of seconds offset to apply</td></tr>
  </table>
  </dd>
</dl>
<p>Convert a time to its human readable components (GMT). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>the exploded time </td></tr>
    <tr><td class="paramname">input</td><td>the time to explode</td></tr>
  </table>
  </dd>
</dl>
<p>Convert a time to its human readable components in the local timezone. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>the exploded time </td></tr>
    <tr><td class="paramname">input</td><td>the time to explode</td></tr>
  </table>
  </dd>
</dl>
<p>Convert time value from human readable format to a numeric apr_time_t (elapsed microseconds since the epoch). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>the resulting imploded time </td></tr>
    <tr><td class="paramname">input</td><td>the input exploded time</td></tr>
  </table>
  </dd>
</dl>
<p>Convert time value from human readable format to a numeric apr_time_t that always represents GMT. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>the resulting imploded time </td></tr>
    <tr><td class="paramname">input</td><td>the input exploded time</td></tr>
  </table>
  </dd>
</dl>
<p>apr_rfc822_date formats dates in the RFC822 format in an efficient manner. It is a fixed length format which requires APR_RFC822_DATA_LEN bytes of storage, including the trailing NUL terminator. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">date_str</td><td>String to write to. </td></tr>
    <tr><td class="paramname">t</td><td>the time to convert</td></tr>
  </table>
  </dd>
</dl>
<p>apr_ctime formats dates in the ctime() format in an efficient manner. It is a fixed length format and requires APR_CTIME_LEN bytes of storage including the trailing NUL terminator. Unlike ANSI/ISO C ctime(), <a class="el" href="unix_2timestr_8c.html#ad1fcb8f26d508fbb34ea2beca7bc851e">apr_ctime()</a> does not include a \n at the end of the string. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">date_str</td><td>String to write to. </td></tr>
    <tr><td class="paramname">t</td><td>the time to convert</td></tr>
  </table>
  </dd>
</dl>
<p>Formats the exploded time according to the format specified </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>string to write to </td></tr>
    <tr><td class="paramname">retsize</td><td>The length of the returned string </td></tr>
    <tr><td class="paramname">max</td><td>The maximum length of the string </td></tr>
    <tr><td class="paramname">format</td><td>The format for the time string </td></tr>
    <tr><td class="paramname">tm</td><td>The time to convert</td></tr>
  </table>
  </dd>
</dl>
<p>Improve the clock resolution for the lifetime of the given pool. Generally this is only desirable on benchmarking and other very time-sensitive applications, and has no impact on most platforms. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The pool to associate the finer clock resolution</td></tr>
  </table>
  </dd>
</dl>
<p>Get the user name for a specified userid </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">username</td><td>Pointer to new string containing user name (on output) </td></tr>
    <tr><td class="paramname">userid</td><td>The userid </td></tr>
    <tr><td class="paramname">p</td><td>The pool from which to allocate the string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function is available only if APR_HAS_USER is defined.</dd></dl>
<p>Get the userid (and groupid) for the specified username </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">userid</td><td>Returns the user id </td></tr>
    <tr><td class="paramname">groupid</td><td>Returns the user's group id </td></tr>
    <tr><td class="paramname">username</td><td>The username to look up </td></tr>
    <tr><td class="paramname">p</td><td>The pool from which to allocate working space </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function is available only if APR_HAS_USER is defined.</dd></dl>
<p>Get the home directory for the named user </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dirname</td><td>Pointer to new string containing directory name (on output) </td></tr>
    <tr><td class="paramname">username</td><td>The named user </td></tr>
    <tr><td class="paramname">p</td><td>The pool from which to allocate the string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function is available only if APR_HAS_USER is defined.</dd></dl>
<p>Get the group name for a specified groupid </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">groupname</td><td>Pointer to new string containing group name (on output) </td></tr>
    <tr><td class="paramname">groupid</td><td>The groupid </td></tr>
    <tr><td class="paramname">p</td><td>The pool from which to allocate the string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function is available only if APR_HAS_USER is defined.</dd></dl>
<p>Get the groupid for a specified group name </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">groupid</td><td>Pointer to the group id (on output) </td></tr>
    <tr><td class="paramname">groupname</td><td>The group name to look up </td></tr>
    <tr><td class="paramname">p</td><td>The pool from which to allocate the string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function is available only if APR_HAS_USER is defined.</dd></dl>
<p>An APR internal function for fast ucs-2 wide Unicode format conversion to the utf-8 octet-encoded Unicode. This function is used for filename and other resource conversions for platforms providing native Unicode support.</p>
<p>Only the errors APR_EINVAL and APR_INCOMPLETE may occur, the former when the character code is invalid (in or out of context) and the later when more words were expected, but insufficient words remain. </p>
<p>The problem with trying to output the entire iovec is that we cannot maintain the behaviour that a real writev would have. If we iterate over the iovec one at a time, we lose the atomic properties of <a class="el" href="apr__arch__os2calls_8h.html#a3d0f3996136a9b5ab46431c60c746efd">writev()</a>. The other option is to combine the entire iovec into one buffer that we could then send in one call to write(). This is not reasonable since we do not know how much data an iovec could contain.</p>
<p>The only reasonable option, that maintains the semantics of a real <a class="el" href="apr__arch__os2calls_8h.html#a3d0f3996136a9b5ab46431c60c746efd">writev()</a>, is to only write the first iovec. Callers of file_writev() must deal with partial writes as they normally would. If you want to ensure an entire iovec is written, use apr_file_writev_full().</p>

</div>
</div>
<a class="anchor" id="ga09accdea610fa869f6e853529fd584f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__MOD__ISAPI.html#gacd6cdbf73df3d9eed42fa493d9b621a6">void</a> <a class="el" href="group__apr__errno.html#gaa5105fa83cc322f09382292db8b47593">apr_status_t</a>(*) <a class="el" href="group__apr__errno.html#gaa5105fa83cc322f09382292db8b47593">apr_status_t</a>(* child_cleanup) (<a class="el" href="group__MOD__ISAPI.html#gacd6cdbf73df3d9eed42fa493d9b621a6">void</a> *)) <a class="el" href="group__APR__Util__Bucket__Brigades.html#gae0af316ed59541b70389da41aaeef4b6">__attribute__</a>((nonnull(3</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga759cdc4d96e9faaa06ff1cc8ec7962f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__MOD__ISAPI.html#gacd6cdbf73df3d9eed42fa493d9b621a6">void</a> <a class="el" href="group__apr__errno.html#gaa5105fa83cc322f09382292db8b47593">apr_status_t</a>(*) <a class="el" href="group__apr__errno.html#gaa5105fa83cc322f09382292db8b47593">apr_status_t</a>(*) <a class="el" href="group__MOD__ISAPI.html#gacd6cdbf73df3d9eed42fa493d9b621a6">void</a> <a class="el" href="structdata.html">data</a>) </td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga329cbf0c5d8e0c61c40f78cdf67d4471"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__MOD__ISAPI.html#gacd6cdbf73df3d9eed42fa493d9b621a6">void</a> <a class="el" href="group__apr__errno.html#gaa5105fa83cc322f09382292db8b47593">apr_status_t</a>(* plain_cleanup)(<a class="el" href="group__MOD__ISAPI.html#gacd6cdbf73df3d9eed42fa493d9b621a6">void</a> *)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
