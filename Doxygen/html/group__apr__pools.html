<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>My Project: Memory Pool Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Memory Pool Functions<div class="ingroups"><a class="el" href="group__APR.html">Apache Portability Runtime library</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Memory Pool Functions:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__apr__pools.png" border="0" alt="" usemap="#group____apr____pools"/>
<map name="group____apr____pools" id="group____apr____pools">
<area shape="rect" id="node2" href="group__PoolDebug.html" title="Pool Debugging functions." alt="" coords="389,5,564,32"/>
<area shape="rect" id="node3" href="group__PoolCleanup.html" title="Pool Cleanup Functions" alt="" coords="396,56,557,83"/>
<area shape="rect" id="node4" href="group__APR.html" title="Apache Portability\l Runtime library" alt="" coords="5,23,133,65"/>
</map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__PoolCleanup"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PoolCleanup.html">Pool Cleanup Functions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__PoolDebug"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PoolDebug.html">Pool Debugging functions.</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga89ce1d55c7f0c39ea87c88eabd655394"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__pools.html#ga89ce1d55c7f0c39ea87c88eabd655394">APR_POOL_DECLARE_ACCESSOR</a>(<a class="el" href="pcre_8txt.html#a2463fbbe8b0c90b90db12195e1edaa5d">type</a>)</td></tr>
<tr class="separator:ga89ce1d55c7f0c39ea87c88eabd655394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43a8a52f68f8b7d3b7694c254da4a074"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__pools.html#ga43a8a52f68f8b7d3b7694c254da4a074">APR_POOL_IMPLEMENT_ACCESSOR</a>(<a class="el" href="pcre_8txt.html#a2463fbbe8b0c90b90db12195e1edaa5d">type</a>)</td></tr>
<tr class="separator:ga43a8a52f68f8b7d3b7694c254da4a074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac81cff34d0ff4be52fa924663478eade"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__pools.html#gac81cff34d0ff4be52fa924663478eade">APR_POOL__FILE_LINE__</a>&#160;&#160;&#160;__FILE__ &quot;:&quot; <a class="el" href="apr__version_8h.html#ae90215615972dfa4108018304361ef0b">APR_STRINGIFY</a>(__LINE__)</td></tr>
<tr class="separator:gac81cff34d0ff4be52fa924663478eade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7c40921aae156b665e82b0a66991a39"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__pools.html#gaa7c40921aae156b665e82b0a66991a39">apr_pool_create</a>(newpool,  <a class="el" href="group__apr__pools.html#ga3eb8c52002440da9a3eed11d54d08dd5">parent</a>)&#160;&#160;&#160;apr_pool_create_ex(newpool, <a class="el" href="group__apr__pools.html#ga3eb8c52002440da9a3eed11d54d08dd5">parent</a>, <a class="el" href="pcre_8txt.html#ad7f989d16aa8ca809a36bc392c07fba1">NULL</a>, <a class="el" href="pcre_8txt.html#ad7f989d16aa8ca809a36bc392c07fba1">NULL</a>)</td></tr>
<tr class="separator:gaa7c40921aae156b665e82b0a66991a39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5b45d10dd235432a214079792714226"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__pools.html#gac5b45d10dd235432a214079792714226">apr_pool_create_core</a>(newpool)&#160;&#160;&#160;apr_pool_create_unmanaged_ex(newpool, <a class="el" href="pcre_8txt.html#ad7f989d16aa8ca809a36bc392c07fba1">NULL</a>, <a class="el" href="pcre_8txt.html#ad7f989d16aa8ca809a36bc392c07fba1">NULL</a>)</td></tr>
<tr class="separator:gac5b45d10dd235432a214079792714226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03a06feb239bed9edd79a4f59679d56b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__pools.html#ga03a06feb239bed9edd79a4f59679d56b">apr_pool_create_unmanaged</a>(newpool)&#160;&#160;&#160;apr_pool_create_unmanaged_ex(newpool, <a class="el" href="pcre_8txt.html#ad7f989d16aa8ca809a36bc392c07fba1">NULL</a>, <a class="el" href="pcre_8txt.html#ad7f989d16aa8ca809a36bc392c07fba1">NULL</a>)</td></tr>
<tr class="separator:ga03a06feb239bed9edd79a4f59679d56b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad214fc0160de3c22b6435e29ea20fce8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__pools.html#gad214fc0160de3c22b6435e29ea20fce8">apr_pcalloc</a>(<a class="el" href="group__APACHE__CORE__MPM.html#ga5cd91701e5c167f2b1a38e70ab57817e">p</a>,  <a class="el" href="README_8txt.html#a870076999eb1486aa63d2e2cf5cdfa55">size</a>)&#160;&#160;&#160;memset(apr_palloc(<a class="el" href="group__APACHE__CORE__MPM.html#ga5cd91701e5c167f2b1a38e70ab57817e">p</a>, <a class="el" href="README_8txt.html#a870076999eb1486aa63d2e2cf5cdfa55">size</a>), 0, <a class="el" href="README_8txt.html#a870076999eb1486aa63d2e2cf5cdfa55">size</a>)</td></tr>
<tr class="separator:gad214fc0160de3c22b6435e29ea20fce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaf137f28edcf9a086cd6bc36c20d7cdfb"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structapr__pool__t.html">apr_pool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a></td></tr>
<tr class="separator:gaf137f28edcf9a086cd6bc36c20d7cdfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga370a939349adf6d1438068e2fc69a0dd"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="pcre_8txt.html#a42dfa4ff673c82d8efe7144098fbc198">int</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__pools.html#ga370a939349adf6d1438068e2fc69a0dd">apr_abortfunc_t</a>) (<a class="el" href="pcre_8txt.html#a42dfa4ff673c82d8efe7144098fbc198">int</a> retcode)</td></tr>
<tr class="separator:ga370a939349adf6d1438068e2fc69a0dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga95a4b4050d59535eea61951c649d49e6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__pools.html#ga95a4b4050d59535eea61951c649d49e6">APR_DECLARE</a> (<a class="el" href="group__apr__errno.html#gaa5105fa83cc322f09382292db8b47593">apr_status_t</a>) apr_pool_initialize(<a class="el" href="group__MOD__ISAPI.html#gacd6cdbf73df3d9eed42fa493d9b621a6">void</a>)</td></tr>
<tr class="separator:ga95a4b4050d59535eea61951c649d49e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac01d61b42e8b6e65b0da64d18ce146ac"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__pools.html#gac01d61b42e8b6e65b0da64d18ce146ac">APR_DECLARE</a> (<a class="el" href="group__MOD__ISAPI.html#gacd6cdbf73df3d9eed42fa493d9b621a6">void</a>) apr_pool_terminate(<a class="el" href="group__MOD__ISAPI.html#gacd6cdbf73df3d9eed42fa493d9b621a6">void</a>)</td></tr>
<tr class="separator:gac01d61b42e8b6e65b0da64d18ce146ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae343a929da26c12e60a11b0ea647ea90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapr__pool__t.html">apr_pool_t</a> <a class="el" href="group__apr__pools.html#ga370a939349adf6d1438068e2fc69a0dd">apr_abortfunc_t</a> <a class="el" href="structapr__allocator__t.html">apr_allocator_t</a> *<a class="el" href="group__apr__pools.html#ga3d4c7b6ba19a3b46b6fecdee3d867787">allocator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__pools.html#gae343a929da26c12e60a11b0ea647ea90">__attribute__</a> ((nonnull(1)))</td></tr>
<tr class="separator:gae343a929da26c12e60a11b0ea647ea90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f2ec0d4771217976fecfeef29780ab0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__pools.html#ga4f2ec0d4771217976fecfeef29780ab0">APR_DECLARE</a> (<a class="el" href="structapr__allocator__t.html">apr_allocator_t</a> *) apr_pool_allocator_get(<a class="el" href="structapr__pool__t.html">apr_pool_t</a> *<a class="el" href="group__APR__XLATE.html#gabb3cd978f04c73d0b763c391e9bfde73">pool</a>) <a class="el" href="group__APR__Util__Bucket__Brigades.html#gae0af316ed59541b70389da41aaeef4b6">__attribute__</a>((nonnull(1)))</td></tr>
<tr class="separator:ga4f2ec0d4771217976fecfeef29780ab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cb63e2c63fd7769ce05b8bd5d82b833"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__pools.html#ga7cb63e2c63fd7769ce05b8bd5d82b833">APR_DECLARE</a> (<a class="el" href="group__MOD__ISAPI.html#gacd6cdbf73df3d9eed42fa493d9b621a6">void</a> *) apr_palloc(<a class="el" href="structapr__pool__t.html">apr_pool_t</a> *<a class="el" href="group__APACHE__CORE__MPM.html#ga5cd91701e5c167f2b1a38e70ab57817e">p</a></td></tr>
<tr class="separator:ga7cb63e2c63fd7769ce05b8bd5d82b833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab07c79075d4123104a7c152ad13cd63f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapr__pool__t.html">apr_pool_t</a> *<a class="el" href="group__APR__XLATE.html#gabb3cd978f04c73d0b763c391e9bfde73">pool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__pools.html#gab07c79075d4123104a7c152ad13cd63f">__attribute__</a> ((nonnull(2)))</td></tr>
<tr class="separator:gab07c79075d4123104a7c152ad13cd63f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba3977fd7aba8ec156375bf8e6bcf061"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__pools.html#gaba3977fd7aba8ec156375bf8e6bcf061">APR_DECLARE</a> (<a class="el" href="group__apr__pools.html#ga370a939349adf6d1438068e2fc69a0dd">apr_abortfunc_t</a>) apr_pool_abort_get(<a class="el" href="structapr__pool__t.html">apr_pool_t</a> *<a class="el" href="group__APR__XLATE.html#gabb3cd978f04c73d0b763c391e9bfde73">pool</a>) <a class="el" href="group__APR__Util__Bucket__Brigades.html#gae0af316ed59541b70389da41aaeef4b6">__attribute__</a>((nonnull(1)))</td></tr>
<tr class="separator:gaba3977fd7aba8ec156375bf8e6bcf061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga423b5a3ecdf41b53559f971f5777cbc4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__pools.html#ga423b5a3ecdf41b53559f971f5777cbc4">APR_DECLARE</a> (<a class="el" href="structapr__pool__t.html">apr_pool_t</a> *) apr_pool_parent_get(<a class="el" href="structapr__pool__t.html">apr_pool_t</a> *<a class="el" href="group__APR__XLATE.html#gabb3cd978f04c73d0b763c391e9bfde73">pool</a>) <a class="el" href="group__APR__Util__Bucket__Brigades.html#gae0af316ed59541b70389da41aaeef4b6">__attribute__</a>((nonnull(1)))</td></tr>
<tr class="separator:ga423b5a3ecdf41b53559f971f5777cbc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8402402afc75175228d3d177681189b1"><td class="memItemLeft" align="right" valign="top">const char <a class="el" href="structapr__pool__t.html">apr_pool_t</a> *<a class="el" href="group__APR__XLATE.html#gabb3cd978f04c73d0b763c391e9bfde73">pool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__pools.html#ga8402402afc75175228d3d177681189b1">__attribute__</a> ((nonnull(1, 2, 3)))</td></tr>
<tr class="separator:ga8402402afc75175228d3d177681189b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga3eb8c52002440da9a3eed11d54d08dd5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapr__pool__t.html">apr_pool_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__pools.html#ga3eb8c52002440da9a3eed11d54d08dd5">parent</a></td></tr>
<tr class="separator:ga3eb8c52002440da9a3eed11d54d08dd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5a8821081b4fed18bef302377c796e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapr__pool__t.html">apr_pool_t</a> <a class="el" href="group__apr__pools.html#ga370a939349adf6d1438068e2fc69a0dd">apr_abortfunc_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__pools.html#gaf5a8821081b4fed18bef302377c796e4">abort_fn</a></td></tr>
<tr class="separator:gaf5a8821081b4fed18bef302377c796e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d4c7b6ba19a3b46b6fecdee3d867787"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__apr__pools.html#ga370a939349adf6d1438068e2fc69a0dd">apr_abortfunc_t</a> <a class="el" href="structapr__allocator__t.html">apr_allocator_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__pools.html#ga3d4c7b6ba19a3b46b6fecdee3d867787">allocator</a></td></tr>
<tr class="separator:ga3d4c7b6ba19a3b46b6fecdee3d867787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ff83cbf1d5de0befaa318c392539164"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__apr__pools.html#ga370a939349adf6d1438068e2fc69a0dd">apr_abortfunc_t</a> <a class="el" href="structapr__allocator__t.html">apr_allocator_t</a> const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__pools.html#ga6ff83cbf1d5de0befaa318c392539164">file_line</a></td></tr>
<tr class="separator:ga6ff83cbf1d5de0befaa318c392539164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f598d678d0ca77c25732a145c68d3c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__apr__platform.html#gaaa72b2253f6f3032cefea5712a27540e">apr_size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__pools.html#ga5f598d678d0ca77c25732a145c68d3c7">size</a></td></tr>
<tr class="separator:ga5f598d678d0ca77c25732a145c68d3c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e9e9d1380aacd6ec8b616ae04374821"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapr__pool__t.html">apr_pool_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__pools.html#ga2e9e9d1380aacd6ec8b616ae04374821">b</a></td></tr>
<tr class="separator:ga2e9e9d1380aacd6ec8b616ae04374821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd3d88da3c0e0313c3645ff34f62f542"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__pools.html#gacd3d88da3c0e0313c3645ff34f62f542">key</a></td></tr>
<tr class="separator:gacd3d88da3c0e0313c3645ff34f62f542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36572a384d49086c60d5aeec6fea04fc"><td class="memItemLeft" align="right" valign="top">const char <a class="el" href="group__apr__errno.html#gaa5105fa83cc322f09382292db8b47593">apr_status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__pools.html#ga36572a384d49086c60d5aeec6fea04fc">cleanup</a> )(<a class="el" href="group__MOD__ISAPI.html#gacd6cdbf73df3d9eed42fa493d9b621a6">void</a> *)</td></tr>
<tr class="separator:ga36572a384d49086c60d5aeec6fea04fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ac3dbc221e1d805779ab73b97a3566e"><td class="memItemLeft" align="right" valign="top">const char <a class="el" href="group__apr__errno.html#gaa5105fa83cc322f09382292db8b47593">apr_status_t</a>(*) <a class="el" href="structapr__pool__t.html">apr_pool_t</a> *poo&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__pools.html#ga4ac3dbc221e1d805779ab73b97a3566e">__attribute__</a> )((nonnull(2, 4)))</td></tr>
<tr class="separator:ga4ac3dbc221e1d805779ab73b97a3566e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="gad214fc0160de3c22b6435e29ea20fce8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define apr_pcalloc</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="group__APACHE__CORE__MPM.html#ga5cd91701e5c167f2b1a38e70ab57817e">p</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="README_8txt.html#a870076999eb1486aa63d2e2cf5cdfa55">size</a>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;memset(apr_palloc(<a class="el" href="group__APACHE__CORE__MPM.html#ga5cd91701e5c167f2b1a38e70ab57817e">p</a>, <a class="el" href="README_8txt.html#a870076999eb1486aa63d2e2cf5cdfa55">size</a>), 0, <a class="el" href="README_8txt.html#a870076999eb1486aa63d2e2cf5cdfa55">size</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocate a block of memory from a pool and set all of the memory to 0 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The pool to allocate from </td></tr>
    <tr><td class="paramname">size</td><td>The amount of memory to allocate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The allocated memory </dd></dl>

</div>
</div>
<a class="anchor" id="gac81cff34d0ff4be52fa924663478eade"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APR_POOL__FILE_LINE__&#160;&#160;&#160;__FILE__ &quot;:&quot; <a class="el" href="apr__version_8h.html#ae90215615972dfa4108018304361ef0b">APR_STRINGIFY</a>(__LINE__)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pool debug levels</p>
<pre>
<h2>| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
</h2>
</pre><pre>
|   |   |   |   |   |   |   | x |  General debug code enabled (useful in
                                   combination with &ndash;with-efence).</pre><pre>|   |   |   |   |   |   | x |   |  Verbose output on stderr (report
                                   CREATE, CLEAR, DESTROY).</pre><pre>|   |   |   | x |   |   |   |   |  Verbose output on stderr (report
                                   PALLOC, PCALLOC).</pre><pre>|   |   |   |   |   | x |   |   |  Lifetime checking. On each use of a
                                   pool, check its lifetime.  If the pool
                                   is out of scope, abort().
                                   In combination with the verbose flag
                                   above, it will output LIFE in such an
                                   event prior to aborting.</pre><pre>|   |   |   |   | x |   |   |   |  Pool owner checking.  On each use of a
                                   pool, check if the current thread is the
                                   pool's owner.  If not, abort().  In
                                   combination with the verbose flag above,
                                   it will output OWNER in such an event
                                   prior to aborting.  Use the debug
                                   function apr_pool_owner_set() to switch
                                   a pool's ownership.</pre><pre>When no debug level was specified, assume general debug mode.
If level 0 was specified, debugging is switched off.
</pre><p>the place in the code where the particular function was called </p>

</div>
</div>
<a class="anchor" id="gaa7c40921aae156b665e82b0a66991a39"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define apr_pool_create</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">newpool, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="group__apr__pools.html#ga3eb8c52002440da9a3eed11d54d08dd5">parent</a>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;apr_pool_create_ex(newpool, <a class="el" href="group__apr__pools.html#ga3eb8c52002440da9a3eed11d54d08dd5">parent</a>, <a class="el" href="pcre_8txt.html#ad7f989d16aa8ca809a36bc392c07fba1">NULL</a>, <a class="el" href="pcre_8txt.html#ad7f989d16aa8ca809a36bc392c07fba1">NULL</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new pool. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newpool</td><td>The pool we have just created. </td></tr>
    <tr><td class="paramname">parent</td><td>The parent pool. If this is NULL, the new pool is a root pool. If it is non-NULL, the new pool will inherit all of its parent pool's attributes, except the <a class="el" href="structapr__pool__t.html">apr_pool_t</a> will be a sub-pool. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function is thread-safe, in the sense that multiple threads can safely create subpools of the same parent pool concurrently. Similarly, a subpool can be created by one thread at the same time that another thread accesses the parent pool. </dd></dl>

</div>
</div>
<a class="anchor" id="gac5b45d10dd235432a214079792714226"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define apr_pool_create_core</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">newpool</td><td>)</td>
          <td>&#160;&#160;&#160;apr_pool_create_unmanaged_ex(newpool, <a class="el" href="pcre_8txt.html#ad7f989d16aa8ca809a36bc392c07fba1">NULL</a>, <a class="el" href="pcre_8txt.html#ad7f989d16aa8ca809a36bc392c07fba1">NULL</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new unmanaged pool. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newpool</td><td>The pool we have just created. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga03a06feb239bed9edd79a4f59679d56b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define apr_pool_create_unmanaged</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">newpool</td><td>)</td>
          <td>&#160;&#160;&#160;apr_pool_create_unmanaged_ex(newpool, <a class="el" href="pcre_8txt.html#ad7f989d16aa8ca809a36bc392c07fba1">NULL</a>, <a class="el" href="pcre_8txt.html#ad7f989d16aa8ca809a36bc392c07fba1">NULL</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga89ce1d55c7f0c39ea87c88eabd655394"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APR_POOL_DECLARE_ACCESSOR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="pcre_8txt.html#a2463fbbe8b0c90b90db12195e1edaa5d">type</a></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code" href="group__PoolCleanup.html#ga8f8e9a6584250688c1f6d72252321b54">APR_DECLARE</a>(<a class="code" href="structapr__pool__t.html">apr_pool_t</a> *) apr_<span class="preprocessor">##type##_pool_get \</span></div><div class="line"><span class="preprocessor">        (const apr_##type##_t *the##type)</span></div><div class="ttc" id="structapr__pool__t_html"><div class="ttname"><a href="structapr__pool__t.html">apr_pool_t</a></div><div class="ttdef"><b>Definition:</b> apr_pools.c:577</div></div>
<div class="ttc" id="group__PoolCleanup_html_ga8f8e9a6584250688c1f6d72252321b54"><div class="ttname"><a href="group__PoolCleanup.html#ga8f8e9a6584250688c1f6d72252321b54">APR_DECLARE</a></div><div class="ttdeci">const void apr_status_t(*) apr_status_t(* APR_DECLARE)(void) apr_pool_pre_cleanup_register(apr_pool_t *p</div><div class="ttdef"><b>Definition:</b> apr_pools.h:646</div></div>
</div><!-- fragment --><p>Declaration helper macro to construct apr_foo_pool_get()s.</p>
<p>This standardized macro is used by opaque (APR) data types to return the <a class="el" href="structapr__pool__t.html">apr_pool_t</a> that is associated with the data type.</p>
<p><a class="el" href="group__apr__pools.html#ga89ce1d55c7f0c39ea87c88eabd655394">APR_POOL_DECLARE_ACCESSOR()</a> is used in a header file to declare the accessor function. A typical usage and result would be: </p><pre>
   <a class="el" href="group__apr__pools.html#ga89ce1d55c7f0c39ea87c88eabd655394">APR_POOL_DECLARE_ACCESSOR(file)</a>;
becomes:
   <a class="el" href="group__apr__pools.html#ga423b5a3ecdf41b53559f971f5777cbc4">APR_DECLARE(apr_pool_t *)</a> apr_file_pool_get(const apr_file_t *thefile);
</pre> <dl class="section remark"><dt>Remarks</dt><dd>Doxygen unwraps this macro (via doxygen.conf) to provide actual help for each specific occurrence of apr_foo_pool_get. </dd>
<dd>
the linkage is specified for APR. It would be possible to expand the macros to support other linkages. </dd></dl>

</div>
</div>
<a class="anchor" id="ga43a8a52f68f8b7d3b7694c254da4a074"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APR_POOL_IMPLEMENT_ACCESSOR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="pcre_8txt.html#a2463fbbe8b0c90b90db12195e1edaa5d">type</a></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code" href="group__PoolCleanup.html#ga8f8e9a6584250688c1f6d72252321b54">APR_DECLARE</a>(<a class="code" href="structapr__pool__t.html">apr_pool_t</a> *) apr_<span class="preprocessor">##type##_pool_get \</span></div><div class="line"><span class="preprocessor">            (const apr_##type##_t *the##type) \</span></div><div class="line"><span class="preprocessor">        { return the##type-&gt;pool; }</span></div><div class="ttc" id="structapr__pool__t_html"><div class="ttname"><a href="structapr__pool__t.html">apr_pool_t</a></div><div class="ttdef"><b>Definition:</b> apr_pools.c:577</div></div>
<div class="ttc" id="group__PoolCleanup_html_ga8f8e9a6584250688c1f6d72252321b54"><div class="ttname"><a href="group__PoolCleanup.html#ga8f8e9a6584250688c1f6d72252321b54">APR_DECLARE</a></div><div class="ttdeci">const void apr_status_t(*) apr_status_t(* APR_DECLARE)(void) apr_pool_pre_cleanup_register(apr_pool_t *p</div><div class="ttdef"><b>Definition:</b> apr_pools.h:646</div></div>
</div><!-- fragment --><p>Implementation helper macro to provide apr_foo_pool_get()s.</p>
<p>In the implementation, the <a class="el" href="group__apr__pools.html#ga43a8a52f68f8b7d3b7694c254da4a074">APR_POOL_IMPLEMENT_ACCESSOR()</a> is used to actually define the function. It assumes the field is named "pool". </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga370a939349adf6d1438068e2fc69a0dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="pcre_8txt.html#a42dfa4ff673c82d8efe7144098fbc198">int</a>(* apr_abortfunc_t) (<a class="el" href="pcre_8txt.html#a42dfa4ff673c82d8efe7144098fbc198">int</a> retcode)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A function that is called when allocation fails. </p>

</div>
</div>
<a class="anchor" id="gaf137f28edcf9a086cd6bc36c20d7cdfb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structapr__pool__t.html">apr_pool_t</a> <a class="el" href="structapr__pool__t.html">apr_pool_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The fundamental pool type </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gae343a929da26c12e60a11b0ea647ea90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapr__pool__t.html">apr_pool_t</a> <a class="el" href="group__apr__pools.html#ga370a939349adf6d1438068e2fc69a0dd">apr_abortfunc_t</a> <a class="el" href="structapr__allocator__t.html">apr_allocator_t</a>* <a class="el" href="group__apr__pools.html#ga3d4c7b6ba19a3b46b6fecdee3d867787">allocator</a> __attribute__ </td>
          <td>(</td>
          <td class="paramtype">(nonnull(1))&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gab07c79075d4123104a7c152ad13cd63f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapr__pool__t.html">apr_pool_t</a>* <a class="el" href="group__APR__XLATE.html#gabb3cd978f04c73d0b763c391e9bfde73">pool</a> __attribute__ </td>
          <td>(</td>
          <td class="paramtype">(nonnull(2))&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga8402402afc75175228d3d177681189b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char <a class="el" href="structapr__pool__t.html">apr_pool_t</a>* <a class="el" href="group__APR__XLATE.html#gabb3cd978f04c73d0b763c391e9bfde73">pool</a> __attribute__ </td>
          <td>(</td>
          <td class="paramtype">(nonnull(1, 2, 3))&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga95a4b4050d59535eea61951c649d49e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">APR_DECLARE </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apr__errno.html#gaa5105fa83cc322f09382292db8b47593">apr_status_t</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Setup all of the internal structures required to use pools </p><dl class="section remark"><dt>Remarks</dt><dd>Programs do NOT need to call this directly. APR will call this automatically from apr_initialize.</dd></dl>
<p>Create a new pool. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newpool</td><td>The pool we have just created. </td></tr>
    <tr><td class="paramname">parent</td><td>The parent pool. If this is NULL, the new pool is a root pool. If it is non-NULL, the new pool will inherit all of its parent pool's attributes, except the <a class="el" href="structapr__pool__t.html">apr_pool_t</a> will be a sub-pool. </td></tr>
    <tr><td class="paramname">abort_fn</td><td>A function to use if the pool cannot allocate more memory. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use with the new pool. If NULL the allocator of the parent pool will be used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function is thread-safe, in the sense that multiple threads can safely create subpools of the same parent pool concurrently. Similarly, a subpool can be created by one thread at the same time that another thread accesses the parent pool.</dd></dl>
<p>Create a new pool. </p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000041">Deprecated:</a></b></dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd>apr_pool_create_unmanaged_ex.</dd></dl>
<p>Create a new unmanaged pool. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newpool</td><td>The pool we have just created. </td></tr>
    <tr><td class="paramname">abort_fn</td><td>A function to use if the pool cannot allocate more memory. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use with the new pool. If NULL a new allocator will be created with the new pool as owner. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>An unmanaged pool is a special pool without a parent; it will NOT be destroyed upon apr_terminate. It must be explicitly destroyed by calling apr_pool_destroy, to prevent memory leaks. Use of this function is discouraged, think twice about whether you really really need it. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Any child cleanups registered against the new pool, or against sub-pools thereof, will not be executed during an invocation of apr_proc_create(), so resources created in an "unmanaged" pool hierarchy will leak to child processes.</dd></dl>
<p>Debug version of apr_pool_create_ex. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newpool</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__apr__pools.html#gaa7c40921aae156b665e82b0a66991a39">apr_pool_create</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__apr__pools.html#gaa7c40921aae156b665e82b0a66991a39">apr_pool_create</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">abort_fn</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__apr__pools.html#gaa7c40921aae156b665e82b0a66991a39">apr_pool_create</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__apr__pools.html#gaa7c40921aae156b665e82b0a66991a39">apr_pool_create</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file_line</td><td>Where the function is called from. This is usually APR_POOL__FILE_LINE__. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Only available when APR_POOL_DEBUG is defined. Call this directly if you have your apr_pool_create_ex calls in a wrapper function and wish to override the file_line argument to reflect the caller of your wrapper function. If you do not have apr_pool_create_ex in a wrapper, trust the macro and don't call apr_pool_create_ex_debug directly.</dd></dl>
<p>Debug version of apr_pool_create_core_ex. </p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000042">Deprecated:</a></b></dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd>apr_pool_create_unmanaged_ex_debug.</dd></dl>
<p>Debug version of apr_pool_create_unmanaged_ex. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newpool</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__apr__pools.html#ga03a06feb239bed9edd79a4f59679d56b">apr_pool_create_unmanaged</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">abort_fn</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__apr__pools.html#ga03a06feb239bed9edd79a4f59679d56b">apr_pool_create_unmanaged</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__apr__pools.html#ga03a06feb239bed9edd79a4f59679d56b">apr_pool_create_unmanaged</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file_line</td><td>Where the function is called from. This is usually APR_POOL__FILE_LINE__. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Only available when APR_POOL_DEBUG is defined. Call this directly if you have your apr_pool_create_unmanaged_ex calls in a wrapper function and wish to override the file_line argument to reflect the caller of your wrapper function. If you do not have apr_pool_create_core_ex in a wrapper, trust the macro and don't call apr_pool_create_core_ex_debug directly.</dd></dl>
<p>Determine if pool a is an ancestor of pool b. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The pool to search </td></tr>
    <tr><td class="paramname">b</td><td>The pool to search for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if a is an ancestor of b, NULL is considered an ancestor of all pools. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>if compiled with APR_POOL_DEBUG, this function will also return true if A is a pool which has been guaranteed by the caller (using apr_pool_join) to have a lifetime at least as long as some ancestor of pool B.</dd></dl>
<p>Set the data associated with the current pool </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The user data associated with the pool. </td></tr>
    <tr><td class="paramname">key</td><td>The key to use for association </td></tr>
    <tr><td class="paramname">cleanup</td><td>The cleanup program to use to cleanup the data (NULL if none) </td></tr>
    <tr><td class="paramname">pool</td><td>The current pool </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>The data to be attached to the pool should have a life span at least as long as the pool it is being attached to.</dd></dl>
<p>Users of APR must take EXTREME care when choosing a key to use for their data. It is possible to accidentally overwrite data by choosing a key that another part of the program is using. Therefore it is advised that steps are taken to ensure that unique keys are used for all of the userdata objects in a particular pool (the same key in two different pools or a pool and one of its subpools is okay) at all times. Careful namespace prefixing of key names is a typical way to help ensure this uniqueness.</p>
<p>Set the data associated with the current pool </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The user data associated with the pool. </td></tr>
    <tr><td class="paramname">key</td><td>The key to use for association </td></tr>
    <tr><td class="paramname">cleanup</td><td>The cleanup program to use to cleanup the data (NULL if none) </td></tr>
    <tr><td class="paramname">pool</td><td>The current pool </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>same as apr_pool_userdata_set(), except that this version doesn't make a copy of the key (this function is useful, for example, when the key is a string literal) </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This should NOT be used if the key could change addresses by any means between the apr_pool_userdata_setn() call and a subsequent apr_pool_userdata_get() on that key, such as if a static string is used as a userdata key in a DSO and the DSO could be unloaded and reloaded between the _setn() and the _get(). You MUST use apr_pool_userdata_set() in such cases. </dd>
<dd>
More generally, the key and the data to be attached to the pool should have a life span at least as long as the pool itself.</dd></dl>
<p>Return the data associated with the current pool. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The user data associated with the pool. </td></tr>
    <tr><td class="paramname">key</td><td>The key for the data to retrieve </td></tr>
    <tr><td class="paramname">pool</td><td>The current pool. </td></tr>
  </table>
  </dd>
</dl>
<p>The problem with trying to output the entire iovec is that we cannot maintain the behaviour that a real writev would have. If we iterate over the iovec one at a time, we lose the atomic properties of <a class="el" href="apr__arch__os2calls_8h.html#a3d0f3996136a9b5ab46431c60c746efd">writev()</a>. The other option is to combine the entire iovec into one buffer that we could then send in one call to write(). This is not reasonable since we do not know how much data an iovec could contain.</p>
<p>The only reasonable option, that maintains the semantics of a real <a class="el" href="apr__arch__os2calls_8h.html#a3d0f3996136a9b5ab46431c60c746efd">writev()</a>, is to only write the first iovec. Callers of file_writev() must deal with partial writes as they normally would. If you want to ensure an entire iovec is written, use apr_file_writev_full().</p>
<div class="fragment"><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;{</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="group__apr__errno.html#ga9ee311b7bf1c691dc521d721339ee2a6">APR_SUCCESS</a>;</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;}</div><div class="ttc" id="group__apr__errno_html_ga9ee311b7bf1c691dc521d721339ee2a6"><div class="ttname"><a href="group__apr__errno.html#ga9ee311b7bf1c691dc521d721339ee2a6">APR_SUCCESS</a></div><div class="ttdeci">#define APR_SUCCESS</div><div class="ttdef"><b>Definition:</b> apr_errno.h:225</div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="gac01d61b42e8b6e65b0da64d18ce146ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">APR_DECLARE </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__MOD__ISAPI.html#gacd6cdbf73df3d9eed42fa493d9b621a6">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tear down all of the internal structures required to use pools </p><dl class="section remark"><dt>Remarks</dt><dd>Programs do NOT need to call this directly. APR will call this automatically from apr_terminate.</dd></dl>
<p>Clear all memory in the pool and run all the cleanups. This also destroys all subpools. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The pool to clear </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This does not actually free the memory, it just allows the pool to re-use this memory for the next allocation. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>apr_pool_destroy()</dd></dl>
<p>Debug version of apr_pool_clear. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>See: apr_pool_clear. </td></tr>
    <tr><td class="paramname">file_line</td><td>Where the function is called from. This is usually APR_POOL__FILE_LINE__. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Only available when APR_POOL_DEBUG is defined. Call this directly if you have your apr_pool_clear calls in a wrapper function and wish to override the file_line argument to reflect the caller of your wrapper function. If you do not have apr_pool_clear in a wrapper, trust the macro and don't call apr_pool_destroy_clear directly.</dd></dl>
<p>Destroy the pool. This takes similar action as apr_pool_clear() and then frees all the memory. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The pool to destroy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This will actually free the memory</dd></dl>
<p>Debug version of apr_pool_destroy. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>See: apr_pool_destroy. </td></tr>
    <tr><td class="paramname">file_line</td><td>Where the function is called from. This is usually APR_POOL__FILE_LINE__. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Only available when APR_POOL_DEBUG is defined. Call this directly if you have your apr_pool_destroy calls in a wrapper function and wish to override the file_line argument to reflect the caller of your wrapper function. If you do not have apr_pool_destroy in a wrapper, trust the macro and don't call apr_pool_destroy_debug directly.</dd></dl>
<p>Set the function to be called when an allocation failure occurs. </p><dl class="section remark"><dt>Remarks</dt><dd>If the program wants APR to exit on a memory allocation error, then this function can be called to set the callback to use (for performing cleanup and then exiting). If this function is not called, then APR will return an error and expect the calling program to deal with the error accordingly.</dd></dl>
<p>Tag a pool (give it a name) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td>The pool to tag </td></tr>
    <tr><td class="paramname">tag</td><td>The tag</td></tr>
  </table>
  </dd>
</dl>
<p>Register a function to be called when a pool is cleared or destroyed </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The pool to register the cleanup with </td></tr>
    <tr><td class="paramname">data</td><td>The data to pass to the cleanup function. </td></tr>
    <tr><td class="paramname">plain_cleanup</td><td>The function to call when the pool is cleared or destroyed </td></tr>
    <tr><td class="paramname">child_cleanup</td><td>The function to call when a child process is about to exec - this function is called in the child, obviously!</td></tr>
  </table>
  </dd>
</dl>
<p>Remove a previously registered cleanup function.</p>
<p>The cleanup most recently registered with <em>p</em> having the same values of <em>data</em> and <em>cleanup</em> will be removed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The pool to remove the cleanup from </td></tr>
    <tr><td class="paramname">data</td><td>The data of the registered cleanup </td></tr>
    <tr><td class="paramname">cleanup</td><td>The function to remove from cleanup </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>For some strange reason only the plain_cleanup is handled by this function</dd></dl>
<p>Replace the child cleanup function of a previously registered cleanup.</p>
<p>The cleanup most recently registered with <em>p</em> having the same values of <em>data</em> and <em>plain_cleanup</em> will have the registered child cleanup function replaced with <em>child_cleanup</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The pool of the registered cleanup </td></tr>
    <tr><td class="paramname">data</td><td>The data of the registered cleanup </td></tr>
    <tr><td class="paramname">plain_cleanup</td><td>The plain cleanup function of the registered cleanup </td></tr>
    <tr><td class="paramname">child_cleanup</td><td>The function to register as the child cleanup</td></tr>
  </table>
  </dd>
</dl>
<p>Run all registered child cleanups, in preparation for an exec() call in a forked child &ndash; close files, etc., but <em>don't</em> flush I/O buffers, <em>don't</em> wait for subprocesses, and <em>don't</em> free any memory. </p>
<div class="fragment"><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;{</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;    atomic_sub((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *)<a class="code" href="group__MOD__DAV.html#gac8d0feaae3f1c6b0eac72aaa9af557c1">mem</a>,(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)<a class="code" href="group__APACHE__CORE__CONFIG.html#gae553dcb033cb5c1e269683855e4f676a">val</a>);</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;}</div><div class="ttc" id="group__APACHE__CORE__CONFIG_html_gae553dcb033cb5c1e269683855e4f676a"><div class="ttname"><a href="group__APACHE__CORE__CONFIG.html#gae553dcb033cb5c1e269683855e4f676a">val</a></div><div class="ttdeci">const module void * val</div><div class="ttdef"><b>Definition:</b> http_config.h:526</div></div>
<div class="ttc" id="group__MOD__DAV_html_gac8d0feaae3f1c6b0eac72aaa9af557c1"><div class="ttname"><a href="group__MOD__DAV.html#gac8d0feaae3f1c6b0eac72aaa9af557c1">mem</a></div><div class="ttdeci">dav_buffer const void * mem</div><div class="ttdef"><b>Definition:</b> mod_dav.h:471</div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ga4f2ec0d4771217976fecfeef29780ab0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">APR_DECLARE </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapr__allocator__t.html">apr_allocator_t</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the pool's allocator </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td>The pool to get the allocator from. </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a name="l02365"></a><span class="lineno"> 2365</span>&#160;{</div><div class="line"><a name="l02366"></a><span class="lineno"> 2366</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="group__APACHE__CORE__MUTEX.html#ga8fea43b485988aa6df5dced9dddbe733">pool</a>-&gt;<a class="code" href="structapr__pool__t.html#a0b966157de565de389783a833e6baf15">allocator</a>;</div><div class="line"><a name="l02367"></a><span class="lineno"> 2367</span>&#160;}</div><div class="ttc" id="group__APACHE__CORE__MUTEX_html_ga8fea43b485988aa6df5dced9dddbe733"><div class="ttname"><a href="group__APACHE__CORE__MUTEX.html#ga8fea43b485988aa6df5dced9dddbe733">pool</a></div><div class="ttdeci">apr_pool_t * pool</div><div class="ttdef"><b>Definition:</b> util_mutex.h:98</div></div>
<div class="ttc" id="structapr__pool__t_html_a0b966157de565de389783a833e6baf15"><div class="ttname"><a href="structapr__pool__t.html#a0b966157de565de389783a833e6baf15">apr_pool_t::allocator</a></div><div class="ttdeci">apr_allocator_t * allocator</div><div class="ttdef"><b>Definition:</b> apr_pools.c:584</div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__apr__pools_ga4f2ec0d4771217976fecfeef29780ab0_cgraph.png" border="0" usemap="#group__apr__pools_ga4f2ec0d4771217976fecfeef29780ab0_cgraph" alt=""/></div>
<map name="group__apr__pools_ga4f2ec0d4771217976fecfeef29780ab0_cgraph" id="group__apr__pools_ga4f2ec0d4771217976fecfeef29780ab0_cgraph">
<area shape="rect" id="node2" href="group__apr__allocator.html#ga9cb19a118179bbd8625eacfec66a9ab8" title="APR_DECLARE" alt="" coords="175,5,296,32"/>
<area shape="rect" id="node3" href="util__expr__parse_8c.html#a5faf6a2d99f50a4655dd390199a8db7b" title="malloc" alt="" coords="344,5,404,32"/>
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga7cb63e2c63fd7769ce05b8bd5d82b833"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">APR_DECLARE </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__MOD__ISAPI.html#gacd6cdbf73df3d9eed42fa493d9b621a6">void</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocate a block of memory from a pool </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The pool to allocate from </td></tr>
    <tr><td class="paramname">size</td><td>The amount of memory to allocate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The allocated memory</dd></dl>
<p>Debug version of apr_palloc </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>See: apr_palloc </td></tr>
    <tr><td class="paramname">size</td><td>See: apr_palloc </td></tr>
    <tr><td class="paramname">file_line</td><td>Where the function is called from. This is usually APR_POOL__FILE_LINE__. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See: apr_palloc</dd></dl>
<p>Debug version of apr_pcalloc </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>See: apr_pcalloc </td></tr>
    <tr><td class="paramname">size</td><td>See: apr_pcalloc </td></tr>
    <tr><td class="paramname">file_line</td><td>Where the function is called from. This is usually APR_POOL__FILE_LINE__. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See: apr_pcalloc </dd></dl>
<div class="fragment"><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;{</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;    <span class="keywordflow">return</span> (<span class="keywordtype">void</span>*)atomic_cmpxchg((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *)<a class="code" href="group__MOD__DAV.html#gac8d0feaae3f1c6b0eac72aaa9af557c1">mem</a>,(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)<a class="code" href="group__apr__atomic.html#ga337f72af8c74a9110f79160df3bba5e8">cmp</a>,(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)<a class="code" href="group__apr__atomic.html#ga62bdcea60b77e638d3d88947a34aff05">with</a>);</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;}</div><div class="ttc" id="group__apr__atomic_html_ga337f72af8c74a9110f79160df3bba5e8"><div class="ttname"><a href="group__apr__atomic.html#ga337f72af8c74a9110f79160df3bba5e8">cmp</a></div><div class="ttdeci">apr_uint32_t apr_uint32_t cmp</div><div class="ttdef"><b>Definition:</b> apr_atomic.h:105</div></div>
<div class="ttc" id="group__MOD__DAV_html_gac8d0feaae3f1c6b0eac72aaa9af557c1"><div class="ttname"><a href="group__MOD__DAV.html#gac8d0feaae3f1c6b0eac72aaa9af557c1">mem</a></div><div class="ttdeci">dav_buffer const void * mem</div><div class="ttdef"><b>Definition:</b> mod_dav.h:471</div></div>
<div class="ttc" id="group__apr__atomic_html_ga62bdcea60b77e638d3d88947a34aff05"><div class="ttname"><a href="group__apr__atomic.html#ga62bdcea60b77e638d3d88947a34aff05">with</a></div><div class="ttdeci">apr_uint32_t with</div><div class="ttdef"><b>Definition:</b> apr_atomic.h:105</div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="gaba3977fd7aba8ec156375bf8e6bcf061"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">APR_DECLARE </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apr__pools.html#ga370a939349adf6d1438068e2fc69a0dd">apr_abortfunc_t</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the abort function associated with the specified pool. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td>The pool for retrieving the abort function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The abort function for the given pool. </dd></dl>
<div class="fragment"><div class="line"><a name="l02348"></a><span class="lineno"> 2348</span>&#160;{</div><div class="line"><a name="l02349"></a><span class="lineno"> 2349</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="group__APACHE__CORE__MUTEX.html#ga8fea43b485988aa6df5dced9dddbe733">pool</a>-&gt;<a class="code" href="structapr__pool__t.html#a82c4bbe64a436265e0cc050be10b7377">abort_fn</a>;</div><div class="line"><a name="l02350"></a><span class="lineno"> 2350</span>&#160;}</div><div class="ttc" id="group__APACHE__CORE__MUTEX_html_ga8fea43b485988aa6df5dced9dddbe733"><div class="ttname"><a href="group__APACHE__CORE__MUTEX.html#ga8fea43b485988aa6df5dced9dddbe733">pool</a></div><div class="ttdeci">apr_pool_t * pool</div><div class="ttdef"><b>Definition:</b> util_mutex.h:98</div></div>
<div class="ttc" id="structapr__pool__t_html_a82c4bbe64a436265e0cc050be10b7377"><div class="ttname"><a href="structapr__pool__t.html#a82c4bbe64a436265e0cc050be10b7377">apr_pool_t::abort_fn</a></div><div class="ttdeci">apr_abortfunc_t abort_fn</div><div class="ttdef"><b>Definition:</b> apr_pools.c:586</div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__apr__pools_gaba3977fd7aba8ec156375bf8e6bcf061_cgraph.png" border="0" usemap="#group__apr__pools_gaba3977fd7aba8ec156375bf8e6bcf061_cgraph" alt=""/></div>
<map name="group__apr__pools_gaba3977fd7aba8ec156375bf8e6bcf061_cgraph" id="group__apr__pools_gaba3977fd7aba8ec156375bf8e6bcf061_cgraph">
<area shape="rect" id="node2" href="group__apr__allocator.html#ga9cb19a118179bbd8625eacfec66a9ab8" title="APR_DECLARE" alt="" coords="175,5,296,32"/>
<area shape="rect" id="node3" href="util__expr__parse_8c.html#a5faf6a2d99f50a4655dd390199a8db7b" title="malloc" alt="" coords="344,5,404,32"/>
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga423b5a3ecdf41b53559f971f5777cbc4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">APR_DECLARE </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapr__pool__t.html">apr_pool_t</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the parent pool of the specified pool. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td>The pool for retrieving the parent pool. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The parent of the given pool.</dd></dl>
<p>Get the current owner of the allocator </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td>The allocator to get the owner from </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;{</div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="group__apr__pools.html#ga3d4c7b6ba19a3b46b6fecdee3d867787">allocator</a>-&gt;<a class="code" href="structapr__allocator__t.html#a7765c4164197b52893dc4523e3104429">owner</a>;</div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;}</div><div class="ttc" id="structapr__allocator__t_html_a7765c4164197b52893dc4523e3104429"><div class="ttname"><a href="structapr__allocator__t.html#a7765c4164197b52893dc4523e3104429">apr_allocator_t::owner</a></div><div class="ttdeci">apr_pool_t * owner</div><div class="ttdef"><b>Definition:</b> apr_pools.c:142</div></div>
<div class="ttc" id="group__apr__pools_html_ga3d4c7b6ba19a3b46b6fecdee3d867787"><div class="ttname"><a href="group__apr__pools.html#ga3d4c7b6ba19a3b46b6fecdee3d867787">allocator</a></div><div class="ttdeci">apr_abortfunc_t apr_allocator_t * allocator</div><div class="ttdef"><b>Definition:</b> apr_pools.h:207</div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__apr__pools_ga423b5a3ecdf41b53559f971f5777cbc4_cgraph.png" border="0" usemap="#group__apr__pools_ga423b5a3ecdf41b53559f971f5777cbc4_cgraph" alt=""/></div>
<map name="group__apr__pools_ga423b5a3ecdf41b53559f971f5777cbc4_cgraph" id="group__apr__pools_ga423b5a3ecdf41b53559f971f5777cbc4_cgraph">
<area shape="rect" id="node2" href="group__apr__allocator.html#ga9cb19a118179bbd8625eacfec66a9ab8" title="APR_DECLARE" alt="" coords="175,5,296,32"/>
<area shape="rect" id="node3" href="util__expr__parse_8c.html#a5faf6a2d99f50a4655dd390199a8db7b" title="malloc" alt="" coords="344,5,404,32"/>
</map>
</div>
</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="ga4ac3dbc221e1d805779ab73b97a3566e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char *<a class="el" href="group__APACHE__CORE__HTTPD.html#ga7bb5e40c10df6a41df64bda1f4bb3e26">tag</a> __attribute__ </td>
          <td>(</td>
          <td class="paramtype">(nonnull(2, 4))&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gaf5a8821081b4fed18bef302377c796e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__apr__pools.html#ga370a939349adf6d1438068e2fc69a0dd">apr_abortfunc_t</a> abort_fn</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga3d4c7b6ba19a3b46b6fecdee3d867787"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__apr__pools.html#ga370a939349adf6d1438068e2fc69a0dd">apr_abortfunc_t</a> <a class="el" href="structapr__allocator__t.html">apr_allocator_t</a> * allocator</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga2e9e9d1380aacd6ec8b616ae04374821"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapr__pool__t.html">apr_pool_t</a>* b</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga36572a384d49086c60d5aeec6fea04fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__MOD__ISAPI.html#gacd6cdbf73df3d9eed42fa493d9b621a6">void</a> <a class="el" href="group__apr__errno.html#gaa5105fa83cc322f09382292db8b47593">apr_status_t</a>(*) <a class="el" href="group__apr__errno.html#gaa5105fa83cc322f09382292db8b47593">apr_status_t</a>(*) <a class="el" href="group__MOD__ISAPI.html#gacd6cdbf73df3d9eed42fa493d9b621a6">void</a> <a class="el" href="group__apr__errno.html#gaa5105fa83cc322f09382292db8b47593">apr_status_t</a>(* cleanup) (<a class="el" href="group__MOD__ISAPI.html#gacd6cdbf73df3d9eed42fa493d9b621a6">void</a> *)) <a class="el" href="group__APR__Util__Bucket__Brigades.html#gae0af316ed59541b70389da41aaeef4b6">__attribute__</a>((nonnull(3)))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga6ff83cbf1d5de0befaa318c392539164"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__apr__pools.html#ga370a939349adf6d1438068e2fc69a0dd">apr_abortfunc_t</a> <a class="el" href="structapr__allocator__t.html">apr_allocator_t</a> const char* file_line</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gacd3d88da3c0e0313c3645ff34f62f542"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* key</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga3eb8c52002440da9a3eed11d54d08dd5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapr__pool__t.html">apr_pool_t</a> * parent</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga5f598d678d0ca77c25732a145c68d3c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__apr__platform.html#gaaa72b2253f6f3032cefea5712a27540e">apr_size_t</a> size</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
