<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>My Project: General Purpose Library Routines</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">General Purpose Library Routines<div class="ingroups"><a class="el" href="group__APR.html">Apache Portability Runtime library</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for General Purpose Library Routines:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__apr__lib.png" border="0" alt="" usemap="#group____apr____lib"/>
<map name="group____apr____lib" id="group____apr____lib">
<area shape="rect" id="node2" href="group__APR.html" title="Apache Portability\l Runtime library" alt="" coords="5,5,133,47"/>
</map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapr__vformatter__buff__t.html">apr_vformatter_buff_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga0c9dd98f46b90b5bcd4cbf75e252d0da"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__lib.html#ga0c9dd98f46b90b5bcd4cbf75e252d0da">HUGE_STRING_LEN</a>&#160;&#160;&#160;8192</td></tr>
<tr class="separator:ga0c9dd98f46b90b5bcd4cbf75e252d0da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3b0264aadbd9f8d805252fb1ca1cd0e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__lib.html#gaa3b0264aadbd9f8d805252fb1ca1cd0e">apr_killpg</a>(<a class="el" href="pcregrep_8txt.html#a4242e9148f20c002763bf4ba53b26ad6">x</a>,  <a class="el" href="group__MOD__CACHE.html#gad4d47f76a849e2c428e3dd7f8c4eab1f">y</a>)&#160;&#160;&#160;(killpg ((<a class="el" href="pcregrep_8txt.html#a4242e9148f20c002763bf4ba53b26ad6">x</a>), (<a class="el" href="group__MOD__CACHE.html#gad4d47f76a849e2c428e3dd7f8c4eab1f">y</a>)))</td></tr>
<tr class="separator:gaa3b0264aadbd9f8d805252fb1ca1cd0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga5e9986deebda40f2d1cf8364fa03c3c5"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structapr__vformatter__buff__t.html">apr_vformatter_buff_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__lib.html#ga5e9986deebda40f2d1cf8364fa03c3c5">apr_vformatter_buff_t</a></td></tr>
<tr class="separator:ga5e9986deebda40f2d1cf8364fa03c3c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gafc328be562cbf80885289214b616e86f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__lib.html#gafc328be562cbf80885289214b616e86f">APR_DECLARE</a> (const char *) apr_filepath_name_get(const char *<a class="el" href="group__APR__Util__DBM.html#gaf694cab4f4f6cd4b594af3c43cef1d0a">pathname</a>)</td></tr>
<tr class="separator:gafc328be562cbf80885289214b616e86f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfb3aa49508166a7d0cc70945b0164b7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__lib.html#gabfb3aa49508166a7d0cc70945b0164b7">APR_DECLARE</a> (<a class="el" href="pcre_8txt.html#a42dfa4ff673c82d8efe7144098fbc198">int</a>) apr_vformatter(<a class="el" href="pcre_8txt.html#a42dfa4ff673c82d8efe7144098fbc198">int</a>(*flush_func)(<a class="el" href="structapr__vformatter__buff__t.html">apr_vformatter_buff_t</a> *<a class="el" href="group__APR__Util__Bucket__Brigades.html#ga11dc1bdeac74315dbed17465c98879e9">b</a>)</td></tr>
<tr class="separator:gabfb3aa49508166a7d0cc70945b0164b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga0823c5d125363d133fed61fb69c69cdd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapr__vformatter__buff__t.html">apr_vformatter_buff_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__lib.html#ga0823c5d125363d133fed61fb69c69cdd">c</a></td></tr>
<tr class="separator:ga0823c5d125363d133fed61fb69c69cdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0675cea1fc084bc705a06e8f2a1ccc98"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapr__vformatter__buff__t.html">apr_vformatter_buff_t</a> const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__lib.html#ga0675cea1fc084bc705a06e8f2a1ccc98">fmt</a></td></tr>
<tr class="separator:ga0675cea1fc084bc705a06e8f2a1ccc98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa28ecbd6731301051402d429bfb8540"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapr__vformatter__buff__t.html">apr_vformatter_buff_t</a> const char va_list&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__lib.html#gaaa28ecbd6731301051402d429bfb8540">ap</a></td></tr>
<tr class="separator:gaaa28ecbd6731301051402d429bfb8540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac94b4a094f5865d6a5d4a7b04929e528"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__lib.html#gac94b4a094f5865d6a5d4a7b04929e528">pwbuf</a></td></tr>
<tr class="separator:gac94b4a094f5865d6a5d4a7b04929e528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga423d6c42d72a554fc31208493f49913e"><td class="memItemLeft" align="right" valign="top">char <a class="el" href="group__apr__platform.html#gaaa72b2253f6f3032cefea5712a27540e">apr_size_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__lib.html#ga423d6c42d72a554fc31208493f49913e">bufsize</a></td></tr>
<tr class="separator:ga423d6c42d72a554fc31208493f49913e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>This is collection of oddballs that didn't fit anywhere else, and might move to more appropriate headers with the release of APR 1.0. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="gaa3b0264aadbd9f8d805252fb1ca1cd0e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define apr_killpg</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="pcregrep_8txt.html#a4242e9148f20c002763bf4ba53b26ad6">x</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="group__MOD__CACHE.html#gad4d47f76a849e2c428e3dd7f8c4eab1f">y</a>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(killpg ((<a class="el" href="pcregrep_8txt.html#a4242e9148f20c002763bf4ba53b26ad6">x</a>), (<a class="el" href="group__MOD__CACHE.html#gad4d47f76a849e2c428e3dd7f8c4eab1f">y</a>)))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>apr_killpg Small utility macros to make things easier to read. Not usually a goal, to be sure.. </p>

</div>
</div>
<a class="anchor" id="ga0c9dd98f46b90b5bcd4cbf75e252d0da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HUGE_STRING_LEN&#160;&#160;&#160;8192</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A constant representing a 'large' string. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga5e9986deebda40f2d1cf8364fa03c3c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structapr__vformatter__buff__t.html">apr_vformatter_buff_t</a> <a class="el" href="structapr__vformatter__buff__t.html">apr_vformatter_buff_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structapr__vformatter__buff__t.html">apr_vformatter_buff_t</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gafc328be562cbf80885289214b616e86f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">APR_DECLARE </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>return the final element of the pathname </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pathname</td><td>The path to get the final element of </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the final element of the path </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd><pre>
For example:
                "/foo/bar/gum"    -&gt; "gum"
                "/foo/bar/gum/"   -&gt; ""
                "gum"             -&gt; "gum"
                "bs\\path\\stuff" -&gt; "stuff"
</pre></dd></dl>
<p>Skip the common prefix <em>prefix</em> from the C string <em>str</em>, and return a pointer to the next character after the prefix. Return <code>NULL</code> if <em>str</em> does not start with <em>prefix</em>.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.6.</dd></dl>
<p>Get the value associated with a given key from the table. After this call, the data is still in the table. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The table to search for the key </td></tr>
    <tr><td class="paramname">key</td><td>The key to search for (case does not matter) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value associated with the key, or NULL if the key does not exist.</dd></dl>
<p>Get values associated with a given key from the table. If more than one value exists, return a comma separated list of values. After this call, the data is still in the table. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The pool to allocate the combined value from, if necessary </td></tr>
    <tr><td class="paramname">t</td><td>The table to search for the key </td></tr>
    <tr><td class="paramname">key</td><td>The key to search for (case does not matter) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value associated with the key, or NULL if the key does not exist. </dd></dl>

</div>
</div>
<a class="anchor" id="gabfb3aa49508166a7d0cc70945b0164b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">APR_DECLARE </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pcre_8txt.html#a42dfa4ff673c82d8efe7144098fbc198">int</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>apr_vformatter() is a generic printf-style formatting routine with some extensions. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flush_func</td><td>The function to call when the buffer is full </td></tr>
    <tr><td class="paramname">c</td><td>The buffer to write to </td></tr>
    <tr><td class="paramname">fmt</td><td>The format string </td></tr>
    <tr><td class="paramname">ap</td><td>The arguments to use to fill out the format string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd><pre>
The extensions are:</pre></dd></dl>
<ul>
<li><pre>%pA takes a struct in_addr *, and prints it as a.b.c.d</pre></li>
<li><pre>%pI takes an <a class="el" href="structapr__sockaddr__t.html">apr_sockaddr_t</a> * and prints it as a.b.c.d:port or
[ipv6-address]:port</pre></li>
<li><pre>%pT takes an apr_os_thread_t * and prints it in decimal
('0' is printed if !APR_HAS_THREADS)</pre></li>
<li><pre>%pt takes an apr_os_thread_t * and prints it in hexadecimal
('0' is printed if !APR_HAS_THREADS)</pre></li>
<li><pre>%pm takes an apr_status_t * and prints the appropriate error
string (from apr_strerror) corresponding to that error code.</pre></li>
<li><pre>%pp takes a void * and outputs it in hex</pre></li>
<li><pre>%pB takes a apr_uint32_t * as bytes and outputs it's apr_strfsize</pre></li>
<li><pre>%pF same as above, but takes a apr_off_t *</pre></li>
<li><pre>%pS same as above, but takes a apr_size_t *</pre></li>
</ul>
<pre>%pA, %pI, %pT, %pp are available from APR 1.0.0 onwards (and in 0.9.x).
%pt is only available from APR 1.2.0 onwards.
%pm, %pB, %pF and %pS are only available from APR 1.3.0 onwards.</pre><pre>The %p hacks are to force gcc's printf warning code to skip
over a pointer argument without complaining.  This does
mean that the ANSI-style %p (output a void * in hex format) won't
work as expected at all, but that seems to be a fair trade-off
for the increased robustness of having printf-warnings work.</pre><pre>Additionally, apr_vformatter allows for arbitrary output methods
using the apr_vformatter_buff and flush_func.</pre><pre>The apr_vformatter_buff has two elements curpos and endpos.
curpos is where apr_vformatter will write the next byte of output.
It proceeds writing output to curpos, and updating curpos, until
either the end of output is reached, or curpos == endpos (i.e. the
buffer is full).</pre><pre>If the end of output is reached, apr_vformatter returns the
number of bytes written.</pre><pre>When the buffer is full, the flush_func is called.  The flush_func
can return -1 to indicate that no further output should be attempted,
and apr_vformatter will return immediately with -1.  Otherwise
the flush_func should flush the buffer in whatever manner is
appropriate, re <a class="el" href="structapr__pool__t.html">apr_pool_t</a> nitialize curpos and endpos, and return 0.</pre><pre>Note that flush_func is only invoked as a result of attempting to
write another byte at curpos when curpos &gt;= endpos.  So for
example, it's possible when the output exactly matches the buffer
space available that curpos == endpos will be true when
apr_vformatter returns.</pre><pre>apr_vformatter does not call out to any other code, it is entirely
self-contained.  This allows the callers to do things which are
otherwise "unsafe".  For example, apr_psprintf uses the "scratch"
space at the unallocated end of a block, and doesn't actually
complete the allocation until apr_vformatter returns.  apr_psprintf
would be completely broken if apr_vformatter were to call anything
that used this same pool.  Similarly http_bprintf() uses the "scratch"
space at the end of its output buffer, and doesn't actually note
that the space is in use until it either has to flush the buffer
or until apr_vformatter returns.
</pre><p>Display a prompt and read in the password from stdin. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prompt</td><td>The prompt to display </td></tr>
    <tr><td class="paramname">pwbuf</td><td>Buffer to store the password </td></tr>
    <tr><td class="paramname">bufsize</td><td>The length of the password buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the password entered must be truncated to fit in the provided buffer, APR_ENAMETOOLONG will be returned. Note that the bufsize paramater is passed by reference for no reason; its value will never be modified by the apr_password_get() function. </dd></dl>
<p>The problem with trying to output the entire iovec is that we cannot maintain the behaviour that a real writev would have. If we iterate over the iovec one at a time, we lose the atomic properties of <a class="el" href="apr__arch__os2calls_8h.html#a3d0f3996136a9b5ab46431c60c746efd">writev()</a>. The other option is to combine the entire iovec into one buffer that we could then send in one call to write(). This is not reasonable since we do not know how much data an iovec could contain.</p>
<p>The only reasonable option, that maintains the semantics of a real <a class="el" href="apr__arch__os2calls_8h.html#a3d0f3996136a9b5ab46431c60c746efd">writev()</a>, is to only write the first iovec. Callers of file_writev() must deal with partial writes as they normally would. If you want to ensure an entire iovec is written, use apr_file_writev_full().</p>
<div class="fragment"><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;{</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="group__apr__errno.html#ga9ee311b7bf1c691dc521d721339ee2a6">APR_SUCCESS</a>;</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;}</div><div class="ttc" id="group__apr__errno_html_ga9ee311b7bf1c691dc521d721339ee2a6"><div class="ttname"><a href="group__apr__errno.html#ga9ee311b7bf1c691dc521d721339ee2a6">APR_SUCCESS</a></div><div class="ttdeci">#define APR_SUCCESS</div><div class="ttdef"><b>Definition:</b> apr_errno.h:225</div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="gaaa28ecbd6731301051402d429bfb8540"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapr__vformatter__buff__t.html">apr_vformatter_buff_t</a> const char va_list ap</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga423d6c42d72a554fc31208493f49913e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char <a class="el" href="group__apr__platform.html#gaaa72b2253f6f3032cefea5712a27540e">apr_size_t</a>* bufsize</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga0823c5d125363d133fed61fb69c69cdd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapr__vformatter__buff__t.html">apr_vformatter_buff_t</a>* c</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga0675cea1fc084bc705a06e8f2a1ccc98"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapr__vformatter__buff__t.html">apr_vformatter_buff_t</a> const char* fmt</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gac94b4a094f5865d6a5d4a7b04929e528"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* pwbuf</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
