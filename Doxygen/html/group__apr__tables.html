<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>My Project: Table and Array Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Table and Array Functions<div class="ingroups"><a class="el" href="group__APR.html">Apache Portability Runtime library</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Table and Array Functions:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__apr__tables.png" border="0" alt="" usemap="#group____apr____tables"/>
<map name="group____apr____tables" id="group____apr____tables">
<area shape="rect" id="node1" href="group__APR.html" title="Apache Portability\l Runtime library" alt="" coords="5,5,133,47"/>
</map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapr__array__header__t.html">apr_array_header_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapr__table__entry__t.html">apr_table_entry_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga84066caaa4c7632671af18c229809fc4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__tables.html#ga84066caaa4c7632671af18c229809fc4">APR_ARRAY_IDX</a>(ary,  <a class="el" href="group__MOD__PROXY.html#ga38403a0592eb8018a3ad61aef0f7ca2c">i</a>,  <a class="el" href="pcre_8txt.html#a2463fbbe8b0c90b90db12195e1edaa5d">type</a>)&#160;&#160;&#160;(((<a class="el" href="pcre_8txt.html#a2463fbbe8b0c90b90db12195e1edaa5d">type</a> *)(ary)-&gt;elts)[<a class="el" href="group__MOD__PROXY.html#ga38403a0592eb8018a3ad61aef0f7ca2c">i</a>])</td></tr>
<tr class="separator:ga84066caaa4c7632671af18c229809fc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1833b0f940ec03d0b95926812152e1ca"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__tables.html#ga1833b0f940ec03d0b95926812152e1ca">APR_ARRAY_PUSH</a>(ary,  <a class="el" href="pcre_8txt.html#a2463fbbe8b0c90b90db12195e1edaa5d">type</a>)&#160;&#160;&#160;(*((<a class="el" href="pcre_8txt.html#a2463fbbe8b0c90b90db12195e1edaa5d">type</a> *)apr_array_push(ary)))</td></tr>
<tr class="separator:ga1833b0f940ec03d0b95926812152e1ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga867455bb7008872e03b08c0742f9698c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__tables.html#ga867455bb7008872e03b08c0742f9698c">APR_OVERLAP_TABLES_SET</a>&#160;&#160;&#160;(0)</td></tr>
<tr class="separator:ga867455bb7008872e03b08c0742f9698c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga553eea6eb6fea4bafaf4cbd7acafdf5f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__tables.html#ga553eea6eb6fea4bafaf4cbd7acafdf5f">APR_OVERLAP_TABLES_MERGE</a>&#160;&#160;&#160;(1)</td></tr>
<tr class="separator:ga553eea6eb6fea4bafaf4cbd7acafdf5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb34b58105a0ca1a6c4098de0e38bae2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__tables.html#gaeb34b58105a0ca1a6c4098de0e38bae2">APR_OVERLAP_TABLES_ADD</a>&#160;&#160;&#160;(2)</td></tr>
<tr class="separator:gaeb34b58105a0ca1a6c4098de0e38bae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gad7ea82d6608a4a633fc3775694ab71e4"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structapr__table__t.html">apr_table_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__tables.html#gad7ea82d6608a4a633fc3775694ab71e4">apr_table_t</a></td></tr>
<tr class="separator:gad7ea82d6608a4a633fc3775694ab71e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63e76617a1cd3828bbaefcbf93928ec2"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structapr__array__header__t.html">apr_array_header_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__tables.html#ga63e76617a1cd3828bbaefcbf93928ec2">apr_array_header_t</a></td></tr>
<tr class="separator:ga63e76617a1cd3828bbaefcbf93928ec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7e0151b714e58b75c597dafed75df3f"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structapr__table__entry__t.html">apr_table_entry_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__tables.html#gac7e0151b714e58b75c597dafed75df3f">apr_table_entry_t</a></td></tr>
<tr class="separator:gac7e0151b714e58b75c597dafed75df3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabac50c7b2bae5f8cef6245d1959f8b06"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="pcre_8txt.html#a42dfa4ff673c82d8efe7144098fbc198">int</a>(&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__tables.html#gabac50c7b2bae5f8cef6245d1959f8b06">apr_table_do_callback_fn_t</a>) (<a class="el" href="group__MOD__ISAPI.html#gacd6cdbf73df3d9eed42fa493d9b621a6">void</a> *<a class="el" href="group__apr__tables.html#gafcb9c0f7671f566c4804fa8bbad43c4b">rec</a>, const char *<a class="el" href="apr__siphash_8h.html#adac0b6a30345ea1d0daa8a692b0b7ad9">key</a>, const char *<a class="el" href="pcretest_8txt.html#a262ad32c75be9b93a7a77b045ed14fe0">value</a>)</td></tr>
<tr class="separator:gabac50c7b2bae5f8cef6245d1959f8b06"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga9511e4ca61f34976bb986a3c46b589de"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__tables.html#ga9511e4ca61f34976bb986a3c46b589de">APR_DECLARE</a> (const <a class="el" href="structapr__array__header__t.html">apr_array_header_t</a> *) apr_table_elts(const <a class="el" href="structapr__table__t.html">apr_table_t</a> *<a class="el" href="pcretest_8txt.html#a9ffb27fb8e1f90c17b13303fee2fb883">t</a>)</td></tr>
<tr class="separator:ga9511e4ca61f34976bb986a3c46b589de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24a036e42e589a90022bf1ec1158113b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__tables.html#ga24a036e42e589a90022bf1ec1158113b">APR_DECLARE</a> (<a class="el" href="pcre_8txt.html#a42dfa4ff673c82d8efe7144098fbc198">int</a>) apr_is_empty_table(const <a class="el" href="structapr__table__t.html">apr_table_t</a> *<a class="el" href="pcretest_8txt.html#a9ffb27fb8e1f90c17b13303fee2fb883">t</a>)</td></tr>
<tr class="separator:ga24a036e42e589a90022bf1ec1158113b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae3cc795193b58c8995d1bc65c7851b3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__tables.html#gaae3cc795193b58c8995d1bc65c7851b3">APR_DECLARE</a> (<a class="el" href="structapr__array__header__t.html">apr_array_header_t</a> *) apr_array_make(<a class="el" href="structapr__pool__t.html">apr_pool_t</a> *<a class="el" href="group__APACHE__CORE__MPM.html#ga5cd91701e5c167f2b1a38e70ab57817e">p</a></td></tr>
<tr class="separator:gaae3cc795193b58c8995d1bc65c7851b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2de0308124f1ed080a6c373e993b5cae"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__tables.html#ga2de0308124f1ed080a6c373e993b5cae">APR_DECLARE</a> (<a class="el" href="group__MOD__ISAPI.html#gacd6cdbf73df3d9eed42fa493d9b621a6">void</a> *) apr_array_push(<a class="el" href="structapr__array__header__t.html">apr_array_header_t</a> *<a class="el" href="group__apr__tables.html#ga1e3f66bfb173c9a913ef3bb37842e273">arr</a>)</td></tr>
<tr class="separator:ga2de0308124f1ed080a6c373e993b5cae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga147e24e5f1f9f5bb7d7d11381291bba5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__tables.html#ga147e24e5f1f9f5bb7d7d11381291bba5">APR_DECLARE</a> (<a class="el" href="group__MOD__ISAPI.html#gacd6cdbf73df3d9eed42fa493d9b621a6">void</a>) apr_array_clear(<a class="el" href="structapr__array__header__t.html">apr_array_header_t</a> *<a class="el" href="group__apr__tables.html#ga1e3f66bfb173c9a913ef3bb37842e273">arr</a>)</td></tr>
<tr class="separator:ga147e24e5f1f9f5bb7d7d11381291bba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76c651e5101e99d13ab524734b2cead1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__tables.html#ga76c651e5101e99d13ab524734b2cead1">APR_DECLARE</a> (char *) apr_array_pstrcat(<a class="el" href="structapr__pool__t.html">apr_pool_t</a> *<a class="el" href="group__APACHE__CORE__MPM.html#ga5cd91701e5c167f2b1a38e70ab57817e">p</a></td></tr>
<tr class="separator:ga76c651e5101e99d13ab524734b2cead1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fd1a47e4d1d3dc2eec1ffec470a0f30"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__tables.html#ga2fd1a47e4d1d3dc2eec1ffec470a0f30">APR_DECLARE</a> (<a class="el" href="structapr__table__t.html">apr_table_t</a> *) apr_table_make(<a class="el" href="structapr__pool__t.html">apr_pool_t</a> *<a class="el" href="group__APACHE__CORE__MPM.html#ga5cd91701e5c167f2b1a38e70ab57817e">p</a></td></tr>
<tr class="separator:ga2fd1a47e4d1d3dc2eec1ffec470a0f30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5df6767d4348ac55d933a7b29333239"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__tables.html#gae5df6767d4348ac55d933a7b29333239">APR_DECLARE</a> (const char *) apr_table_get(const <a class="el" href="structapr__table__t.html">apr_table_t</a> *<a class="el" href="pcretest_8txt.html#a9ffb27fb8e1f90c17b13303fee2fb883">t</a></td></tr>
<tr class="separator:gae5df6767d4348ac55d933a7b29333239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab02b0393c878208ff6cb55c701ff536a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__tables.html#gab02b0393c878208ff6cb55c701ff536a">APR_DECLARE_NONSTD</a> (<a class="el" href="pcre_8txt.html#a42dfa4ff673c82d8efe7144098fbc198">int</a>) apr_table_do(<a class="el" href="group__apr__tables.html#gabac50c7b2bae5f8cef6245d1959f8b06">apr_table_do_callback_fn_t</a> *<a class="el" href="group__apr__skiplist.html#ga4c81b1eebdb8efeefcadd27cb3fe1c31">comp</a></td></tr>
<tr class="separator:gab02b0393c878208ff6cb55c701ff536a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga3f892b271cc0564b2d8e9536a96abd7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcre_8txt.html#a42dfa4ff673c82d8efe7144098fbc198">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__tables.html#ga3f892b271cc0564b2d8e9536a96abd7c">nelts</a></td></tr>
<tr class="separator:ga3f892b271cc0564b2d8e9536a96abd7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga922b4b4bccf7114fd241df5bd432ad58"><td class="memItemLeft" align="right" valign="top"><a class="el" href="pcre_8txt.html#a42dfa4ff673c82d8efe7144098fbc198">int</a> <a class="el" href="pcre_8txt.html#a42dfa4ff673c82d8efe7144098fbc198">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__tables.html#ga922b4b4bccf7114fd241df5bd432ad58">elt_size</a></td></tr>
<tr class="separator:ga922b4b4bccf7114fd241df5bd432ad58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6e7405500bdd51690dc9ef83744684f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structapr__array__header__t.html">apr_array_header_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__tables.html#gab6e7405500bdd51690dc9ef83744684f">src</a></td></tr>
<tr class="separator:gab6e7405500bdd51690dc9ef83744684f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e3f66bfb173c9a913ef3bb37842e273"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structapr__array__header__t.html">apr_array_header_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__tables.html#ga1e3f66bfb173c9a913ef3bb37842e273">arr</a></td></tr>
<tr class="separator:ga1e3f66bfb173c9a913ef3bb37842e273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga950d7fed8d587d0a9318ffd24f95096f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structapr__array__header__t.html">apr_array_header_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__tables.html#ga950d7fed8d587d0a9318ffd24f95096f">first</a></td></tr>
<tr class="separator:ga950d7fed8d587d0a9318ffd24f95096f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade8df35e4d83c24788cf409262f7fc51"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structapr__array__header__t.html">apr_array_header_t</a> const <a class="el" href="structapr__array__header__t.html">apr_array_header_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__tables.html#gade8df35e4d83c24788cf409262f7fc51">second</a></td></tr>
<tr class="separator:gade8df35e4d83c24788cf409262f7fc51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37d96adf842aef6b03690e17874c9ed8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structapr__array__header__t.html">apr_array_header_t</a> const char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__tables.html#ga37d96adf842aef6b03690e17874c9ed8">sep</a></td></tr>
<tr class="separator:ga37d96adf842aef6b03690e17874c9ed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0d127e044cb4fd448cde5c19d10179e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structapr__table__t.html">apr_table_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__tables.html#gad0d127e044cb4fd448cde5c19d10179e">t</a></td></tr>
<tr class="separator:gad0d127e044cb4fd448cde5c19d10179e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd3d88da3c0e0313c3645ff34f62f542"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__tables.html#gacd3d88da3c0e0313c3645ff34f62f542">key</a></td></tr>
<tr class="separator:gacd3d88da3c0e0313c3645ff34f62f542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d708cd93abeca73400ed82977502830"><td class="memItemLeft" align="right" valign="top">const char const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__tables.html#ga4d708cd93abeca73400ed82977502830">val</a></td></tr>
<tr class="separator:ga4d708cd93abeca73400ed82977502830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13c7c35ef67602a57343d21ee1d62e61"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structapr__table__t.html">apr_table_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__tables.html#ga13c7c35ef67602a57343d21ee1d62e61">overlay</a></td></tr>
<tr class="separator:ga13c7c35ef67602a57343d21ee1d62e61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74964146831939c658b798439fc32f6d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structapr__table__t.html">apr_table_t</a> const <a class="el" href="structapr__table__t.html">apr_table_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__tables.html#ga74964146831939c658b798439fc32f6d">base</a></td></tr>
<tr class="separator:ga74964146831939c658b798439fc32f6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafcb9c0f7671f566c4804fa8bbad43c4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MOD__ISAPI.html#gacd6cdbf73df3d9eed42fa493d9b621a6">void</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__tables.html#gafcb9c0f7671f566c4804fa8bbad43c4b">rec</a></td></tr>
<tr class="separator:gafcb9c0f7671f566c4804fa8bbad43c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ca169f10741c89e389d179f952e4dc9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__MOD__ISAPI.html#gacd6cdbf73df3d9eed42fa493d9b621a6">void</a> const <a class="el" href="structapr__table__t.html">apr_table_t</a> <a class="el" href="group__MOD__ISAPI.html#gacd6cdbf73df3d9eed42fa493d9b621a6">void</a> const <a class="el" href="structapr__table__t.html">apr_table_t</a> va_list&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__tables.html#ga8ca169f10741c89e389d179f952e4dc9">vp</a></td></tr>
<tr class="separator:ga8ca169f10741c89e389d179f952e4dc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7465df964235e37c6f5e1212af22be2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structapr__table__t.html">apr_table_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__tables.html#gac7465df964235e37c6f5e1212af22be2">b</a></td></tr>
<tr class="separator:gac7465df964235e37c6f5e1212af22be2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b08a4d2ec878257d64c55f64a62242c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structapr__table__t.html">apr_table_t</a> unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__tables.html#ga8b08a4d2ec878257d64c55f64a62242c">flags</a></td></tr>
<tr class="separator:ga8b08a4d2ec878257d64c55f64a62242c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Arrays are used to store data which is referenced sequentially or as a stack. Functions are provided to push and pop individual elements as well as to operate on the entire array.</p>
<p>Tables are used to store data which can be referenced by key. Limited capabilities are provided for tables with multiple elements which share a key; while key lookup will return only a single element, iteration is available. Additionally, a table can be compressed to resolve duplicates.</p>
<p>Both arrays and tables may store string or binary data; some features, such as concatenation or merging of elements, work only for string data. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga84066caaa4c7632671af18c229809fc4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APR_ARRAY_IDX</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ary, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="group__MOD__PROXY.html#ga38403a0592eb8018a3ad61aef0f7ca2c">i</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="pcre_8txt.html#a2463fbbe8b0c90b90db12195e1edaa5d">type</a>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(((<a class="el" href="pcre_8txt.html#a2463fbbe8b0c90b90db12195e1edaa5d">type</a> *)(ary)-&gt;elts)[<a class="el" href="group__MOD__PROXY.html#ga38403a0592eb8018a3ad61aef0f7ca2c">i</a>])</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A helper macro for accessing a member of an APR array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ary</td><td>the array </td></tr>
    <tr><td class="paramname">i</td><td>the index into the array to return </td></tr>
    <tr><td class="paramname">type</td><td>the type of the objects stored in the array</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the item at index i </dd></dl>

</div>
</div>
<a class="anchor" id="ga1833b0f940ec03d0b95926812152e1ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APR_ARRAY_PUSH</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ary, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="pcre_8txt.html#a2463fbbe8b0c90b90db12195e1edaa5d">type</a>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(*((<a class="el" href="pcre_8txt.html#a2463fbbe8b0c90b90db12195e1edaa5d">type</a> *)apr_array_push(ary)))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A helper macro for pushing elements into an APR array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ary</td><td>the array </td></tr>
    <tr><td class="paramname">type</td><td>the type of the objects stored in the array</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the location where the new object should be placed </dd></dl>

</div>
</div>
<a class="anchor" id="gaeb34b58105a0ca1a6c4098de0e38bae2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APR_OVERLAP_TABLES_ADD&#160;&#160;&#160;(2)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>flag for overlap to use apr_table_addn </p>

</div>
</div>
<a class="anchor" id="ga553eea6eb6fea4bafaf4cbd7acafdf5f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APR_OVERLAP_TABLES_MERGE&#160;&#160;&#160;(1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>flag for overlap to use apr_table_mergen </p>

</div>
</div>
<a class="anchor" id="ga867455bb7008872e03b08c0742f9698c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APR_OVERLAP_TABLES_SET&#160;&#160;&#160;(0)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>flag for overlap to use apr_table_setn </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga63e76617a1cd3828bbaefcbf93928ec2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structapr__array__header__t.html">apr_array_header_t</a> <a class="el" href="structapr__array__header__t.html">apr_array_header_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structapr__array__header__t.html">apr_array_header_t</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gabac50c7b2bae5f8cef6245d1959f8b06"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="pcre_8txt.html#a42dfa4ff673c82d8efe7144098fbc198">int</a>( apr_table_do_callback_fn_t) (<a class="el" href="group__MOD__ISAPI.html#gacd6cdbf73df3d9eed42fa493d9b621a6">void</a> *<a class="el" href="group__apr__tables.html#gafcb9c0f7671f566c4804fa8bbad43c4b">rec</a>, const char *<a class="el" href="apr__siphash_8h.html#adac0b6a30345ea1d0daa8a692b0b7ad9">key</a>, const char *<a class="el" href="pcretest_8txt.html#a262ad32c75be9b93a7a77b045ed14fe0">value</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declaration prototype for the iterator callback function of apr_table_do() and apr_table_vdo(). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rec</td><td>The data passed as the first argument to apr_table_[v]<a class="el" href="pcregrep_8txt.html#a29df1716374a8e3439d34a27760970bd">do()</a> </td></tr>
    <tr><td class="paramname">key</td><td>The key from this iteration of the table </td></tr>
    <tr><td class="paramname">value</td><td>The value from this iteration of the table </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Iteration continues while this callback function returns non-zero. To export the callback function for apr_table_[v]<a class="el" href="pcregrep_8txt.html#a29df1716374a8e3439d34a27760970bd">do()</a> it must be declared in the _NONSTD convention. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>apr_table_do </dd>
<dd>
apr_table_vdo </dd></dl>

</div>
</div>
<a class="anchor" id="gac7e0151b714e58b75c597dafed75df3f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structapr__table__entry__t.html">apr_table_entry_t</a> <a class="el" href="structapr__table__entry__t.html">apr_table_entry_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The (opaque) structure for string-content tables. </p>

</div>
</div>
<a class="anchor" id="gad7ea82d6608a4a633fc3775694ab71e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structapr__table__t.html">apr_table_t</a> <a class="el" href="structapr__table__t.html">apr_table_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>the table abstract data type </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga9511e4ca61f34976bb986a3c46b589de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">APR_DECLARE </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structapr__array__header__t.html">apr_array_header_t</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the elements from a table. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The table </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An array containing the contents of the table </dd></dl>

</div>
</div>
<a class="anchor" id="ga24a036e42e589a90022bf1ec1158113b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">APR_DECLARE </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pcre_8txt.html#a42dfa4ff673c82d8efe7144098fbc198">int</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine if the table is empty (either NULL or having no elements). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The table to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if empty, False otherwise</dd></dl>
<p>Determine if the array is empty (either NULL or having no elements). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The array to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if empty, False otherwise</dd></dl>
<p>Iterate over a table running the provided function once for every element in the table. The vp varargs parameter must be a list of zero or more (char *) keys followed by a NULL pointer. If zero keys are given, the </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comp</td><td>function will be invoked for every element in the table. Otherwise, the function is invoked only for those elements matching the keys specified.</td></tr>
  </table>
  </dd>
</dl>
<p>If an invocation of the comp function returns zero, iteration will continue using the next specified key, if any.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comp</td><td>The function to run </td></tr>
    <tr><td class="paramname">rec</td><td>The data to pass as the first argument to the function </td></tr>
    <tr><td class="paramname">t</td><td>The table to iterate over </td></tr>
    <tr><td class="paramname">vp</td><td>List of zero or more (char *) keys followed by NULL </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>FALSE if one of the <a class="el" href="group__apr__skiplist.html#ga4c81b1eebdb8efeefcadd27cb3fe1c31">comp()</a> iterations returned zero; TRUE if all iterations returned non-zero </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__apr__tables.html#gabac50c7b2bae5f8cef6245d1959f8b06">apr_table_do_callback_fn_t</a> </dd>
<dd>
apr_table_do </dd></dl>

</div>
</div>
<a class="anchor" id="gaae3cc795193b58c8995d1bc65c7851b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">APR_DECLARE </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapr__array__header__t.html">apr_array_header_t</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create an array. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The pool to allocate the memory out of </td></tr>
    <tr><td class="paramname">nelts</td><td>the number of elements in the initial array </td></tr>
    <tr><td class="paramname">elt_size</td><td>The size of each element in the array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new array</dd></dl>
<p>Copy the entire array. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The pool to allocate the copy of the array out of </td></tr>
    <tr><td class="paramname">arr</td><td>The array to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An exact copy of the array passed in </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The alternate apr_array_copy_hdr copies only the header, and arranges for the elements to be copied if (and only if) the code subsequently does a push or arraycat.</dd></dl>
<p>Copy the headers of the array, and arrange for the elements to be copied if and only if the code subsequently does a push or arraycat. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The pool to allocate the copy of the array out of </td></tr>
    <tr><td class="paramname">arr</td><td>The array to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An exact copy of the array passed in </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The alternate apr_array_copy copies the <em>entire</em> array.</dd></dl>
<p>Append one array to the end of another, creating a new array in the process. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The pool to allocate the new array out of </td></tr>
    <tr><td class="paramname">first</td><td>The array to put first in the new array. </td></tr>
    <tr><td class="paramname">second</td><td>The array to put second in the new array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new array containing the data from the two arrays passed in. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2de0308124f1ed080a6c373e993b5cae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">APR_DECLARE </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__MOD__ISAPI.html#gacd6cdbf73df3d9eed42fa493d9b621a6">void</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a new element to an array (as a first-in, last-out stack). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>The array to add an element to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Location for the new element in the array. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If there are no free spots in the array, then this function will allocate new space for the new element.</dd></dl>
<p>Remove an element from an array (as a first-in, last-out stack). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>The array to remove an element from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Location of the element in the array. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If there are no elements in the array, NULL is returned.</dd></dl>
<p>Look up the value associated with a key in a hash table. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ht</td><td>The hash table </td></tr>
    <tr><td class="paramname">key</td><td>Pointer to the key </td></tr>
    <tr><td class="paramname">klen</td><td>Length of the key. Can be APR_HASH_KEY_STRING to use the string length. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns NULL if the key is not present.</dd></dl>
<p>Get the current entry's value from the iteration state. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hi</td><td>The iteration state </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pointer to the value</dd></dl>
<p>Allocate a block of memory from a pool </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The pool to allocate from </td></tr>
    <tr><td class="paramname">size</td><td>The amount of memory to allocate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The allocated memory</dd></dl>
<p>Debug version of apr_palloc </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>See: apr_palloc </td></tr>
    <tr><td class="paramname">size</td><td>See: apr_palloc </td></tr>
    <tr><td class="paramname">file_line</td><td>Where the function is called from. This is usually APR_POOL__FILE_LINE__. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See: apr_palloc</dd></dl>
<p>Debug version of apr_pcalloc </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>See: apr_pcalloc </td></tr>
    <tr><td class="paramname">size</td><td>See: apr_pcalloc </td></tr>
    <tr><td class="paramname">file_line</td><td>Where the function is called from. This is usually APR_POOL__FILE_LINE__. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See: apr_pcalloc</dd></dl>
<p>Set the signal handler function for a given signal </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">signo</td><td>The signal (eg... SIGWINCH) </td></tr>
    <tr><td class="paramname">func</td><td>the function to get called</td></tr>
  </table>
  </dd>
</dl>
<p>Allocate memory using the same mechanism as the skip list. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sl</td><td>The skip list </td></tr>
    <tr><td class="paramname">size</td><td>The amount to allocate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If a pool was provided to apr_skiplist_init(), memory will be allocated from the pool or from a free list maintained with the skip list. Otherwise, memory will be allocated using the C standard library heap functions.</dd></dl>
<p>Return the next matching element in the skip list using the specified comparison function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sl</td><td>The skip list </td></tr>
    <tr><td class="paramname">data</td><td>The value to search for </td></tr>
    <tr><td class="paramname">iter</td><td>A pointer to the returned skip list node representing the element found </td></tr>
    <tr><td class="paramname">func</td><td>The comparison function to use</td></tr>
  </table>
  </dd>
</dl>
<p>Return the next matching element in the skip list using the current comparison function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sl</td><td>The skip list </td></tr>
    <tr><td class="paramname">data</td><td>The value to search for </td></tr>
    <tr><td class="paramname">iter</td><td>A pointer to the returned skip list node representing the element found</td></tr>
  </table>
  </dd>
</dl>
<p>Return the last matching element in the skip list using the specified comparison function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sl</td><td>The skip list </td></tr>
    <tr><td class="paramname">data</td><td>The value to search for </td></tr>
    <tr><td class="paramname">iter</td><td>A pointer to the returned skip list node representing the element found </td></tr>
    <tr><td class="paramname">func</td><td>The comparison function to use</td></tr>
  </table>
  </dd>
</dl>
<p>Return the last matching element in the skip list using the current comparison function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sl</td><td>The skip list </td></tr>
    <tr><td class="paramname">data</td><td>The value to search for </td></tr>
    <tr><td class="paramname">iter</td><td>A pointer to the returned skip list node representing the element found</td></tr>
  </table>
  </dd>
</dl>
<p>Return the next element in the skip list. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sl</td><td>The skip list </td></tr>
    <tr><td class="paramname">iter</td><td>On entry, a pointer to the skip list node to start with; on return, a pointer to the skip list node representing the element returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If iter points to a NULL value on entry, NULL will be returned.</dd></dl>
<p>Return the previous element in the skip list. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sl</td><td>The skip list </td></tr>
    <tr><td class="paramname">iter</td><td>On entry, a pointer to the skip list node to start with; on return, a pointer to the skip list node representing the element returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If iter points to a NULL value on entry, NULL will be returned.</dd></dl>
<p>Return the element of the skip list node </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>The skip list node</td></tr>
  </table>
  </dd>
</dl>
<p>Return the first element in the skip list, removing the element from the skip list. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sl</td><td>The skip list </td></tr>
    <tr><td class="paramname">myfree</td><td>A function to be called for the removed element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>NULL will be returned if there are no elements</dd></dl>
<p>Return the first element in the skip list, leaving the element in the skip list. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sl</td><td>The skip list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>NULL will be returned if there are no elements</dd></dl>
<p>Duplicate a block of memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The pool to allocate from </td></tr>
    <tr><td class="paramname">m</td><td>The memory to duplicate </td></tr>
    <tr><td class="paramname">n</td><td>The number of bytes to duplicate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new block of memory or NULL if m == NULL </dd></dl>
<div class="fragment"><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;{</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;    <span class="keywordflow">return</span> (<span class="keywordtype">void</span>*)atomic_cmpxchg((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *)<a class="code" href="group__MOD__DAV.html#gac8d0feaae3f1c6b0eac72aaa9af557c1">mem</a>,(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)<a class="code" href="group__apr__atomic.html#ga337f72af8c74a9110f79160df3bba5e8">cmp</a>,(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)<a class="code" href="group__apr__atomic.html#ga62bdcea60b77e638d3d88947a34aff05">with</a>);</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;}</div><div class="ttc" id="group__apr__atomic_html_ga337f72af8c74a9110f79160df3bba5e8"><div class="ttname"><a href="group__apr__atomic.html#ga337f72af8c74a9110f79160df3bba5e8">cmp</a></div><div class="ttdeci">apr_uint32_t apr_uint32_t cmp</div><div class="ttdef"><b>Definition:</b> apr_atomic.h:105</div></div>
<div class="ttc" id="group__MOD__DAV_html_gac8d0feaae3f1c6b0eac72aaa9af557c1"><div class="ttname"><a href="group__MOD__DAV.html#gac8d0feaae3f1c6b0eac72aaa9af557c1">mem</a></div><div class="ttdeci">dav_buffer const void * mem</div><div class="ttdef"><b>Definition:</b> mod_dav.h:471</div></div>
<div class="ttc" id="group__apr__atomic_html_ga62bdcea60b77e638d3d88947a34aff05"><div class="ttname"><a href="group__apr__atomic.html#ga62bdcea60b77e638d3d88947a34aff05">with</a></div><div class="ttdeci">apr_uint32_t with</div><div class="ttdef"><b>Definition:</b> apr_atomic.h:105</div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__apr__tables_ga2de0308124f1ed080a6c373e993b5cae_cgraph.png" border="0" usemap="#group__apr__tables_ga2de0308124f1ed080a6c373e993b5cae_cgraph" alt=""/></div>
<map name="group__apr__tables_ga2de0308124f1ed080a6c373e993b5cae_cgraph" id="group__apr__tables_ga2de0308124f1ed080a6c373e993b5cae_cgraph">
<area shape="rect" id="node2" href="group__apr__allocator.html#ga9cb19a118179bbd8625eacfec66a9ab8" title="APR_DECLARE" alt="" coords="207,5,328,32"/>
<area shape="rect" id="node3" href="atomic_8c.html#a50850e462d65e0409d5a93a6b4ec26c6" title="apr_atomic_xchg32" alt="" coords="200,56,335,83"/>
<area shape="rect" id="node4" href="util__expr__parse_8c.html#a5faf6a2d99f50a4655dd390199a8db7b" title="malloc" alt="" coords="967,132,1027,159"/>
<area shape="rect" id="node5" href="apr__hash_8c.html#a5ba9a5ead41ce5a6e073cc781cc59016" title="APR_DECLARE_NONSTD" alt="" coords="175,157,360,184"/>
<area shape="rect" id="node6" href="util__expr__scan_8c.html#a8fdafe3be7e00ce3d4f0cb50a9a5eb39" title="while" alt="" coords="241,208,293,235"/>
<area shape="rect" id="node7" href="group__MOD__ISAPI.html#gacd6cdbf73df3d9eed42fa493d9b621a6" title="void" alt="" coords="973,208,1020,235"/>
<area shape="rect" id="node8" href="util__expr__scan_8c.html#a0a7c4a7733cdb1eb01d004f938def83c" title="ap_expr_yyrealloc" alt="" coords="605,259,732,285"/>
<area shape="rect" id="node9" href="util__expr__scan_8c.html#ae306439b40fb64237eafb4c0b4524aee" title="ap_expr_yyrestart" alt="" coords="408,157,535,184"/>
<area shape="rect" id="node10" href="util__expr__scan_8c.html#a073e30a44c0e142fe3d3a1f87bbf6c5e" title="ap_expr_yy_create_buffer" alt="" coords="583,157,755,184"/>
<area shape="rect" id="node11" href="util__expr__scan_8c.html#a3dd61ae214da108171a1bc60b87291d0" title="ap_expr_yyalloc" alt="" coords="803,157,919,184"/>
</map>
</div>
</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__apr__tables_ga2de0308124f1ed080a6c373e993b5cae_icgraph.png" border="0" usemap="#group__apr__tables_ga2de0308124f1ed080a6c373e993b5cae_icgraph" alt=""/></div>
<map name="group__apr__tables_ga2de0308124f1ed080a6c373e993b5cae_icgraph" id="group__apr__tables_ga2de0308124f1ed080a6c373e993b5cae_icgraph">
<area shape="rect" id="node2" href="group__apr__allocator.html#ga9cb19a118179bbd8625eacfec66a9ab8" title="APR_DECLARE" alt="" coords="175,5,296,32"/>
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga147e24e5f1f9f5bb7d7d11381291bba5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">APR_DECLARE </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__MOD__ISAPI.html#gacd6cdbf73df3d9eed42fa493d9b621a6">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove all elements from an array. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>The array to remove all elements from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>As the underlying storage is allocated from a pool, no memory is freed by this operation, but is available for reuse.</dd></dl>
<p>Concatenate two arrays together. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>The destination array, and the one to go first in the combined array </td></tr>
    <tr><td class="paramname">src</td><td>The source array to add to the destination array</td></tr>
  </table>
  </dd>
</dl>
<p>Delete all of the elements from a table. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The table to clear</td></tr>
  </table>
  </dd>
</dl>
<p>Add a key/value pair to a table. If another element already exists with the same key, this will overwrite the old data. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The table to add the data to. </td></tr>
    <tr><td class="paramname">key</td><td>The key to use (case does not matter) </td></tr>
    <tr><td class="paramname">val</td><td>The value to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>When adding data, this function makes a copy of both the key and the value.</dd></dl>
<p>Add a key/value pair to a table. If another element already exists with the same key, this will overwrite the old data. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The table to add the data to. </td></tr>
    <tr><td class="paramname">key</td><td>The key to use (case does not matter) </td></tr>
    <tr><td class="paramname">val</td><td>The value to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>When adding data, this function does not make a copy of the key or the value, so care should be taken to ensure that the values will not change after they have been added..</dd></dl>
<p>Remove data from the table. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The table to remove data from </td></tr>
    <tr><td class="paramname">key</td><td>The key of the data being removed (case does not matter)</td></tr>
  </table>
  </dd>
</dl>
<p>Add data to a table by merging the value with data that has already been stored. The merging is done by concatenating the two values, separated by the string ", ". </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The table to search for the data </td></tr>
    <tr><td class="paramname">key</td><td>The key to merge data for (case does not matter) </td></tr>
    <tr><td class="paramname">val</td><td>The data to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the key is not found, then this function acts like apr_table_add</dd></dl>
<p>Add data to a table by merging the value with data that has already been stored. The merging is done by concatenating the two values, separated by the string ", ". </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The table to search for the data </td></tr>
    <tr><td class="paramname">key</td><td>The key to merge data for (case does not matter) </td></tr>
    <tr><td class="paramname">val</td><td>The data to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the key is not found, then this function acts like apr_table_addn</dd></dl>
<p>Add data to a table, regardless of whether there is another element with the same key. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The table to add to </td></tr>
    <tr><td class="paramname">key</td><td>The key to use </td></tr>
    <tr><td class="paramname">val</td><td>The value to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>When adding data, this function makes a copy of both the key and the value.</dd></dl>
<p>Add data to a table, regardless of whether there is another element with the same key. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The table to add to </td></tr>
    <tr><td class="paramname">key</td><td>The key to use </td></tr>
    <tr><td class="paramname">val</td><td>The value to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>When adding data, this function does not make a copy of the key or the value, so care should be taken to ensure that the values will not change after they have been added.</dd></dl>
<p>For each element in table b, either use setn or mergen to add the data to table a. Which method is used is determined by the flags passed in. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The table to add the data to. </td></tr>
    <tr><td class="paramname">b</td><td>The table to iterate over, adding its data to table a </td></tr>
    <tr><td class="paramname">flags</td><td>How to add the table to table a. One of: APR_OVERLAP_TABLES_SET Use apr_table_setn APR_OVERLAP_TABLES_MERGE Use apr_table_mergen APR_OVERLAP_TABLES_ADD Use apr_table_addn </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>When merging duplicates, the two values are concatenated, separated by the string ", ". </dd>
<dd>
This function is highly optimized, and uses less memory and CPU cycles than a function that just loops through table b calling other functions. Conceptually, apr_table_overlap does this:</dd></dl>
<pre>
 <a class="el" href="structapr__array__header__t.html">apr_array_header_t</a> *barr = apr_table_elts(b);
 <a class="el" href="structapr__table__entry__t.html">apr_table_entry_t</a> *belt = (<a class="el" href="structapr__table__entry__t.html">apr_table_entry_t</a> *)barr-&gt;elts;
 int i;</pre><pre> for (i = 0; i &lt; barr-&gt;nelts; ++i) {
     if (flags &amp; APR_OVERLAP_TABLES_MERGE) {
         apr_table_mergen(a, belt[i].key, belt[i].val);
     }
     else if (flags &amp; APR_OVERLAP_TABLES_ADD) {
         apr_table_addn(a, belt[i].key, belt[i].val);
     }
     else {
         apr_table_setn(a, belt[i].key, belt[i].val);
     }
 }
</pre><p>Except that it is more efficient (less space and cpu-time) especially when b has many elements.</p>
<p>Notice the assumptions on the keys and values in b &ndash; they must be in an ancestor of a's pool. In practice b and a are usually from the same pool.</p>
<p>Eliminate redundant entries in a table by either overwriting or merging duplicates.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Table. </td></tr>
    <tr><td class="paramname">flags</td><td>APR_OVERLAP_TABLES_MERGE to merge, or APR_OVERLAP_TABLES_SET to overwrite, or APR_OVERLAP_TABLES_ADD to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>When merging duplicates, the two values are concatenated, separated by the string ", ". </dd></dl>
<div class="fragment"><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;{</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;    atomic_sub((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *)<a class="code" href="group__MOD__DAV.html#gac8d0feaae3f1c6b0eac72aaa9af557c1">mem</a>,(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)<a class="code" href="group__APACHE__CORE__CONFIG.html#gae553dcb033cb5c1e269683855e4f676a">val</a>);</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;}</div><div class="ttc" id="group__APACHE__CORE__CONFIG_html_gae553dcb033cb5c1e269683855e4f676a"><div class="ttname"><a href="group__APACHE__CORE__CONFIG.html#gae553dcb033cb5c1e269683855e4f676a">val</a></div><div class="ttdeci">const module void * val</div><div class="ttdef"><b>Definition:</b> http_config.h:526</div></div>
<div class="ttc" id="group__MOD__DAV_html_gac8d0feaae3f1c6b0eac72aaa9af557c1"><div class="ttname"><a href="group__MOD__DAV.html#gac8d0feaae3f1c6b0eac72aaa9af557c1">mem</a></div><div class="ttdeci">dav_buffer const void * mem</div><div class="ttdef"><b>Definition:</b> mod_dav.h:471</div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ga76c651e5101e99d13ab524734b2cead1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">APR_DECLARE </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate a new string from the <a class="el" href="structapr__pool__t.html">apr_pool_t</a> containing the concatenated sequence of substrings referenced as elements within the array. The string will be empty if all substrings are empty or null, or if there are no elements in the array. If sep is non-NUL, it will be inserted between elements as a separator. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The pool to allocate the string out of </td></tr>
    <tr><td class="paramname">arr</td><td>The array to generate the string from </td></tr>
    <tr><td class="paramname">sep</td><td>The separator to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A string containing all of the data in the array. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2fd1a47e4d1d3dc2eec1ffec470a0f30"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">APR_DECLARE </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapr__table__t.html">apr_table_t</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make a new table. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The pool to allocate the pool out of </td></tr>
    <tr><td class="paramname">nelts</td><td>The number of elements in the initial table. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new table. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This table can only store text data</dd></dl>
<p>Create a new table and copy another table into it. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The pool to allocate the new table out of </td></tr>
    <tr><td class="paramname">t</td><td>The table to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A copy of the table passed in </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The table keys and respective values are not copied</dd></dl>
<p>Create a new table whose contents are deep copied from the given table. A deep copy operation copies all fields, and makes copies of dynamically allocated memory pointed to by the fields. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The pool to allocate the new table out of </td></tr>
    <tr><td class="paramname">t</td><td>The table to clone </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A deep copy of the table passed in</dd></dl>
<p>Merge two tables into one new table. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The pool to use for the new table </td></tr>
    <tr><td class="paramname">overlay</td><td>The first table to put in the new table </td></tr>
    <tr><td class="paramname">base</td><td>The table to add at the end of the new table </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new table containing all of the data from the two passed in </dd></dl>

</div>
</div>
<a class="anchor" id="gae5df6767d4348ac55d933a7b29333239"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">APR_DECLARE </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the value associated with a given key from the table. After this call, the data is still in the table. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The table to search for the key </td></tr>
    <tr><td class="paramname">key</td><td>The key to search for (case does not matter) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value associated with the key, or NULL if the key does not exist.</dd></dl>
<p>Get values associated with a given key from the table. If more than one value exists, return a comma separated list of values. After this call, the data is still in the table. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The pool to allocate the combined value from, if necessary </td></tr>
    <tr><td class="paramname">t</td><td>The table to search for the key </td></tr>
    <tr><td class="paramname">key</td><td>The key to search for (case does not matter) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value associated with the key, or NULL if the key does not exist. </dd></dl>

</div>
</div>
<a class="anchor" id="gab02b0393c878208ff6cb55c701ff536a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">APR_DECLARE_NONSTD </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pcre_8txt.html#a42dfa4ff673c82d8efe7144098fbc198">int</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Iterate over a table running the provided function once for every element in the table. The varargs array must be a list of zero or more (char *) keys followed by a NULL pointer. If zero keys are given, the </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comp</td><td>function will be invoked for every element in the table. Otherwise, the function is invoked only for those elements matching the keys specified.</td></tr>
  </table>
  </dd>
</dl>
<p>If an invocation of the comp function returns zero, iteration will continue using the next specified key, if any.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comp</td><td>The function to run </td></tr>
    <tr><td class="paramname">rec</td><td>The data to pass as the first argument to the function </td></tr>
    <tr><td class="paramname">t</td><td>The table to iterate over </td></tr>
    <tr><td class="paramname">...</td><td>A varargs array of zero or more (char *) keys followed by NULL </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>FALSE if one of the <a class="el" href="group__apr__skiplist.html#ga4c81b1eebdb8efeefcadd27cb3fe1c31">comp()</a> iterations returned zero; TRUE if all iterations returned non-zero </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__apr__tables.html#gabac50c7b2bae5f8cef6245d1959f8b06">apr_table_do_callback_fn_t</a> </dd>
<dd>
apr_table_vdo </dd></dl>
<div class="fragment"><div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;{</div><div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;    <span class="keywordtype">int</span> cc;</div><div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;    va_list <a class="code" href="group__APR__Strings__Snprintf.html#ga21ecbc810cd93b85a818c96ca2f92f1a">ap</a>;</div><div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;    <span class="keywordtype">char</span> *<a class="code" href="group__APACHE__CORE__PROTO.html#ga17bc47ccf1b618ed082a4ff4f2cc7f7e">buf</a>;</div><div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;    <span class="keywordtype">int</span> <a class="code" href="group__APACHE__CORE__LOG.html#gab5a43233d60ef05c5b5bf5cba3d74468">len</a>;</div><div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;</div><div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;    buf = <a class="code" href="util__expr__parse_8c.html#a5faf6a2d99f50a4655dd390199a8db7b">malloc</a>(<a class="code" href="group__APACHE__CORE__DAEMON.html#ga0c9dd98f46b90b5bcd4cbf75e252d0da">HUGE_STRING_LEN</a>);</div><div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;    <span class="keywordflow">if</span> (buf == <a class="code" href="pcre_8txt.html#ad7f989d16aa8ca809a36bc392c07fba1">NULL</a>) {</div><div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;        <span class="keywordflow">return</span> 0;</div><div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;    }</div><div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;    va_start(ap, <a class="code" href="group__apr__file__io.html#ga34332e75afdd7ed8d280f2a09b4329ea">format</a>);</div><div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;    len = apr_vsnprintf(buf, <a class="code" href="group__APACHE__CORE__DAEMON.html#ga0c9dd98f46b90b5bcd4cbf75e252d0da">HUGE_STRING_LEN</a>, <a class="code" href="group__apr__file__io.html#ga34332e75afdd7ed8d280f2a09b4329ea">format</a>, ap);</div><div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;    cc = apr_file_puts(buf, fptr);</div><div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;    va_end(ap);</div><div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;    <a class="code" href="util__expr__parse_8c.html#af07d89f5ceaea0c7c8252cc41fd75f37">free</a>(buf);</div><div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;    <span class="keywordflow">return</span> (cc == <a class="code" href="group__apr__errno.html#ga9ee311b7bf1c691dc521d721339ee2a6">APR_SUCCESS</a>) ? len : -1;</div><div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;}</div><div class="ttc" id="group__APACHE__CORE__DAEMON_html_ga0c9dd98f46b90b5bcd4cbf75e252d0da"><div class="ttname"><a href="group__APACHE__CORE__DAEMON.html#ga0c9dd98f46b90b5bcd4cbf75e252d0da">HUGE_STRING_LEN</a></div><div class="ttdeci">#define HUGE_STRING_LEN</div><div class="ttdef"><b>Definition:</b> httpd.h:302</div></div>
<div class="ttc" id="group__APACHE__CORE__LOG_html_gab5a43233d60ef05c5b5bf5cba3d74468"><div class="ttname"><a href="group__APACHE__CORE__LOG.html#gab5a43233d60ef05c5b5bf5cba3d74468">len</a></div><div class="ttdeci">const char apr_size_t len</div><div class="ttdef"><b>Definition:</b> ap_regex.h:140</div></div>
<div class="ttc" id="group__apr__file__io_html_ga34332e75afdd7ed8d280f2a09b4329ea"><div class="ttname"><a href="group__apr__file__io.html#ga34332e75afdd7ed8d280f2a09b4329ea">format</a></div><div class="ttdeci">const char * format</div><div class="ttdef"><b>Definition:</b> apr_file_io.h:873</div></div>
<div class="ttc" id="group__APR__Strings__Snprintf_html_ga21ecbc810cd93b85a818c96ca2f92f1a"><div class="ttname"><a href="group__APR__Strings__Snprintf.html#ga21ecbc810cd93b85a818c96ca2f92f1a">ap</a></div><div class="ttdeci">provider ap</div><div class="ttdef"><b>Definition:</b> apache_probes.d:1</div></div>
<div class="ttc" id="util__expr__parse_8c_html_a5faf6a2d99f50a4655dd390199a8db7b"><div class="ttname"><a href="util__expr__parse_8c.html#a5faf6a2d99f50a4655dd390199a8db7b">malloc</a></div><div class="ttdeci">void * malloc(YYSIZE_T)</div></div>
<div class="ttc" id="pcre_8txt_html_ad7f989d16aa8ca809a36bc392c07fba1"><div class="ttname"><a href="pcre_8txt.html#ad7f989d16aa8ca809a36bc392c07fba1">NULL</a></div><div class="ttdeci">this is a typedef for a structure whose contents are not externally defined It is up to the caller to free the that it does not depend on memory the complete pcre data block is not fully because it may contain a copy of the tableptr argu which is an those that are compatible with but some others as well can also be set and unset from within the the contents of the options argument specifies their settings at the start of compilation and execution The and PCRE_NO_START_OPTIMIZE options can be set at the time of matching as well as at compile time If errptr is NULL</div><div class="ttdef"><b>Definition:</b> pcre.txt:2065</div></div>
<div class="ttc" id="group__APACHE__CORE__PROTO_html_ga17bc47ccf1b618ed082a4ff4f2cc7f7e"><div class="ttname"><a href="group__APACHE__CORE__PROTO.html#ga17bc47ccf1b618ed082a4ff4f2cc7f7e">buf</a></div><div class="ttdeci">int const char * buf</div><div class="ttdef"><b>Definition:</b> http_protocol.h:974</div></div>
<div class="ttc" id="util__expr__parse_8c_html_af07d89f5ceaea0c7c8252cc41fd75f37"><div class="ttname"><a href="util__expr__parse_8c.html#af07d89f5ceaea0c7c8252cc41fd75f37">free</a></div><div class="ttdeci">void free(void *)</div></div>
<div class="ttc" id="group__apr__errno_html_ga9ee311b7bf1c691dc521d721339ee2a6"><div class="ttname"><a href="group__apr__errno.html#ga9ee311b7bf1c691dc521d721339ee2a6">APR_SUCCESS</a></div><div class="ttdeci">#define APR_SUCCESS</div><div class="ttdef"><b>Definition:</b> apr_errno.h:225</div></div>
</div><!-- fragment -->
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__apr__tables_gab02b0393c878208ff6cb55c701ff536a_cgraph.png" border="0" usemap="#group__apr__tables_gab02b0393c878208ff6cb55c701ff536a_cgraph" alt=""/></div>
<map name="group__apr__tables_gab02b0393c878208ff6cb55c701ff536a_cgraph" id="group__apr__tables_gab02b0393c878208ff6cb55c701ff536a_cgraph">
<area shape="rect" id="node2" href="util__expr__parse_8c.html#a5faf6a2d99f50a4655dd390199a8db7b" title="malloc" alt="" coords="239,5,299,32"/>
<area shape="rect" id="node3" href="util__expr__parse_8c.html#af07d89f5ceaea0c7c8252cc41fd75f37" title="free" alt="" coords="247,56,291,83"/>
</map>
</div>
</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="ga1e3f66bfb173c9a913ef3bb37842e273"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structapr__array__header__t.html">apr_array_header_t</a> * arr</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gac7465df964235e37c6f5e1212af22be2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structapr__table__t.html">apr_table_t</a>* b</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga74964146831939c658b798439fc32f6d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structapr__table__t.html">apr_table_t</a> const <a class="el" href="structapr__table__t.html">apr_table_t</a>* base</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga922b4b4bccf7114fd241df5bd432ad58"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcre_8txt.html#a42dfa4ff673c82d8efe7144098fbc198">int</a> <a class="el" href="pcre_8txt.html#a42dfa4ff673c82d8efe7144098fbc198">int</a> elt_size</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga950d7fed8d587d0a9318ffd24f95096f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structapr__array__header__t.html">apr_array_header_t</a>* first</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga8b08a4d2ec878257d64c55f64a62242c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned flags</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gacd3d88da3c0e0313c3645ff34f62f542"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* key</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga3f892b271cc0564b2d8e9536a96abd7c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="pcre_8txt.html#a42dfa4ff673c82d8efe7144098fbc198">int</a> nelts</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga13c7c35ef67602a57343d21ee1d62e61"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structapr__table__t.html">apr_table_t</a>* overlay</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gafcb9c0f7671f566c4804fa8bbad43c4b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MOD__ISAPI.html#gacd6cdbf73df3d9eed42fa493d9b621a6">void</a> const <a class="el" href="structapr__table__t.html">apr_table_t</a> <a class="el" href="group__MOD__ISAPI.html#gacd6cdbf73df3d9eed42fa493d9b621a6">void</a>* rec</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gade8df35e4d83c24788cf409262f7fc51"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structapr__array__header__t.html">apr_array_header_t</a> const <a class="el" href="structapr__array__header__t.html">apr_array_header_t</a>* second</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga37d96adf842aef6b03690e17874c9ed8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structapr__array__header__t.html">apr_array_header_t</a> const char sep</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gab6e7405500bdd51690dc9ef83744684f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structapr__array__header__t.html">apr_array_header_t</a>* src</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gad0d127e044cb4fd448cde5c19d10179e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MOD__ISAPI.html#gacd6cdbf73df3d9eed42fa493d9b621a6">void</a> const <a class="el" href="structapr__table__t.html">apr_table_t</a> <a class="el" href="group__MOD__ISAPI.html#gacd6cdbf73df3d9eed42fa493d9b621a6">void</a> const <a class="el" href="structapr__table__t.html">apr_table_t</a>* t</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga4d708cd93abeca73400ed82977502830"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char const char* val</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga8ca169f10741c89e389d179f952e4dc9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MOD__ISAPI.html#gacd6cdbf73df3d9eed42fa493d9b621a6">void</a> const <a class="el" href="structapr__table__t.html">apr_table_t</a> <a class="el" href="group__MOD__ISAPI.html#gacd6cdbf73df3d9eed42fa493d9b621a6">void</a> const <a class="el" href="structapr__table__t.html">apr_table_t</a> va_list vp</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
