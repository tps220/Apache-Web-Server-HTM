<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>My Project: Internal Memory Allocation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Internal Memory Allocation<div class="ingroups"><a class="el" href="group__APR.html">Apache Portability Runtime library</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Internal Memory Allocation:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__apr__allocator.png" border="0" alt="" usemap="#group____apr____allocator"/>
<map name="group____apr____allocator" id="group____apr____allocator">
<area shape="rect" id="node2" href="group__APR.html" title="Apache Portability\l Runtime library" alt="" coords="5,5,133,47"/>
</map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapr__memnode__t.html">apr_memnode_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gaf382851817012929f4e2458b43f4482c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__allocator.html#gaf382851817012929f4e2458b43f4482c">APR_MEMNODE_T_SIZE</a>&#160;&#160;&#160;<a class="el" href="group__apr__general.html#gab484e98426221f3212fcb67af0467381">APR_ALIGN_DEFAULT</a>(sizeof(<a class="el" href="structapr__memnode__t.html">apr_memnode_t</a>))</td></tr>
<tr class="separator:gaf382851817012929f4e2458b43f4482c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54f32b19d8dad59bc6364a7a6b8ebec9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__allocator.html#ga54f32b19d8dad59bc6364a7a6b8ebec9">APR_ALLOCATOR_MAX_FREE_UNLIMITED</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:ga54f32b19d8dad59bc6364a7a6b8ebec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga1ceabfd30fcfc455e47d052d2a24244b"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structapr__allocator__t.html">apr_allocator_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__allocator.html#ga1ceabfd30fcfc455e47d052d2a24244b">apr_allocator_t</a></td></tr>
<tr class="separator:ga1ceabfd30fcfc455e47d052d2a24244b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b6437036dfcdffbf87ad4677c818211"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structapr__memnode__t.html">apr_memnode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__allocator.html#ga3b6437036dfcdffbf87ad4677c818211">apr_memnode_t</a></td></tr>
<tr class="separator:ga3b6437036dfcdffbf87ad4677c818211"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga9cb19a118179bbd8625eacfec66a9ab8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__allocator.html#ga9cb19a118179bbd8625eacfec66a9ab8">APR_DECLARE</a> (<a class="el" href="group__apr__errno.html#gaa5105fa83cc322f09382292db8b47593">apr_status_t</a>) apr_allocator_create(<a class="el" href="structapr__allocator__t.html">apr_allocator_t</a> **<a class="el" href="group__apr__pools.html#ga3d4c7b6ba19a3b46b6fecdee3d867787">allocator</a>) <a class="el" href="group__APR__Util__Bucket__Brigades.html#gae0af316ed59541b70389da41aaeef4b6">__attribute__</a>((nonnull(1)))</td></tr>
<tr class="separator:ga9cb19a118179bbd8625eacfec66a9ab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3ed16bee8def122c1d7c8f822ee0a5e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__allocator.html#gab3ed16bee8def122c1d7c8f822ee0a5e">APR_DECLARE</a> (<a class="el" href="group__MOD__ISAPI.html#gacd6cdbf73df3d9eed42fa493d9b621a6">void</a>) apr_allocator_destroy(<a class="el" href="structapr__allocator__t.html">apr_allocator_t</a> *<a class="el" href="group__apr__pools.html#ga3d4c7b6ba19a3b46b6fecdee3d867787">allocator</a>) <a class="el" href="group__APR__Util__Bucket__Brigades.html#gae0af316ed59541b70389da41aaeef4b6">__attribute__</a>((nonnull(1)))</td></tr>
<tr class="separator:gab3ed16bee8def122c1d7c8f822ee0a5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a358d9857909db42118ab336d2ed241"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__allocator.html#ga1a358d9857909db42118ab336d2ed241">APR_DECLARE</a> (<a class="el" href="structapr__memnode__t.html">apr_memnode_t</a> *) apr_allocator_alloc(<a class="el" href="structapr__allocator__t.html">apr_allocator_t</a> *<a class="el" href="group__apr__pools.html#ga3d4c7b6ba19a3b46b6fecdee3d867787">allocator</a></td></tr>
<tr class="separator:ga1a358d9857909db42118ab336d2ed241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0af316ed59541b70389da41aaeef4b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__apr__platform.html#gaaa72b2253f6f3032cefea5712a27540e">apr_size_t</a> <a class="el" href="README_8txt.html#a870076999eb1486aa63d2e2cf5cdfa55">size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__allocator.html#gae0af316ed59541b70389da41aaeef4b6">__attribute__</a> ((nonnull(1)))</td></tr>
<tr class="separator:gae0af316ed59541b70389da41aaeef4b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3414f52c685559fb6384c523991b96f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapr__memnode__t.html">apr_memnode_t</a> *memnode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__allocator.html#gae3414f52c685559fb6384c523991b96f">__attribute__</a> ((nonnull(1, 2)))</td></tr>
<tr class="separator:gae3414f52c685559fb6384c523991b96f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f88d1052393c7c22c1e2e2fef1c1067"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__allocator.html#ga1f88d1052393c7c22c1e2e2fef1c1067">APR_DECLARE</a> (<a class="el" href="group__apr__platform.html#gaaa72b2253f6f3032cefea5712a27540e">apr_size_t</a>) apr_allocator_align(<a class="el" href="structapr__allocator__t.html">apr_allocator_t</a> *<a class="el" href="group__apr__pools.html#ga3d4c7b6ba19a3b46b6fecdee3d867787">allocator</a></td></tr>
<tr class="separator:ga1f88d1052393c7c22c1e2e2fef1c1067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5bd5875da60b3e97573ba81258cfd69"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__allocator.html#gac5bd5875da60b3e97573ba81258cfd69">APR_DECLARE</a> (<a class="el" href="structapr__pool__t.html">apr_pool_t</a> *) apr_allocator_owner_get(<a class="el" href="structapr__allocator__t.html">apr_allocator_t</a> *<a class="el" href="group__apr__pools.html#ga3d4c7b6ba19a3b46b6fecdee3d867787">allocator</a>) <a class="el" href="group__APR__Util__Bucket__Brigades.html#gae0af316ed59541b70389da41aaeef4b6">__attribute__</a>((nonnull(1)))</td></tr>
<tr class="separator:gac5bd5875da60b3e97573ba81258cfd69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae93b7565ed822cd38dea54dbaf6141b6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__allocator.html#gae93b7565ed822cd38dea54dbaf6141b6">APR_DECLARE</a> (<a class="el" href="structapr__thread__mutex__t.html">apr_thread_mutex_t</a> *) apr_allocator_mutex_get(<a class="el" href="structapr__allocator__t.html">apr_allocator_t</a> *<a class="el" href="group__apr__pools.html#ga3d4c7b6ba19a3b46b6fecdee3d867787">allocator</a>) <a class="el" href="group__APR__Util__Bucket__Brigades.html#gae0af316ed59541b70389da41aaeef4b6">__attribute__</a>((nonnull(1)))</td></tr>
<tr class="separator:gae93b7565ed822cd38dea54dbaf6141b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga5f598d678d0ca77c25732a145c68d3c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__apr__platform.html#gaaa72b2253f6f3032cefea5712a27540e">apr_size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__allocator.html#ga5f598d678d0ca77c25732a145c68d3c7">size</a></td></tr>
<tr class="separator:ga5f598d678d0ca77c25732a145c68d3c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga54f32b19d8dad59bc6364a7a6b8ebec9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APR_ALLOCATOR_MAX_FREE_UNLIMITED&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Symbolic constants </p>

</div>
</div>
<a class="anchor" id="gaf382851817012929f4e2458b43f4482c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APR_MEMNODE_T_SIZE&#160;&#160;&#160;<a class="el" href="group__apr__general.html#gab484e98426221f3212fcb67af0467381">APR_ALIGN_DEFAULT</a>(sizeof(<a class="el" href="structapr__memnode__t.html">apr_memnode_t</a>))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The base size of a memory node - aligned. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga1ceabfd30fcfc455e47d052d2a24244b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structapr__allocator__t.html">apr_allocator_t</a> <a class="el" href="structapr__allocator__t.html">apr_allocator_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>the allocator structure </p>

</div>
</div>
<a class="anchor" id="ga3b6437036dfcdffbf87ad4677c818211"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structapr__memnode__t.html">apr_memnode_t</a> <a class="el" href="structapr__memnode__t.html">apr_memnode_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>the structure which holds information about the allocation </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gae0af316ed59541b70389da41aaeef4b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__apr__platform.html#gaaa72b2253f6f3032cefea5712a27540e">apr_size_t</a> <a class="el" href="README_8txt.html#a870076999eb1486aa63d2e2cf5cdfa55">size</a> __attribute__ </td>
          <td>(</td>
          <td class="paramtype">(nonnull(1))&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gae3414f52c685559fb6384c523991b96f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapr__memnode__t.html">apr_memnode_t</a>* memnode __attribute__ </td>
          <td>(</td>
          <td class="paramtype">(nonnull(1, 2))&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga9cb19a118179bbd8625eacfec66a9ab8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">APR_DECLARE </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apr__errno.html#gaa5105fa83cc322f09382292db8b47593">apr_status_t</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new allocator </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td>The allocator we have just created.</td></tr>
  </table>
  </dd>
</dl>
<p>Load a DSO library. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res_handle</td><td>Location to store new handle for the DSO. </td></tr>
    <tr><td class="paramname">path</td><td>Path to the DSO library </td></tr>
    <tr><td class="paramname">ctx</td><td>Pool to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000010">Bug:</a></b></dt><dd>We aught to provide an alternative to RTLD_GLOBAL, which is the only supported method of loading DSOs today. </dd></dl>
<p>Close a DSO library. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>handle to close.</td></tr>
  </table>
  </dd>
</dl>
<p>Load a symbol from a DSO handle. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ressym</td><td>Location to store the loaded symbol </td></tr>
    <tr><td class="paramname">handle</td><td>handle to load the symbol from. </td></tr>
    <tr><td class="paramname">symname</td><td>Name of the symbol to load.</td></tr>
  </table>
  </dd>
</dl>
<p>Get the value of an environment variable </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the returned value, allocated from <em>pool</em> </td></tr>
    <tr><td class="paramname">envvar</td><td>the name of the environment variable </td></tr>
    <tr><td class="paramname">pool</td><td>where to allocate <em>value</em> and any temporary storage from</td></tr>
  </table>
  </dd>
</dl>
<p>Set the value of an environment variable </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">envvar</td><td>the name of the environment variable </td></tr>
    <tr><td class="paramname">value</td><td>the value to set </td></tr>
    <tr><td class="paramname">pool</td><td>where to allocate temporary storage from</td></tr>
  </table>
  </dd>
</dl>
<p>Delete a variable from the environment </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">envvar</td><td>the name of the environment variable </td></tr>
    <tr><td class="paramname">pool</td><td>where to allocate temporary storage from</td></tr>
  </table>
  </dd>
</dl>
<p>Perform shell escaping on the provided string.</p>
<p>Shell escaping causes characters to be prefixed with a '\' character. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">escaped</td><td>Optional buffer to write the encoded string, can be NULL </td></tr>
    <tr><td class="paramname">str</td><td>The original string </td></tr>
    <tr><td class="paramname">slen</td><td>The length of the original string, or APR_ESCAPE_STRING </td></tr>
    <tr><td class="paramname">len</td><td>If present, returns the length of the string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>APR_SUCCESS, or APR_NOTFOUND if no changes to the string were detected or the string was NULL</dd></dl>
<p>Unescapes a URL, leaving reserved characters intact. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">escaped</td><td>Optional buffer to write the encoded string, can be NULL </td></tr>
    <tr><td class="paramname">url</td><td>String to be unescaped </td></tr>
    <tr><td class="paramname">slen</td><td>The length of the original url, or APR_ESCAPE_STRING </td></tr>
    <tr><td class="paramname">forbid</td><td>Optional list of forbidden characters, in addition to 0x00 </td></tr>
    <tr><td class="paramname">reserved</td><td>Optional list of reserved characters that will be left unescaped </td></tr>
    <tr><td class="paramname">plus</td><td>If non zero, '+' is converted to ' ' as per application/x-www-form-urlencoded encoding </td></tr>
    <tr><td class="paramname">len</td><td>If set, the length of the escaped string will be returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>APR_SUCCESS on success, APR_NOTFOUND if no characters are decoded or the string is NULL, APR_EINVAL if a bad escape sequence is found, APR_BADCH if a character on the forbid list is found.</dd></dl>
<p>Escape a path segment, as defined in RFC1808. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">escaped</td><td>Optional buffer to write the encoded string, can be NULL </td></tr>
    <tr><td class="paramname">str</td><td>The original string </td></tr>
    <tr><td class="paramname">slen</td><td>The length of the original string, or APR_ESCAPE_STRING </td></tr>
    <tr><td class="paramname">len</td><td>If present, returns the length of the string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>APR_SUCCESS, or APR_NOTFOUND if no changes to the string were detected or the string was NULL</dd></dl>
<p>Converts an OS path to a URL, in an OS dependent way, as defined in RFC1808. In all cases if a ':' occurs before the first '/' in the URL, the URL should be prefixed with "./" (or the ':' escaped). In the case of Unix, this means leaving '/' alone, but otherwise doing what escape_path_segment() does. For efficiency reasons, we don't use escape_path_segment(), which is provided for reference. Again, RFC 1808 is where this stuff is defined.</p>
<p>If partial is set, os_escape_path() assumes that the path will be appended to something with a '/' in it (and thus does not prefix "./"). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">escaped</td><td>Optional buffer to write the encoded string, can be NULL </td></tr>
    <tr><td class="paramname">path</td><td>The original string </td></tr>
    <tr><td class="paramname">slen</td><td>The length of the original string, or APR_ESCAPE_STRING </td></tr>
    <tr><td class="paramname">partial</td><td>If non zero, suppresses the prepending of "./" </td></tr>
    <tr><td class="paramname">len</td><td>If present, returns the length of the string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>APR_SUCCESS, or APR_NOTFOUND if no changes to the string were detected or if the string was NULL</dd></dl>
<p>Urlencode a string, as defined in <a href="http://www.w3.org/TR/html401/interact/forms.html#h-17.13.4.1">http://www.w3.org/TR/html401/interact/forms.html#h-17.13.4.1</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">escaped</td><td>Optional buffer to write the encoded string, can be NULL </td></tr>
    <tr><td class="paramname">str</td><td>The original string </td></tr>
    <tr><td class="paramname">slen</td><td>The length of the original string, or APR_ESCAPE_STRING </td></tr>
    <tr><td class="paramname">len</td><td>If present, returns the length of the string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>APR_SUCCESS, or APR_NOTFOUND if no changes to the string were detected or if the stirng was NULL</dd></dl>
<p>Apply entity encoding to a string. Characters are replaced as follows: '&lt;' becomes '&lt;', '&gt;' becomes '&gt;', '&amp;' becomes '&amp;', the double quote becomes '&quot;" and the single quote becomes '''.</p>
<p>If toasc is not zero, any non ascii character will be encoded as '%#ddd;', where ddd is the decimal code of the character. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">escaped</td><td>Optional buffer to write the encoded string, can be NULL </td></tr>
    <tr><td class="paramname">str</td><td>The original string </td></tr>
    <tr><td class="paramname">slen</td><td>The length of the original string, or APR_ESCAPE_STRING </td></tr>
    <tr><td class="paramname">toasc</td><td>If non zero, encode non ascii characters </td></tr>
    <tr><td class="paramname">len</td><td>If present, returns the length of the string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>APR_SUCCESS, or APR_NOTFOUND if no changes to the string were detected or the string was NULL</dd></dl>
<p>Decodes html entities or numeric character references in a string. If the string to be unescaped is syntactically incorrect, then the following fixups will be made: unknown entities will be left undecoded; references to unused numeric characters will be deleted. In particular, &amp;#00; will not be decoded, but will be deleted. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">unescaped</td><td>Optional buffer to write the encoded string, can be NULL </td></tr>
    <tr><td class="paramname">str</td><td>The original string </td></tr>
    <tr><td class="paramname">slen</td><td>The length of the original string, or APR_ESCAPE_STRING </td></tr>
    <tr><td class="paramname">len</td><td>If present, returns the length of the string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>APR_SUCCESS, or APR_NOTFOUND if no changes to the string were detected or the string was NULL</dd></dl>
<p>Escape control characters in a string, as performed by the shell's 'echo' command. Characters are replaced as follows: \a alert (bell), \b backspace, \f form feed, \n new line, \r carriage return, \t horizontal tab, \v vertical tab, \ backslash.</p>
<p>Any non ascii character will be encoded as '\xHH', where HH is the hex code of the character.</p>
<p>If quote is not zero, the double quote character will also be escaped. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">escaped</td><td>Optional buffer to write the encoded string, can be NULL </td></tr>
    <tr><td class="paramname">str</td><td>The original string </td></tr>
    <tr><td class="paramname">slen</td><td>The length of the original string, or APR_ESCAPE_STRING </td></tr>
    <tr><td class="paramname">quote</td><td>If non zero, encode double quotes </td></tr>
    <tr><td class="paramname">len</td><td>If present, returns the length of the string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>APR_SUCCESS, or APR_NOTFOUND if no changes to the string were detected or the string was NULL</dd></dl>
<p>Convert binary data to a hex encoding. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The destination buffer, can be NULL </td></tr>
    <tr><td class="paramname">src</td><td>The original buffer </td></tr>
    <tr><td class="paramname">srclen</td><td>The length of the original buffer </td></tr>
    <tr><td class="paramname">colon</td><td>If not zero, insert colon characters between hex digits. </td></tr>
    <tr><td class="paramname">len</td><td>If present, returns the length of the string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>APR_SUCCESS, or APR_NOTFOUND if the string was NULL</dd></dl>
<p>Convert hex encoded string to binary data. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The destination buffer, can be NULL </td></tr>
    <tr><td class="paramname">str</td><td>The original buffer </td></tr>
    <tr><td class="paramname">slen</td><td>The length of the original buffer </td></tr>
    <tr><td class="paramname">colon</td><td>If not zero, ignore colon characters between hex digits. </td></tr>
    <tr><td class="paramname">len</td><td>If present, returns the length of the string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>APR_SUCCESS, or APR_NOTFOUND if the string was NULL, or APR_BADCH if a non hex character is present.</dd></dl>
<p>Apply LDAP escaping to binary data. Characters from RFC4514 and RFC4515 are escaped with their hex equivalents. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The destination buffer, can be NULL </td></tr>
    <tr><td class="paramname">src</td><td>The original buffer </td></tr>
    <tr><td class="paramname">srclen</td><td>The length of the original buffer </td></tr>
    <tr><td class="paramname">flags</td><td>APR_ESCAPE_LDAP_DN for RFC4514, APR_ESCAPE_LDAP_FILTER for RFC4515, APR_ESCAPE_LDAP_ALL for both </td></tr>
    <tr><td class="paramname">len</td><td>If present, returns the length of the string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>APR_SUCCESS, or APR_NOTFOUND if the string was NULL</dd></dl>
<p>get the specified file's stats. The file is specified by filename, instead of using a pre-opened file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">finfo</td><td>Where to store the information about the file, which is never touched if the call fails. </td></tr>
    <tr><td class="paramname">fname</td><td>The name of the file to stat. </td></tr>
    <tr><td class="paramname">wanted</td><td>The desired <a class="el" href="structapr__finfo__t.html">apr_finfo_t</a> fields, as a bit flag of APR_FINFO_ values </td></tr>
    <tr><td class="paramname">pool</td><td>the pool to use to allocate the new file.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If <code>APR_INCOMPLETE</code> is returned all the fields in <em>finfo</em> may not be filled in, and you need to check the <code>finfo-&gt;valid</code> bitmask to verify that what you're looking for is there.</dd></dl>
<p>Open the specified directory. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_dir</td><td>The opened directory descriptor. </td></tr>
    <tr><td class="paramname">dirname</td><td>The full path to the directory (use / on all systems) </td></tr>
    <tr><td class="paramname">pool</td><td>The pool to use.</td></tr>
  </table>
  </dd>
</dl>
<p>close the specified directory. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thedir</td><td>the directory descriptor to close.</td></tr>
  </table>
  </dd>
</dl>
<p>Read the next entry from the specified directory. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">finfo</td><td>the file info structure and filled in by apr_dir_read </td></tr>
    <tr><td class="paramname">wanted</td><td>The desired <a class="el" href="structapr__finfo__t.html">apr_finfo_t</a> fields, as a bit flag of APR_FINFO_ values </td></tr>
    <tr><td class="paramname">thedir</td><td>the directory descriptor returned from apr_dir_open </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>No ordering is guaranteed for the entries read.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If <code>APR_INCOMPLETE</code> is returned all the fields in <em>finfo</em> may not be filled in, and you need to check the <code>finfo-&gt;valid</code> bitmask to verify that what you're looking for is there. When no more entries are available, APR_ENOENT is returned.</dd></dl>
<p>Rewind the directory to the first entry. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thedir</td><td>the directory descriptor to rewind.</td></tr>
  </table>
  </dd>
</dl>
<p>Extract the rootpath from the given filepath </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rootpath</td><td>the root file path returned with APR_SUCCESS or APR_EINCOMPLETE </td></tr>
    <tr><td class="paramname">filepath</td><td>the pathname to parse for its root component </td></tr>
    <tr><td class="paramname">flags</td><td>the desired rules to apply, from <pre>
     APR_FILEPATH_NATIVE    Use native path separators (e.g. '\' on Win32)
     APR_FILEPATH_TRUENAME  Tests that the root exists, and makes it proper
</pre> </td></tr>
    <tr><td class="paramname">p</td><td>the pool to allocate the new path string from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>on return, filepath points to the first non-root character in the given filepath. In the simplest example, given a filepath of "/foo", returns the rootpath of "/" and filepath points at "foo". This is far more complex on other platforms, which will canonicalize the root form to a consistant format, given the APR_FILEPATH_TRUENAME flag, and also test for the validity of that root (e.g., that a drive d:/ or network share //machine/foovol/). The function returns APR_ERELATIVE if filepath isn't rooted (an error), APR_EINCOMPLETE if the root path is ambiguous (but potentially legitimate, e.g. "/" on Windows is incomplete because it doesn't specify the drive letter), or APR_EBADPATH if the root is simply invalid. APR_SUCCESS is returned if filepath is an absolute path.</dd></dl>
<p>Merge additional file path onto the previously processed rootpath </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newpath</td><td>the merged paths returned </td></tr>
    <tr><td class="paramname">rootpath</td><td>the root file path (NULL uses the current working path) </td></tr>
    <tr><td class="paramname">addpath</td><td>the path to add to the root path </td></tr>
    <tr><td class="paramname">flags</td><td>the desired APR_FILEPATH_ rules to apply when merging </td></tr>
    <tr><td class="paramname">p</td><td>the pool to allocate the new path string from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>if the flag APR_FILEPATH_TRUENAME is given, and the addpath contains wildcard characters ('*', '?') on platforms that don't support such characters within filenames, the paths will be merged, but the result code will be APR_EPATHWILD, and all further segments will not reflect the true filenames including the wildcard and following segments.</dd></dl>
<p>Split a search path into separate components </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pathelts</td><td>the returned components of the search path </td></tr>
    <tr><td class="paramname">liststr</td><td>the search path (e.g., <code>getenv("PATH")</code>) </td></tr>
    <tr><td class="paramname">p</td><td>the pool to allocate the array and path components from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>empty path components do not become part of <em>pathelts</em>. </dd>
<dd>
the path separator in <em>liststr</em> is system specific; e.g., ':' on Unix, ';' on Windows, etc.</dd></dl>
<p>Merge a list of search path components into a single search path </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">liststr</td><td>the returned search path; may be NULL if <em>pathelts</em> is empty </td></tr>
    <tr><td class="paramname">pathelts</td><td>the components of the search path </td></tr>
    <tr><td class="paramname">p</td><td>the pool to allocate the search path from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>emtpy strings in the source array are ignored. </dd>
<dd>
the path separator in <em>liststr</em> is system specific; e.g., ':' on Unix, ';' on Windows, etc.</dd></dl>
<p>Return the default file path (for relative file names) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>the default path string returned </td></tr>
    <tr><td class="paramname">flags</td><td>optional flag APR_FILEPATH_NATIVE to retrieve the default file path in os-native format. </td></tr>
    <tr><td class="paramname">p</td><td>the pool to allocate the default path string from</td></tr>
  </table>
  </dd>
</dl>
<p>Set the default file path (for relative file names) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>the default path returned </td></tr>
    <tr><td class="paramname">p</td><td>the pool to allocate any working storage</td></tr>
  </table>
  </dd>
</dl>
<p>Determine the encoding used internally by the FilePath functions </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">style</td><td>points to a variable which receives the encoding style flag </td></tr>
    <tr><td class="paramname">p</td><td>the pool to allocate any working storage </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Use <code>apr_os_locale_encoding</code> and/or <code>apr_os_default_encoding</code> to get the name of the path encoding if it's not UTF-8.</dd></dl>
<p>Open the specified file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newf</td><td>The opened file descriptor. </td></tr>
    <tr><td class="paramname">fname</td><td>The full path to the file (using / on all systems) </td></tr>
    <tr><td class="paramname">flag</td><td>Or'ed value of: <ul>
<li><a class="el" href="group__apr__file__open__flags.html#gaf9e7303f028b130ff7d4b209d6662d7d">APR_FOPEN_READ</a> open for reading </li>
<li><a class="el" href="group__apr__file__open__flags.html#gac598bb95fc9476b0bf2ed0b1c308842c">APR_FOPEN_WRITE</a> open for writing </li>
<li><a class="el" href="group__apr__file__open__flags.html#gafe94f21ccbf411172e70e7f473af251a">APR_FOPEN_CREATE</a> create the file if not there </li>
<li><a class="el" href="group__apr__file__open__flags.html#ga45f353db9b71d4760a3f35cf3781cfc8">APR_FOPEN_APPEND</a> file ptr is set to end prior to all writes </li>
<li><a class="el" href="group__apr__file__open__flags.html#ga09b05a5bd5db534b93794f7657bcb146">APR_FOPEN_TRUNCATE</a> set length to zero if file exists </li>
<li><a class="el" href="group__apr__file__open__flags.html#gacb20b3028864f34cb26314fe2cacc3fa">APR_FOPEN_BINARY</a> not a text file </li>
<li><a class="el" href="group__apr__file__open__flags.html#gac48fd4c853c9f561632a2e8aaf5d8d97">APR_FOPEN_BUFFERED</a> buffer the data. Default is non-buffered </li>
<li><a class="el" href="group__apr__file__open__flags.html#gabb7fb062cdf1d58faee8c7ea518496f1">APR_FOPEN_EXCL</a> return error if <a class="el" href="group__apr__file__open__flags.html#gafe94f21ccbf411172e70e7f473af251a">APR_FOPEN_CREATE</a> and file exists </li>
<li><a class="el" href="group__apr__file__open__flags.html#ga5d3756f6d242c667ed1d3f54af4916eb">APR_FOPEN_DELONCLOSE</a> delete the file after closing </li>
<li><a class="el" href="group__apr__file__open__flags.html#ga435cd9b2604b11796779c23ffa00a3dd">APR_FOPEN_XTHREAD</a> Platform dependent tag to open the file for use across multiple threads </li>
<li><a class="el" href="group__apr__file__open__flags.html#ga426f6e2a8457ab410d99248269059a18">APR_FOPEN_SHARELOCK</a> Platform dependent support for higher level locked read/write access to support writes across process/machines </li>
<li><a class="el" href="group__apr__file__open__flags.html#ga3fc9b5a7791d9f462997cd29de67eb80">APR_FOPEN_NOCLEANUP</a> Do not register a cleanup with the pool passed in on the <em>pool</em> argument (see below) </li>
<li><a class="el" href="group__apr__file__open__flags.html#ga60c21e28e4a612d58a874fe2cc71a6e4">APR_FOPEN_SENDFILE_ENABLED</a> Open with appropriate platform semantics for sendfile operations. Advisory only, apr_socket_sendfile does not check this flag </li>
<li><a class="el" href="group__apr__file__open__flags.html#gaf6cfaa4789e6264afd186235f0adbc22">APR_FOPEN_LARGEFILE</a> Platform dependent flag to enable large file support, see WARNING below </li>
<li><a class="el" href="group__apr__file__open__flags.html#ga0d155e9bb7fbf1a5cd4e84b5ede059f4">APR_FOPEN_SPARSE</a> Platform dependent flag to enable sparse file support, see WARNING below </li>
<li><a class="el" href="group__apr__file__open__flags.html#ga31e4d14068147e43e1778bcf975dda62">APR_FOPEN_NONBLOCK</a> Platform dependent flag to enable non blocking file io </li>
</ul>
</td></tr>
    <tr><td class="paramname">perm</td><td>Access permissions for file. </td></tr>
    <tr><td class="paramname">pool</td><td>The pool to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If perm is <a class="el" href="group__apr__file__permissions.html#gad3c65a67ee6eb12ecc6a33857397900b">APR_FPROT_OS_DEFAULT</a> and the file is being created, appropriate default permissions will be used. </dd>
<dd>
By default, the returned file descriptor will not be inherited by child processes created by apr_proc_create(). This can be changed using apr_file_inherit_set().</dd></dl>
<p>Close the specified file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>The file descriptor to close.</td></tr>
  </table>
  </dd>
</dl>
<p>Delete the specified file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The full path to the file (using / on all systems) </td></tr>
    <tr><td class="paramname">pool</td><td>The pool to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the file is open, it won't be removed until all instances are closed.</dd></dl>
<p>Rename the specified file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from_path</td><td>The full path to the original file (using / on all systems) </td></tr>
    <tr><td class="paramname">to_path</td><td>The full path to the new file (using / on all systems) </td></tr>
    <tr><td class="paramname">pool</td><td>The pool to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>If a file exists at the new location, then it will be overwritten. Moving files or directories across devices may not be possible.</dd></dl>
<p>Create a hard link to the specified file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from_path</td><td>The full path to the original file (using / on all systems) </td></tr>
    <tr><td class="paramname">to_path</td><td>The full path to the new file (using / on all systems) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Both files must reside on the same device.</dd></dl>
<p>Copy the specified file to another file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from_path</td><td>The full path to the original file (using / on all systems) </td></tr>
    <tr><td class="paramname">to_path</td><td>The full path to the new file (using / on all systems) </td></tr>
    <tr><td class="paramname">perms</td><td>Access permissions for the new file if it is created. In place of the usual or'd combination of file permissions, the value <a class="el" href="group__apr__file__permissions.html#gac08d4e868c7c9532f7c97c70556663dc">APR_FPROT_FILE_SOURCE_PERMS</a> may be given, in which case the source file's permissions are copied. </td></tr>
    <tr><td class="paramname">pool</td><td>The pool to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The new file does not need to exist, it will be created if required. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If the new file already exists, its contents will be overwritten.</dd></dl>
<p>Append the specified file to another file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from_path</td><td>The full path to the source file (use / on all systems) </td></tr>
    <tr><td class="paramname">to_path</td><td>The full path to the destination file (use / on all systems) </td></tr>
    <tr><td class="paramname">perms</td><td>Access permissions for the destination file if it is created. In place of the usual or'd combination of file permissions, the value <a class="el" href="group__apr__file__permissions.html#gac08d4e868c7c9532f7c97c70556663dc">APR_FPROT_FILE_SOURCE_PERMS</a> may be given, in which case the source file's permissions are copied. </td></tr>
    <tr><td class="paramname">pool</td><td>The pool to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The new file does not need to exist, it will be created if required. </dd>
<dd>
Note that advanced filesystem permissions such as ACLs are not duplicated by this API. The target permissions (including duplicating the source file permissions) are assigned only when the target file does not yet exist.</dd></dl>
<p>Are we at the end of the file </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fptr</td><td>The apr file we are testing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Returns <a class="el" href="group__APR__Error.html#ga35d9dca2514c522a2840aca0f3e2ebd3">APR_EOF</a> if we are at the end of file, <a class="el" href="group__apr__errno.html#ga9ee311b7bf1c691dc521d721339ee2a6">APR_SUCCESS</a> otherwise.</dd></dl>
<p>Open standard error as an apr file pointer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thefile</td><td>The apr file to use as stderr. </td></tr>
    <tr><td class="paramname">pool</td><td>The pool to allocate the file out of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The only reason that the apr_file_open_std* functions exist is that you may not always have a stderr/out/in on Windows. This is generally a problem with newer versions of Windows and services.</dd>
<dd>
The other problem is that the C library functions generally work differently on Windows and Unix. So, by using apr_file_open_std* functions, you can get a handle to an APR struct that works with the APR functions which are supposed to work identically on all platforms.</dd></dl>
<p>open standard output as an apr file pointer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thefile</td><td>The apr file to use as stdout. </td></tr>
    <tr><td class="paramname">pool</td><td>The pool to allocate the file out of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>See remarks for apr_file_open_stderr().</dd></dl>
<p>open standard input as an apr file pointer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thefile</td><td>The apr file to use as stdin. </td></tr>
    <tr><td class="paramname">pool</td><td>The pool to allocate the file out of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>See remarks for apr_file_open_stderr().</dd></dl>
<p>open standard error as an apr file pointer, with flags. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thefile</td><td>The apr file to use as stderr. </td></tr>
    <tr><td class="paramname">flags</td><td>The flags to open the file with. Only the <ul>
<li><a class="el" href="group__apr__file__open__flags.html#gabb7fb062cdf1d58faee8c7ea518496f1">APR_FOPEN_EXCL</a> </li>
<li><a class="el" href="group__apr__file__open__flags.html#gac48fd4c853c9f561632a2e8aaf5d8d97">APR_FOPEN_BUFFERED</a> </li>
<li><a class="el" href="group__apr__file__open__flags.html#ga435cd9b2604b11796779c23ffa00a3dd">APR_FOPEN_XTHREAD</a> </li>
<li><a class="el" href="group__apr__file__open__flags.html#ga426f6e2a8457ab410d99248269059a18">APR_FOPEN_SHARELOCK</a> </li>
<li><a class="el" href="group__apr__file__open__flags.html#ga60c21e28e4a612d58a874fe2cc71a6e4">APR_FOPEN_SENDFILE_ENABLED</a> </li>
<li><a class="el" href="group__apr__file__open__flags.html#gaf6cfaa4789e6264afd186235f0adbc22">APR_FOPEN_LARGEFILE</a></li>
</ul>
flags should be used. The <a class="el" href="group__apr__file__open__flags.html#gac598bb95fc9476b0bf2ed0b1c308842c">APR_FOPEN_WRITE</a> flag will be set unconditionally. </td></tr>
    <tr><td class="paramname">pool</td><td>The pool to allocate the file out of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>See remarks for apr_file_open_stderr().</dd></dl>
<p>open standard output as an apr file pointer, with flags. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thefile</td><td>The apr file to use as stdout. </td></tr>
    <tr><td class="paramname">flags</td><td>The flags to open the file with. Only the <ul>
<li><a class="el" href="group__apr__file__open__flags.html#gabb7fb062cdf1d58faee8c7ea518496f1">APR_FOPEN_EXCL</a> </li>
<li><a class="el" href="group__apr__file__open__flags.html#gac48fd4c853c9f561632a2e8aaf5d8d97">APR_FOPEN_BUFFERED</a> </li>
<li><a class="el" href="group__apr__file__open__flags.html#ga435cd9b2604b11796779c23ffa00a3dd">APR_FOPEN_XTHREAD</a> </li>
<li><a class="el" href="group__apr__file__open__flags.html#ga426f6e2a8457ab410d99248269059a18">APR_FOPEN_SHARELOCK</a> </li>
<li><a class="el" href="group__apr__file__open__flags.html#ga60c21e28e4a612d58a874fe2cc71a6e4">APR_FOPEN_SENDFILE_ENABLED</a> </li>
<li><a class="el" href="group__apr__file__open__flags.html#gaf6cfaa4789e6264afd186235f0adbc22">APR_FOPEN_LARGEFILE</a></li>
</ul>
flags should be used. The <a class="el" href="group__apr__file__open__flags.html#gac598bb95fc9476b0bf2ed0b1c308842c">APR_FOPEN_WRITE</a> flag will be set unconditionally. </td></tr>
    <tr><td class="paramname">pool</td><td>The pool to allocate the file out of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>See remarks for apr_file_open_stderr().</dd></dl>
<p>open standard input as an apr file pointer, with flags. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thefile</td><td>The apr file to use as stdin. </td></tr>
    <tr><td class="paramname">flags</td><td>The flags to open the file with. Only the <ul>
<li><a class="el" href="group__apr__file__open__flags.html#gabb7fb062cdf1d58faee8c7ea518496f1">APR_FOPEN_EXCL</a> </li>
<li><a class="el" href="group__apr__file__open__flags.html#gac48fd4c853c9f561632a2e8aaf5d8d97">APR_FOPEN_BUFFERED</a> </li>
<li><a class="el" href="group__apr__file__open__flags.html#ga435cd9b2604b11796779c23ffa00a3dd">APR_FOPEN_XTHREAD</a> </li>
<li><a class="el" href="group__apr__file__open__flags.html#ga426f6e2a8457ab410d99248269059a18">APR_FOPEN_SHARELOCK</a> </li>
<li><a class="el" href="group__apr__file__open__flags.html#ga60c21e28e4a612d58a874fe2cc71a6e4">APR_FOPEN_SENDFILE_ENABLED</a> </li>
<li><a class="el" href="group__apr__file__open__flags.html#gaf6cfaa4789e6264afd186235f0adbc22">APR_FOPEN_LARGEFILE</a></li>
</ul>
flags should be used. The <a class="el" href="group__apr__file__open__flags.html#gac598bb95fc9476b0bf2ed0b1c308842c">APR_FOPEN_WRITE</a> flag will be set unconditionally. </td></tr>
    <tr><td class="paramname">pool</td><td>The pool to allocate the file out of.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>See remarks for apr_file_open_stderr().</dd></dl>
<p>Read data from the specified file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thefile</td><td>The file descriptor to read from. </td></tr>
    <tr><td class="paramname">buf</td><td>The buffer to store the data to. </td></tr>
    <tr><td class="paramname">nbytes</td><td>On entry, the number of bytes to read; on exit, the number of bytes read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>apr_file_read() will read up to the specified number of bytes, but never more. If there isn't enough data to fill that number of bytes, all of the available data is read. The third argument is modified to reflect the number of bytes read. If a char was put back into the stream via ungetc, it will be the first character returned.</dd>
<dd>
It is not possible for both bytes to be read and an <a class="el" href="group__APR__Error.html#ga35d9dca2514c522a2840aca0f3e2ebd3">APR_EOF</a> or other error to be returned. <a class="el" href="group__APR__Error.html#gaee1ce306c0ebf1701b34172310aa1bd5">APR_EINTR</a> is never returned.</dd></dl>
<p>Write data to the specified file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thefile</td><td>The file descriptor to write to. </td></tr>
    <tr><td class="paramname">buf</td><td>The buffer which contains the data. </td></tr>
    <tr><td class="paramname">nbytes</td><td>On entry, the number of bytes to write; on exit, the number of bytes written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>apr_file_write() will write up to the specified number of bytes, but never more. If the OS cannot write that many bytes, it will write as many as it can. The third argument is modified to reflect the * number of bytes written.</dd>
<dd>
It is possible for both bytes to be written and an error to be returned. <a class="el" href="group__APR__Error.html#gaee1ce306c0ebf1701b34172310aa1bd5">APR_EINTR</a> is never returned.</dd></dl>
<p>Write data from iovec array to the specified file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thefile</td><td>The file descriptor to write to. </td></tr>
    <tr><td class="paramname">vec</td><td>The array from which to get the data to write to the file. </td></tr>
    <tr><td class="paramname">nvec</td><td>The number of elements in the struct iovec array. This must be smaller than <a class="el" href="group__apr__file__writev.html#gae04a4721139b2b252ea20e68883da4b4">APR_MAX_IOVEC_SIZE</a>. If it isn't, the function will fail with <a class="el" href="group__APR__Error.html#gae3ffc41994444e71ce522c036ca1d9a4">APR_EINVAL</a>. </td></tr>
    <tr><td class="paramname">nbytes</td><td>The number of bytes written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>It is possible for both bytes to be written and an error to be returned. <a class="el" href="group__APR__Error.html#gaee1ce306c0ebf1701b34172310aa1bd5">APR_EINTR</a> is never returned.</dd>
<dd>
apr_file_writev() is available even if the underlying operating system doesn't provide <a class="el" href="apr__arch__os2calls_8h.html#a3d0f3996136a9b5ab46431c60c746efd">writev()</a>.</dd></dl>
<p>Read data from the specified file, ensuring that the buffer is filled before returning. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thefile</td><td>The file descriptor to read from. </td></tr>
    <tr><td class="paramname">buf</td><td>The buffer to store the data to. </td></tr>
    <tr><td class="paramname">nbytes</td><td>The number of bytes to read. </td></tr>
    <tr><td class="paramname">bytes_read</td><td>If non-NULL, this will contain the number of bytes read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>apr_file_read_full() will read up to the specified number of bytes, but never more. If there isn't enough data to fill that number of bytes, then the process/thread will block until it is available or EOF is reached. If a char was put back into the stream via ungetc, it will be the first character returned.</dd>
<dd>
It is possible for both bytes to be read and an error to be returned. And if *bytes_read is less than nbytes, an accompanying error is <em>always</em> returned.</dd>
<dd>
<a class="el" href="group__APR__Error.html#gaee1ce306c0ebf1701b34172310aa1bd5">APR_EINTR</a> is never returned.</dd></dl>
<p>Write data to the specified file, ensuring that all of the data is written before returning. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thefile</td><td>The file descriptor to write to. </td></tr>
    <tr><td class="paramname">buf</td><td>The buffer which contains the data. </td></tr>
    <tr><td class="paramname">nbytes</td><td>The number of bytes to write. </td></tr>
    <tr><td class="paramname">bytes_written</td><td>If non-NULL, set to the number of bytes written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>apr_file_write_full() will write up to the specified number of bytes, but never more. If the OS cannot write that many bytes, the process/thread will block until they can be written. Exceptional error such as "out of space" or "pipe closed" will terminate with an error.</dd>
<dd>
It is possible for both bytes to be written and an error to be returned. And if *bytes_written is less than nbytes, an accompanying error is <em>always</em> returned.</dd>
<dd>
<a class="el" href="group__APR__Error.html#gaee1ce306c0ebf1701b34172310aa1bd5">APR_EINTR</a> is never returned.</dd></dl>
<p>Write data from iovec array to the specified file, ensuring that all of the data is written before returning. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thefile</td><td>The file descriptor to write to. </td></tr>
    <tr><td class="paramname">vec</td><td>The array from which to get the data to write to the file. </td></tr>
    <tr><td class="paramname">nvec</td><td>The number of elements in the struct iovec array. This must be smaller than <a class="el" href="group__apr__file__writev.html#gae04a4721139b2b252ea20e68883da4b4">APR_MAX_IOVEC_SIZE</a>. If it isn't, the function will fail with <a class="el" href="group__APR__Error.html#gae3ffc41994444e71ce522c036ca1d9a4">APR_EINVAL</a>. </td></tr>
    <tr><td class="paramname">nbytes</td><td>The number of bytes written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>apr_file_writev_full() is available even if the underlying operating system doesn't provide <a class="el" href="apr__arch__os2calls_8h.html#a3d0f3996136a9b5ab46431c60c746efd">writev()</a>.</dd></dl>
<p>Write a character into the specified file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to write. </td></tr>
    <tr><td class="paramname">thefile</td><td>The file descriptor to write to</td></tr>
  </table>
  </dd>
</dl>
<p>Read a character from the specified file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to read into </td></tr>
    <tr><td class="paramname">thefile</td><td>The file descriptor to read from</td></tr>
  </table>
  </dd>
</dl>
<p>Put a character back onto a specified stream. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ch</td><td>The character to write. </td></tr>
    <tr><td class="paramname">thefile</td><td>The file descriptor to write to</td></tr>
  </table>
  </dd>
</dl>
<p>Read a line from the specified file </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The buffer to store the string in. </td></tr>
    <tr><td class="paramname">len</td><td>The length of the string </td></tr>
    <tr><td class="paramname">thefile</td><td>The file descriptor to read from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The buffer will be NUL-terminated if any characters are stored. The newline at the end of the line will not be stripped.</dd></dl>
<p>Write the string into the specified file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to write. </td></tr>
    <tr><td class="paramname">thefile</td><td>The file descriptor to write to</td></tr>
  </table>
  </dd>
</dl>
<p>Flush the file's buffer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thefile</td><td>The file descriptor to flush</td></tr>
  </table>
  </dd>
</dl>
<p>Transfer all file modified data and metadata to disk. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thefile</td><td>The file descriptor to sync</td></tr>
  </table>
  </dd>
</dl>
<p>Transfer all file modified data to disk. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thefile</td><td>The file descriptor to sync</td></tr>
  </table>
  </dd>
</dl>
<p>Duplicate the specified file descriptor. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_file</td><td>The structure to duplicate into. </td></tr>
    <tr><td class="paramname">old_file</td><td>The file to duplicate. </td></tr>
    <tr><td class="paramname">p</td><td>The pool to use for the new file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>*new_file must point to a valid <a class="el" href="structapr__file__t.html">apr_file_t</a>, or point to NULL.</dd></dl>
<p>Duplicate the specified file descriptor and close the original </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_file</td><td>The old file that is to be closed and reused </td></tr>
    <tr><td class="paramname">old_file</td><td>The file to duplicate </td></tr>
    <tr><td class="paramname">p</td><td>The pool to use for the new file</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>new_file MUST point at a valid <a class="el" href="structapr__file__t.html">apr_file_t</a>. It cannot be NULL.</dd></dl>
<p>Move the specified file descriptor to a new pool </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_file</td><td>Pointer in which to return the new <a class="el" href="structapr__file__t.html">apr_file_t</a> </td></tr>
    <tr><td class="paramname">old_file</td><td>The file to move </td></tr>
    <tr><td class="paramname">p</td><td>The pool to which the descriptor is to be moved </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Unlike apr_file_dup2(), this function doesn't do an OS dup() operation on the underlying descriptor; it just moves the descriptor's <a class="el" href="structapr__file__t.html">apr_file_t</a> wrapper to a new pool. </dd>
<dd>
The new pool need not be an ancestor of old_file's pool. </dd>
<dd>
After calling this function, old_file may not be used</dd></dl>
<p>Give the specified apr file handle a new buffer </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thefile</td><td>The file handle that is to be modified </td></tr>
    <tr><td class="paramname">buffer</td><td>The buffer </td></tr>
    <tr><td class="paramname">bufsize</td><td>The size of the buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>It is possible to add a buffer to previously unbuffered file handles, the <a class="el" href="group__apr__file__open__flags.html#gac48fd4c853c9f561632a2e8aaf5d8d97">APR_FOPEN_BUFFERED</a> flag will be added to the file handle's flags. Likewise, with buffer=NULL and bufsize=0 arguments it is possible to make a previously buffered file handle unbuffered.</dd></dl>
<p>Move the read/write file offset to a specified byte within a file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thefile</td><td>The file descriptor </td></tr>
    <tr><td class="paramname">where</td><td>How to move the pointer, one of: <ul>
<li><a class="el" href="group__apr__file__seek__flags.html#ga2fdf78845c897f69451d49e1e2b90ac9">APR_SET</a> &ndash; set the offset to offset </li>
<li><a class="el" href="group__apr__file__seek__flags.html#gae17abc53fea00bfd51e184017113e250">APR_CUR</a> &ndash; add the offset to the current position </li>
<li><a class="el" href="group__apr__file__seek__flags.html#ga438f3568be799d1e4bbd19492ca47d22">APR_END</a> &ndash; add the offset to the current file size </li>
</ul>
</td></tr>
    <tr><td class="paramname">offset</td><td>The offset to move the pointer to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The third argument is modified to be the offset the pointer was actually moved to.</dd></dl>
<p>Create an anonymous pipe. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The newly created pipe's file for reading. </td></tr>
    <tr><td class="paramname">out</td><td>The newly created pipe's file for writing. </td></tr>
    <tr><td class="paramname">pool</td><td>The pool to operate on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>By default, the returned file descriptors will be inherited by child processes created using apr_proc_create(). This can be changed using apr_file_inherit_unset(). </dd></dl>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000012">Bug:</a></b></dt><dd>Some platforms cannot toggle between blocking and nonblocking, and when passing a pipe as a standard handle to an application which does not expect it, a non-blocking stream will fluxor the client app. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000038">Deprecated:</a></b></dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd>apr_file_pipe_create_pools()</dd></dl>
<p>Create an anonymous pipe which portably supports async timeout options. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The newly created pipe's file for reading. </td></tr>
    <tr><td class="paramname">out</td><td>The newly created pipe's file for writing. </td></tr>
    <tr><td class="paramname">blocking</td><td>one of these values defined in apr_thread_proc.h; <ul>
<li><a class="el" href="group__apr__thread__proc.html#ga646af57314e71f4647243f36dd03e5ea">APR_FULL_BLOCK</a> </li>
<li><a class="el" href="group__apr__thread__proc.html#gaf8295548cb0821ee02249d6de8336bcb">APR_READ_BLOCK</a> </li>
<li><a class="el" href="group__apr__thread__proc.html#ga36ff2de9664ad6995bd488b4ac715c9c">APR_WRITE_BLOCK</a> </li>
<li><a class="el" href="group__apr__thread__proc.html#gae0707f76da785490830fc3491093767c">APR_FULL_NONBLOCK</a> </li>
</ul>
</td></tr>
    <tr><td class="paramname">pool</td><td>The pool to operate on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>By default, the returned file descriptors will be inherited by child processes created using apr_proc_create(). This can be changed using apr_file_inherit_unset(). </dd>
<dd>
Some platforms cannot toggle between blocking and nonblocking, and when passing a pipe as a standard handle to an application which does not expect it, a non-blocking stream will fluxor the client app. Use this function rather than apr_file_pipe_create() to create pipes where one or both ends require non-blocking semantics. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000039">Deprecated:</a></b></dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd>apr_file_pipe_create_pools()</dd></dl>
<p>Create an anonymous pipe which portably supports async timeout options, placing each side of the pipe in a different pool. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The newly created pipe's file for reading. </td></tr>
    <tr><td class="paramname">out</td><td>The newly created pipe's file for writing. </td></tr>
    <tr><td class="paramname">blocking</td><td>one of these values defined in apr_thread_proc.h; <ul>
<li><a class="el" href="group__apr__thread__proc.html#ga646af57314e71f4647243f36dd03e5ea">APR_FULL_BLOCK</a> </li>
<li><a class="el" href="group__apr__thread__proc.html#gaf8295548cb0821ee02249d6de8336bcb">APR_READ_BLOCK</a> </li>
<li><a class="el" href="group__apr__thread__proc.html#ga36ff2de9664ad6995bd488b4ac715c9c">APR_WRITE_BLOCK</a> </li>
<li><a class="el" href="group__apr__thread__proc.html#gae0707f76da785490830fc3491093767c">APR_FULL_NONBLOCK</a> </li>
</ul>
</td></tr>
    <tr><td class="paramname">pool_in</td><td>The pool for the reading pipe. </td></tr>
    <tr><td class="paramname">pool_out</td><td>The pool for the writing pipe. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>By default, the returned file descriptors will be inherited by child processes created using apr_proc_create(). This can be changed using apr_file_inherit_unset(). </dd>
<dd>
Some platforms cannot toggle between blocking and nonblocking, and when passing a pipe as a standard handle to an application which does not expect it, a non-blocking stream will fluxor the client app. Use this function rather than apr_file_pipe_create() to create pipes where one or both ends require non-blocking semantics.</dd></dl>
<p>Create a named pipe. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The filename of the named pipe </td></tr>
    <tr><td class="paramname">perm</td><td>The permissions for the newly created pipe. </td></tr>
    <tr><td class="paramname">pool</td><td>The pool to operate on.</td></tr>
  </table>
  </dd>
</dl>
<p>Get the timeout value for a pipe or manipulate the blocking state. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thepipe</td><td>The pipe we are getting a timeout for. </td></tr>
    <tr><td class="paramname">timeout</td><td>The current timeout value in microseconds.</td></tr>
  </table>
  </dd>
</dl>
<p>Set the timeout value for a pipe or manipulate the blocking state. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thepipe</td><td>The pipe we are setting a timeout on. </td></tr>
    <tr><td class="paramname">timeout</td><td>The timeout value in microseconds. Values &lt; 0 mean wait forever, 0 means do not wait at all.</td></tr>
  </table>
  </dd>
</dl>
<p>file (un)locking functions. Establish a lock on the specified, open file. The lock may be advisory or mandatory, at the discretion of the platform. The lock applies to the file as a whole, rather than a specific range. Locks are established on a per-thread/process basis; a second lock by the same thread will not block. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thefile</td><td>The file to lock. </td></tr>
    <tr><td class="paramname">type</td><td>The type of lock to establish on the file.</td></tr>
  </table>
  </dd>
</dl>
<p>Remove any outstanding locks on the file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thefile</td><td>The file to unlock.</td></tr>
  </table>
  </dd>
</dl>
<p>accessor and general file_io functions. return the file name of the current file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_path</td><td>The path of the file. </td></tr>
    <tr><td class="paramname">thefile</td><td>The currently open file.</td></tr>
  </table>
  </dd>
</dl>
<p>Return the data associated with the current file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The user data associated with the file. </td></tr>
    <tr><td class="paramname">key</td><td>The key to use for retrieving data associated with this file. </td></tr>
    <tr><td class="paramname">file</td><td>The currently open file.</td></tr>
  </table>
  </dd>
</dl>
<p>Set the data associated with the current file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>The currently open file. </td></tr>
    <tr><td class="paramname">data</td><td>The user data to associate with the file. </td></tr>
    <tr><td class="paramname">key</td><td>The key to use for associating data with the file. </td></tr>
    <tr><td class="paramname">cleanup</td><td>The cleanup routine to use when the file is destroyed.</td></tr>
  </table>
  </dd>
</dl>
<p>set the specified file's permission bits. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fname</td><td>The file (name) to apply the permissions to. </td></tr>
    <tr><td class="paramname">perms</td><td>The permission bits to apply to the file.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Some platforms may not be able to apply all of the available permission bits; <a class="el" href="group__APR__Error.html#ga64dff43b83bcefd3f3c751be6b864ca1">APR_INCOMPLETE</a> will be returned if some permissions are specified which could not be set.</dd>
<dd>
Platforms which do not implement this feature will return <a class="el" href="group__APR__Error.html#ga939ddb834a30bc9a5a0a329b13000161">APR_ENOTIMPL</a>.</dd></dl>
<p>Set attributes of the specified file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fname</td><td>The full path to the file (using / on all systems) </td></tr>
    <tr><td class="paramname">attributes</td><td>Or'd combination of <ul>
<li><a class="el" href="group__apr__file__attrs__set__flags.html#ga333f2c798495cfb95ee624e11c862e38">APR_FILE_ATTR_READONLY</a> - make the file readonly </li>
<li><a class="el" href="group__apr__file__attrs__set__flags.html#ga51346f433e354f0bc8722388b6b275fd">APR_FILE_ATTR_EXECUTABLE</a> - make the file executable </li>
<li><a class="el" href="group__apr__file__attrs__set__flags.html#ga68c188c0e56b9abdef3c97ffd913c5aa">APR_FILE_ATTR_HIDDEN</a> - make the file hidden </li>
</ul>
</td></tr>
    <tr><td class="paramname">attr_mask</td><td>Mask of valid bits in attributes. </td></tr>
    <tr><td class="paramname">pool</td><td>the pool to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function should be used in preference to explicit manipulation of the file permissions, because the operations to provide these attributes are platform specific and may involve more than simply setting permission bits. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Platforms which do not implement this feature will return <a class="el" href="group__APR__Error.html#ga939ddb834a30bc9a5a0a329b13000161">APR_ENOTIMPL</a>.</dd></dl>
<p>Set the mtime of the specified file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fname</td><td>The full path to the file (using / on all systems) </td></tr>
    <tr><td class="paramname">mtime</td><td>The mtime to apply to the file. </td></tr>
    <tr><td class="paramname">pool</td><td>The pool to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Platforms which do not implement this feature will return <a class="el" href="group__APR__Error.html#ga939ddb834a30bc9a5a0a329b13000161">APR_ENOTIMPL</a>.</dd></dl>
<p>Create a new directory on the file system. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>the path for the directory to be created. (use / on all systems) </td></tr>
    <tr><td class="paramname">perm</td><td>Permissions for the new directory. </td></tr>
    <tr><td class="paramname">pool</td><td>the pool to use.</td></tr>
  </table>
  </dd>
</dl>
<p>Creates a new directory on the file system, but behaves like 'mkdir -p'. Creates intermediate directories as required. No error will be reported if PATH already exists. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>the path for the directory to be created. (use / on all systems) </td></tr>
    <tr><td class="paramname">perm</td><td>Permissions for the new directory. </td></tr>
    <tr><td class="paramname">pool</td><td>the pool to use.</td></tr>
  </table>
  </dd>
</dl>
<p>Remove directory from the file system. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>the path for the directory to be removed. (use / on all systems) </td></tr>
    <tr><td class="paramname">pool</td><td>the pool to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Removing a directory which is in-use (e.g., the current working directory, or during apr_dir_read, or with an open file) is not portable.</dd></dl>
<p>get the specified file's stats. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">finfo</td><td>Where to store the information about the file. </td></tr>
    <tr><td class="paramname">wanted</td><td>The desired <a class="el" href="structapr__finfo__t.html">apr_finfo_t</a> fields, as a bit flag of APR_FINFO_* values </td></tr>
    <tr><td class="paramname">thefile</td><td>The file to get information about.</td></tr>
  </table>
  </dd>
</dl>
<p>Truncate the file's length to the specified offset </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fp</td><td>The file to truncate </td></tr>
    <tr><td class="paramname">offset</td><td>The offset to truncate to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The read/write file offset is repositioned to offset.</dd></dl>
<p>Retrieve the flags that were passed into apr_file_open() when the file was opened. </p><dl class="section return"><dt>Returns</dt><dd>apr_int32_t the flags</dd></dl>
<p>Open a temporary file </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fp</td><td>The apr file to use as a temporary file. </td></tr>
    <tr><td class="paramname">templ</td><td>The template to use when creating a temp file. </td></tr>
    <tr><td class="paramname">flags</td><td>The flags to open the file with. If this is zero, the file is opened with <a class="el" href="group__apr__file__open__flags.html#gafe94f21ccbf411172e70e7f473af251a">APR_FOPEN_CREATE</a> | <a class="el" href="group__apr__file__open__flags.html#gaf9e7303f028b130ff7d4b209d6662d7d">APR_FOPEN_READ</a> | <a class="el" href="group__apr__file__open__flags.html#gac598bb95fc9476b0bf2ed0b1c308842c">APR_FOPEN_WRITE</a> | <a class="el" href="group__apr__file__open__flags.html#gabb7fb062cdf1d58faee8c7ea518496f1">APR_FOPEN_EXCL</a> | <a class="el" href="group__apr__file__open__flags.html#ga5d3756f6d242c667ed1d3f54af4916eb">APR_FOPEN_DELONCLOSE</a> </td></tr>
    <tr><td class="paramname">p</td><td>The pool to allocate the file out of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function generates a unique temporary file name from template. The last six characters of template must be XXXXXX and these are replaced with a string that makes the filename unique. Since it will be modified, template must not be a string constant, but should be declared as a character array.</dd></dl>
<p>Find an existing directory suitable as a temporary storage location. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">temp_dir</td><td>The temp directory. </td></tr>
    <tr><td class="paramname">p</td><td>The pool to use for any necessary allocations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function uses an algorithm to search for a directory that an an application can use for temporary storage.</dd></dl>
<p>Setup any APR internal data structures. This MUST be the first function called for any APR library. It is safe to call apr_initialize several times as long as apr_terminate is called the same number of times. </p><dl class="section remark"><dt>Remarks</dt><dd>See apr_app_initialize if this is an application, rather than a library consumer of apr.</dd></dl>
<p>Set up an application with normalized argc, argv (and optionally env) in order to deal with platform-specific oddities, such as Win32 services, code pages and signals. This must be the first function called for any APR program. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">argc</td><td>Pointer to the argc that may be corrected </td></tr>
    <tr><td class="paramname">argv</td><td>Pointer to the argv that may be corrected </td></tr>
    <tr><td class="paramname">env</td><td>Pointer to the env that may be corrected, may be NULL </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>See apr_initialize if this is a library consumer of apr. Otherwise, this call is identical to apr_initialize, and must be closed with a call to apr_terminate at the end of program execution.</dd></dl>
<p>Generate random bytes. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Buffer to fill with random bytes </td></tr>
    <tr><td class="paramname">length</td><td>Length of buffer in bytes</td></tr>
  </table>
  </dd>
</dl>
<p>Initialize the arguments for parsing by apr_getopt(). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>The options structure created for apr_getopt() </td></tr>
    <tr><td class="paramname">cont</td><td>The pool to operate on </td></tr>
    <tr><td class="paramname">argc</td><td>The number of arguments to parse </td></tr>
    <tr><td class="paramname">argv</td><td>The array of arguments to parse </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Arguments 3 and 4 are most commonly argc and argv from main(argc, argv) The (*os)-&gt;errfn is initialized to fprintf(stderr... but may be overridden.</dd></dl>
<p>Parse the options initialized by apr_getopt_init(). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>The apr_opt_t structure returned by apr_getopt_init() </td></tr>
    <tr><td class="paramname">opts</td><td>A string of characters that are acceptable options to the program. Characters followed by ":" are required to have an option associated </td></tr>
    <tr><td class="paramname">option_ch</td><td>The next option character parsed </td></tr>
    <tr><td class="paramname">option_arg</td><td>The argument following the option character: </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>There are four potential status values on exit. They are: <pre>
            APR_EOF      &ndash;  No more options to parse
            APR_BADCH    &ndash;  Found a bad option character
            APR_BADARG   &ndash;  No argument followed the option flag
            APR_SUCCESS  &ndash;  The next option was found.
</pre></dd></dl>
<p>Parse the options initialized by apr_getopt_init(), accepting long options beginning with "--" in addition to single-character options beginning with "-". </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>The <a class="el" href="structapr__getopt__t.html">apr_getopt_t</a> structure created by apr_getopt_init() </td></tr>
    <tr><td class="paramname">opts</td><td>A pointer to a list of <a class="el" href="structapr__getopt__option__t.html">apr_getopt_option_t</a> structures, which can be initialized with { "name", optch, has_args }. has_args is nonzero if the option requires an argument. A structure with an optch value of 0 terminates the list. </td></tr>
    <tr><td class="paramname">option_ch</td><td>Receives the value of "optch" from the <a class="el" href="structapr__getopt__option__t.html">apr_getopt_option_t</a> structure corresponding to the next option matched. </td></tr>
    <tr><td class="paramname">option_arg</td><td>Receives the argument following the option, if any. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>There are four potential status values on exit. They are: <pre>
            APR_EOF      --  No more options to parse
            APR_BADCH    --  Found a bad option character
            APR_BADARG   --  No argument followed the option flag
            APR_SUCCESS  --  The next option was found.
</pre> When APR_SUCCESS is returned, os-&gt;ind gives the index of the first non-option argument. On error, a message will be printed to stdout unless os-&gt;err is set to 0. If os-&gt;interleave is set to nonzero, options can come after arguments, and os-&gt;argv will be permuted to leave non-option arguments at the end (the original argv is unaffected).</dd></dl>
<p>Create and initialize a mutex that can be used to synchronize both processes and threads. Note: There is considerable overhead in using this API if only cross-process or cross-thread mutual exclusion is required. See apr_proc_mutex.h and apr_thread_mutex.h for more specialized lock routines. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>the memory address where the newly created mutex will be stored. </td></tr>
    <tr><td class="paramname">fname</td><td>A file name to use if the lock mechanism requires one. This argument should always be provided. The lock code itself will determine if it should be used. </td></tr>
    <tr><td class="paramname">mech</td><td>The mechanism to use for the interprocess lock, if any; one of <pre>
           APR_LOCK_FCNTL
           APR_LOCK_FLOCK
           APR_LOCK_SYSVSEM
           APR_LOCK_POSIXSEM
           APR_LOCK_PROC_PTHREAD
           APR_LOCK_DEFAULT     pick the default mechanism for the platform
</pre> </td></tr>
    <tr><td class="paramname">pool</td><td>the pool from which to allocate the mutex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Check APR_HAS_foo_SERIALIZE defines to see if the platform supports APR_LOCK_foo. Only APR_LOCK_DEFAULT is portable.</dd></dl>
<p>Re-open a mutex in a child process. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>The newly re-opened mutex structure. </td></tr>
    <tr><td class="paramname">fname</td><td>A file name to use if the mutex mechanism requires one. This argument should always be provided. The mutex code itself will determine if it should be used. This filename should be the same one that was passed to apr_global_mutex_create(). </td></tr>
    <tr><td class="paramname">pool</td><td>The pool to operate on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function must be called to maintain portability, even if the underlying lock mechanism does not require it.</dd></dl>
<p>Acquire the lock for the given mutex. If the mutex is already locked, the current thread will be put to sleep until the lock becomes available. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>the mutex on which to acquire the lock.</td></tr>
  </table>
  </dd>
</dl>
<p>Attempt to acquire the lock for the given mutex. If the mutex has already been acquired, the call returns immediately with APR_EBUSY. Note: it is important that the <a class="el" href="group__APR__STATUS__IS.html#gabb92ad7b6ef304132de70e9e5cbaa896">APR_STATUS_IS_EBUSY(s)</a> macro be used to determine if the return value was APR_EBUSY, for portability reasons. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>the mutex on which to attempt the lock acquiring.</td></tr>
  </table>
  </dd>
</dl>
<p>Release the lock for the given mutex. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>the mutex from which to release the lock.</td></tr>
  </table>
  </dd>
</dl>
<p>Destroy the mutex and free the memory associated with the lock. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>the mutex to destroy.</td></tr>
  </table>
  </dd>
</dl>
<p>Iterate over a hash table running the provided function once for every element in the hash table. The </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comp</td><td>function will be invoked for every element in the hash table.</td></tr>
    <tr><td class="paramname">comp</td><td>The function to run </td></tr>
    <tr><td class="paramname">rec</td><td>The data to pass as the first argument to the function </td></tr>
    <tr><td class="paramname">ht</td><td>The hash table to iterate over </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>FALSE if one of the <a class="el" href="group__apr__skiplist.html#ga4c81b1eebdb8efeefcadd27cb3fe1c31">comp()</a> iterations returned zero; TRUE if all iterations returned non-zero </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__apr__hash.html#ga9352d7eed661ad06b7635314530a3227">apr_hash_do_callback_fn_t</a></dd></dl>
<p>apr_vformatter() is a generic printf-style formatting routine with some extensions. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flush_func</td><td>The function to call when the buffer is full </td></tr>
    <tr><td class="paramname">c</td><td>The buffer to write to </td></tr>
    <tr><td class="paramname">fmt</td><td>The format string </td></tr>
    <tr><td class="paramname">ap</td><td>The arguments to use to fill out the format string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd><pre>
The extensions are:</pre></dd></dl>
<ul>
<li><pre>%pA takes a struct in_addr *, and prints it as a.b.c.d</pre></li>
<li><pre>%pI takes an <a class="el" href="structapr__sockaddr__t.html">apr_sockaddr_t</a> * and prints it as a.b.c.d:port or
[ipv6-address]:port</pre></li>
<li><pre>%pT takes an apr_os_thread_t * and prints it in decimal
('0' is printed if !APR_HAS_THREADS)</pre></li>
<li><pre>%pt takes an apr_os_thread_t * and prints it in hexadecimal
('0' is printed if !APR_HAS_THREADS)</pre></li>
<li><pre>%pm takes an apr_status_t * and prints the appropriate error
string (from apr_strerror) corresponding to that error code.</pre></li>
<li><pre>%pp takes a void * and outputs it in hex</pre></li>
<li><pre>%pB takes a apr_uint32_t * as bytes and outputs it's apr_strfsize</pre></li>
<li><pre>%pF same as above, but takes a apr_off_t *</pre></li>
<li><pre>%pS same as above, but takes a apr_size_t *</pre></li>
</ul>
<pre>%pA, %pI, %pT, %pp are available from APR 1.0.0 onwards (and in 0.9.x).
%pt is only available from APR 1.2.0 onwards.
%pm, %pB, %pF and %pS are only available from APR 1.3.0 onwards.</pre><pre>The %p hacks are to force gcc's printf warning code to skip
over a pointer argument without complaining.  This does
mean that the ANSI-style %p (output a void * in hex format) won't
work as expected at all, but that seems to be a fair trade-off
for the increased robustness of having printf-warnings work.</pre><pre>Additionally, apr_vformatter allows for arbitrary output methods
using the apr_vformatter_buff and flush_func.</pre><pre>The apr_vformatter_buff has two elements curpos and endpos.
curpos is where apr_vformatter will write the next byte of output.
It proceeds writing output to curpos, and updating curpos, until
either the end of output is reached, or curpos == endpos (i.e. the
buffer is full).</pre><pre>If the end of output is reached, apr_vformatter returns the
number of bytes written.</pre><pre>When the buffer is full, the flush_func is called.  The flush_func
can return -1 to indicate that no further output should be attempted,
and apr_vformatter will return immediately with -1.  Otherwise
the flush_func should flush the buffer in whatever manner is
appropriate, re <a class="el" href="structapr__pool__t.html">apr_pool_t</a> nitialize curpos and endpos, and return 0.</pre><pre>Note that flush_func is only invoked as a result of attempting to
write another byte at curpos when curpos &gt;= endpos.  So for
example, it's possible when the output exactly matches the buffer
space available that curpos == endpos will be true when
apr_vformatter returns.</pre><pre>apr_vformatter does not call out to any other code, it is entirely
self-contained.  This allows the callers to do things which are
otherwise "unsafe".  For example, apr_psprintf uses the "scratch"
space at the unallocated end of a block, and doesn't actually
complete the allocation until apr_vformatter returns.  apr_psprintf
would be completely broken if apr_vformatter were to call anything
that used this same pool.  Similarly http_bprintf() uses the "scratch"
space at the end of its output buffer, and doesn't actually note
that the space is in use until it either has to flush the buffer
or until apr_vformatter returns.
</pre><p>Display a prompt and read in the password from stdin. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prompt</td><td>The prompt to display </td></tr>
    <tr><td class="paramname">pwbuf</td><td>Buffer to store the password </td></tr>
    <tr><td class="paramname">bufsize</td><td>The length of the password buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the password entered must be truncated to fit in the provided buffer, APR_ENAMETOOLONG will be returned. Note that the bufsize paramater is passed by reference for no reason; its value will never be modified by the apr_password_get() function.</dd></dl>
<p>Create a new mmap'ed file out of an existing APR file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newmmap</td><td>The newly created mmap'ed file. </td></tr>
    <tr><td class="paramname">file</td><td>The file to turn into an mmap. </td></tr>
    <tr><td class="paramname">offset</td><td>The offset into the file to start the data pointer at. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the file </td></tr>
    <tr><td class="paramname">flag</td><td>bit-wise or of: <pre>
         APR_MMAP_READ       MMap opened for reading
         APR_MMAP_WRITE      MMap opened for writing
</pre> </td></tr>
    <tr><td class="paramname">cntxt</td><td>The pool to use when creating the mmap.</td></tr>
  </table>
  </dd>
</dl>
<p>Duplicate the specified MMAP. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_mmap</td><td>The structure to duplicate into. </td></tr>
    <tr><td class="paramname">old_mmap</td><td>The mmap to duplicate. </td></tr>
    <tr><td class="paramname">p</td><td>The pool to use for new_mmap.</td></tr>
  </table>
  </dd>
</dl>
<p>Remove a mmap'ed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mm</td><td>The mmap'ed file.</td></tr>
  </table>
  </dd>
</dl>
<p>Move the pointer into the mmap'ed file to the specified offset. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>The pointer to the offset specified. </td></tr>
    <tr><td class="paramname">mm</td><td>The mmap'ed file. </td></tr>
    <tr><td class="paramname">offset</td><td>The offset to move to.</td></tr>
  </table>
  </dd>
</dl>
<p>Create a socket. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_sock</td><td>The new socket that has been set up. </td></tr>
    <tr><td class="paramname">family</td><td>The address family of the socket (e.g., APR_INET). </td></tr>
    <tr><td class="paramname">type</td><td>The type of the socket (e.g., SOCK_STREAM). </td></tr>
    <tr><td class="paramname">protocol</td><td>The protocol of the socket (e.g., APR_PROTO_TCP). </td></tr>
    <tr><td class="paramname">cont</td><td>The pool for the <a class="el" href="structapr__socket__t.html">apr_socket_t</a> and associated storage. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The pool will be used by various functions that operate on the socket. The caller must ensure that it is not used by other threads at the same time.</dd></dl>
<p>Shutdown either reading, writing, or both sides of a socket. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thesocket</td><td>The socket to close </td></tr>
    <tr><td class="paramname">how</td><td>How to shutdown the socket. One of: <pre>
           APR_SHUTDOWN_READ         no longer allow read requests
           APR_SHUTDOWN_WRITE        no longer allow write requests
           APR_SHUTDOWN_READWRITE    no longer allow read or write requests 
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__apr__network__io.html#gae2130f1fa2d0db58c5c3c9c73d9b4009">apr_shutdown_how_e</a> </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This does not actually close the socket descriptor, it just controls which calls are still valid on the socket.</dd></dl>
<p>Close a socket. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thesocket</td><td>The socket to close</td></tr>
  </table>
  </dd>
</dl>
<p>Bind the socket to its associated port </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket to bind </td></tr>
    <tr><td class="paramname">sa</td><td>The socket address to bind to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This may be where we will find out if there is any other process using the selected port.</dd></dl>
<p>Listen to a bound socket for connections. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket to listen on </td></tr>
    <tr><td class="paramname">backlog</td><td>The number of outstanding connections allowed in the sockets listen queue. If this value is less than zero, the listen queue size is set to zero.</td></tr>
  </table>
  </dd>
</dl>
<p>Accept a new connection request </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_sock</td><td>A copy of the socket that is connected to the socket that made the connection request. This is the socket which should be used for all future communication. </td></tr>
    <tr><td class="paramname">sock</td><td>The socket we are listening on. </td></tr>
    <tr><td class="paramname">connection_pool</td><td>The pool for the new socket. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The pool will be used by various functions that operate on the socket. The caller must ensure that it is not used by other threads at the same time.</dd></dl>
<p>Issue a connection request to a socket either on the same machine or a different one. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket we wish to use for our side of the connection </td></tr>
    <tr><td class="paramname">sa</td><td>The address of the machine we wish to connect to.</td></tr>
  </table>
  </dd>
</dl>
<p>Determine whether the receive part of the socket has been closed by the peer (such that a subsequent call to apr_socket_read would return APR_EOF), if the socket's receive buffer is empty. This function does not block waiting for I/O.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket to check </td></tr>
    <tr><td class="paramname">atreadeof</td><td>If APR_SUCCESS is returned, *atreadeof is set to non-zero if a subsequent read would return APR_EOF </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an error is returned if it was not possible to determine the status, in which case *atreadeof is not changed.</dd></dl>
<p>Create <a class="el" href="structapr__sockaddr__t.html">apr_sockaddr_t</a> from hostname, address family, and port. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sa</td><td>The new <a class="el" href="structapr__sockaddr__t.html">apr_sockaddr_t</a>. </td></tr>
    <tr><td class="paramname">hostname</td><td>The hostname or numeric address string to resolve/parse, or NULL to build an address that corresponds to 0.0.0.0 or :: or in case of APR_UNIX family it is absolute socket filename. </td></tr>
    <tr><td class="paramname">family</td><td>The address family to use, or APR_UNSPEC if the system should decide. </td></tr>
    <tr><td class="paramname">port</td><td>The port number. </td></tr>
    <tr><td class="paramname">flags</td><td>Special processing flags: <pre>
      APR_IPV4_ADDR_OK          first query for IPv4 addresses; only look
                                for IPv6 addresses if the first query failed;
                                only valid if family is APR_UNSPEC and hostname
                                isn't NULL; mutually exclusive with
                                APR_IPV6_ADDR_OK
      APR_IPV6_ADDR_OK          first query for IPv6 addresses; only look
                                for IPv4 addresses if the first query failed;
                                only valid if family is APR_UNSPEC and hostname
                                isn't NULL and APR_HAVE_IPV6; mutually exclusive
                                with APR_IPV4_ADDR_OK
</pre> </td></tr>
    <tr><td class="paramname">p</td><td>The pool for the <a class="el" href="structapr__sockaddr__t.html">apr_sockaddr_t</a> and associated storage.</td></tr>
  </table>
  </dd>
</dl>
<p>Copy <a class="el" href="structapr__sockaddr__t.html">apr_sockaddr_t</a> src to dst on pool p. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>The destination <a class="el" href="structapr__sockaddr__t.html">apr_sockaddr_t</a>. </td></tr>
    <tr><td class="paramname">src</td><td>The source <a class="el" href="structapr__sockaddr__t.html">apr_sockaddr_t</a>. </td></tr>
    <tr><td class="paramname">p</td><td>The pool for the <a class="el" href="structapr__sockaddr__t.html">apr_sockaddr_t</a> and associated storage.</td></tr>
  </table>
  </dd>
</dl>
<p>Look up the host name from an <a class="el" href="structapr__sockaddr__t.html">apr_sockaddr_t</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hostname</td><td>The hostname. </td></tr>
    <tr><td class="paramname">sa</td><td>The <a class="el" href="structapr__sockaddr__t.html">apr_sockaddr_t</a>. </td></tr>
    <tr><td class="paramname">flags</td><td>Special processing flags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Results can vary significantly between platforms when processing wildcard socket addresses.</dd></dl>
<p>Parse hostname/IP address with scope id and port.</p>
<p>Any of the following strings are accepted: 8080 (just the port number) www.apache.org (just the hostname) www.apache.org:8080 (hostname and port number)</p>
<p>[fe80::1eth0] (IPv6 numeric address string and scope id)</p>
<p>Invalid strings: (empty string) [abc] (not valid IPv6 numeric address string) abc:65536 (invalid port number)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>The new buffer containing just the hostname. On output, *addr will be NULL if no hostname/IP address was specfied. </td></tr>
    <tr><td class="paramname">scope_id</td><td>The new buffer containing just the scope id. On output, *scope_id will be NULL if no scope id was specified. </td></tr>
    <tr><td class="paramname">port</td><td>The port number. On output, *port will be 0 if no port was specified. <h3>FIXME: 0 is a legal port (per RFC 1700). this should</h3>
</td></tr>
  </table>
  </dd>
</dl>
<h3>return something besides zero if the port is missing.</h3>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The input string to be parsed. </td></tr>
    <tr><td class="paramname">p</td><td>The pool from which *addr and *scope_id are allocated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If scope id shouldn't be allowed, check for scope_id != NULL in addition to checking the return code. If addr/hostname should be required, check for addr == NULL in addition to checking the return code.</dd></dl>
<p>Get name of the current machine </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>A buffer to store the hostname in. </td></tr>
    <tr><td class="paramname">len</td><td>The maximum length of the hostname that can be stored in the buffer provided. The suggested length is APRMAXHOSTLEN + 1. </td></tr>
    <tr><td class="paramname">cont</td><td>The pool to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the buffer was not large enough, an error will be returned.</dd></dl>
<p>Return the data associated with the current socket </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The user data associated with the socket. </td></tr>
    <tr><td class="paramname">key</td><td>The key to associate with the user data. </td></tr>
    <tr><td class="paramname">sock</td><td>The currently open socket.</td></tr>
  </table>
  </dd>
</dl>
<p>Set the data associated with the current socket. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The currently open socket. </td></tr>
    <tr><td class="paramname">data</td><td>The user data to associate with the socket. </td></tr>
    <tr><td class="paramname">key</td><td>The key to associate with the data. </td></tr>
    <tr><td class="paramname">cleanup</td><td>The cleanup to call when the socket is destroyed.</td></tr>
  </table>
  </dd>
</dl>
<p>Send data over a network. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket to send the data over. </td></tr>
    <tr><td class="paramname">buf</td><td>The buffer which contains the data to be sent. </td></tr>
    <tr><td class="paramname">len</td><td>On entry, the number of bytes to send; on exit, the number of bytes sent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd><pre>
This functions acts like a blocking write by default.  To change 
this behavior, use <a class="el" href="unix_2sockopt_8c.html#a945bdbe807ec5635d65a6fd9ddb78c29">apr_socket_timeout_set()</a> or the APR_SO_NONBLOCK
socket option.</pre></dd></dl>
<p>It is possible for both bytes to be sent and an error to be returned.</p>
<pre>APR_EINTR is never returned.
</pre><p>Send multiple buffers over a network. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket to send the data over. </td></tr>
    <tr><td class="paramname">vec</td><td>The array of iovec structs containing the data to send </td></tr>
    <tr><td class="paramname">nvec</td><td>The number of iovec structs in the array </td></tr>
    <tr><td class="paramname">len</td><td>Receives the number of bytes actually written </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd><pre>
This functions acts like a blocking write by default.  To change 
this behavior, use <a class="el" href="unix_2sockopt_8c.html#a945bdbe807ec5635d65a6fd9ddb78c29">apr_socket_timeout_set()</a> or the APR_SO_NONBLOCK
socket option.
The number of bytes actually sent is stored in argument 4.</pre></dd></dl>
<p>It is possible for both bytes to be sent and an error to be returned.</p>
<pre>APR_EINTR is never returned.
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket to send from </td></tr>
    <tr><td class="paramname">where</td><td>The <a class="el" href="structapr__sockaddr__t.html">apr_sockaddr_t</a> describing where to send the data </td></tr>
    <tr><td class="paramname">flags</td><td>The flags to use </td></tr>
    <tr><td class="paramname">buf</td><td>The data to send </td></tr>
    <tr><td class="paramname">len</td><td>The length of the data to send</td></tr>
  </table>
  </dd>
</dl>
<p>Read data from a socket. On success, the address of the peer from which the data was sent is copied into the <em>from</em> parameter, and the <em>len</em> parameter is updated to give the number of bytes written to <em>buf</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>Updated with the address from which the data was received </td></tr>
    <tr><td class="paramname">sock</td><td>The socket to use </td></tr>
    <tr><td class="paramname">flags</td><td>The flags to use </td></tr>
    <tr><td class="paramname">buf</td><td>The buffer to use </td></tr>
    <tr><td class="paramname">len</td><td>The length of the available buffer</td></tr>
  </table>
  </dd>
</dl>
<p>Send a file from an open file descriptor to a socket, along with optional headers and trailers </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket to which we're writing </td></tr>
    <tr><td class="paramname">file</td><td>The open file from which to read </td></tr>
    <tr><td class="paramname">hdtr</td><td>A structure containing the headers and trailers to send </td></tr>
    <tr><td class="paramname">offset</td><td>Offset into the file where we should begin writing </td></tr>
    <tr><td class="paramname">len</td><td>(input) - Number of bytes to send from the file (output) - Number of bytes actually sent, including headers, file, and trailers </td></tr>
    <tr><td class="paramname">flags</td><td>APR flags that are mapped to OS specific flags </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This functions acts like a blocking write by default. To change this behavior, use <a class="el" href="unix_2sockopt_8c.html#a945bdbe807ec5635d65a6fd9ddb78c29">apr_socket_timeout_set()</a> or the APR_SO_NONBLOCK socket option. The number of bytes actually sent is stored in the len parameter. The offset parameter is passed by reference for no reason; its value will never be modified by the apr_socket_sendfile() function.</dd></dl>
<p>Read data from a network. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket to read the data from. </td></tr>
    <tr><td class="paramname">buf</td><td>The buffer to store the data in. </td></tr>
    <tr><td class="paramname">len</td><td>On entry, the number of bytes to receive; on exit, the number of bytes received. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd><pre>
This functions acts like a blocking read by default.  To change 
this behavior, use <a class="el" href="unix_2sockopt_8c.html#a945bdbe807ec5635d65a6fd9ddb78c29">apr_socket_timeout_set()</a> or the APR_SO_NONBLOCK
socket option.
The number of bytes actually received is stored in argument 3.</pre></dd></dl>
<p>It is possible for both bytes to be received and an APR_EOF or other error to be returned.</p>
<pre>APR_EINTR is never returned.
</pre><p>Setup socket options for the specified socket </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket to set up. </td></tr>
    <tr><td class="paramname">opt</td><td>The option we would like to configure. One of: <pre>
           APR_SO_DEBUG      --  turn on debugging information 
           APR_SO_KEEPALIVE  --  keep connections active
           APR_SO_LINGER     --  lingers on close if data is present
           APR_SO_NONBLOCK   --  Turns blocking on/off for socket
                                 When this option is enabled, use
                                 the <a class="el" href="group__APR__STATUS__IS.html#ga9dd578bfcd76a2d997395608ae5b3a4e">APR_STATUS_IS_EAGAIN()</a> macro to
                                 see if a send or receive function
                                 could not transfer data without
                                 blocking.
           APR_SO_REUSEADDR  --  The rules used in validating addresses
                                 supplied to bind should allow reuse
                                 of local addresses.
           APR_SO_SNDBUF     --  Set the SendBufferSize
           APR_SO_RCVBUF     --  Set the ReceiveBufferSize
           APR_SO_FREEBIND   --  Allow binding to non-local IP address.
</pre> </td></tr>
    <tr><td class="paramname">on</td><td>Value for the option.</td></tr>
  </table>
  </dd>
</dl>
<p>Setup socket timeout for the specified socket </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket to set up. </td></tr>
    <tr><td class="paramname">t</td><td>Value for the timeout. <pre>
  t &gt; 0  &ndash; read and write calls return APR_TIMEUP if specified time
            elapsess with no data read or written
  t == 0 &ndash; read and write calls never block
  t &lt; 0  &ndash; read and write calls block
</pre></td></tr>
  </table>
  </dd>
</dl>
<p>Query socket options for the specified socket </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket to query </td></tr>
    <tr><td class="paramname">opt</td><td>The option we would like to query. One of: <pre>
           APR_SO_DEBUG      --  turn on debugging information 
           APR_SO_KEEPALIVE  --  keep connections active
           APR_SO_LINGER     --  lingers on close if data is present
           APR_SO_NONBLOCK   --  Turns blocking on/off for socket
           APR_SO_REUSEADDR  --  The rules used in validating addresses
                                 supplied to bind should allow reuse
                                 of local addresses.
           APR_SO_SNDBUF     --  Set the SendBufferSize
           APR_SO_RCVBUF     --  Set the ReceiveBufferSize
           APR_SO_DISCONNECTED -- Query the disconnected state of the socket.
                                 (Currently only used on Windows)
</pre> </td></tr>
    <tr><td class="paramname">on</td><td>Socket option returned on the call.</td></tr>
  </table>
  </dd>
</dl>
<p>Query socket timeout for the specified socket </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket to query </td></tr>
    <tr><td class="paramname">t</td><td>Socket timeout returned from the query.</td></tr>
  </table>
  </dd>
</dl>
<p>Query the specified socket if at the OOB/Urgent data mark </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket to query </td></tr>
    <tr><td class="paramname">atmark</td><td>Is set to true if socket is at the OOB/urgent mark, otherwise is set to false.</td></tr>
  </table>
  </dd>
</dl>
<p>Return an address associated with a socket; either the address to which the socket is bound locally or the address of the peer to which the socket is connected. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sa</td><td>The returned <a class="el" href="structapr__sockaddr__t.html">apr_sockaddr_t</a>. </td></tr>
    <tr><td class="paramname">which</td><td>Whether to retrieve the local or remote address </td></tr>
    <tr><td class="paramname">sock</td><td>The socket to use</td></tr>
  </table>
  </dd>
</dl>
<p>Return the IP address (in numeric address string format) in an APR socket address. APR will allocate storage for the IP address string from the pool of the <a class="el" href="structapr__sockaddr__t.html">apr_sockaddr_t</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>The IP address. </td></tr>
    <tr><td class="paramname">sockaddr</td><td>The socket address to reference.</td></tr>
  </table>
  </dd>
</dl>
<p>Write the IP address (in numeric address string format) of the APR socket address <em>sockaddr</em> into the buffer <em>buf</em> (of size <em>buflen</em>). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sockaddr</td><td>The socket address to reference.</td></tr>
  </table>
  </dd>
</dl>
<p>See if the IP addresses in two APR socket addresses are equivalent. Appropriate logic is present for comparing IPv4-mapped IPv6 addresses with IPv4 addresses.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr1</td><td>One of the APR socket addresses. </td></tr>
    <tr><td class="paramname">addr2</td><td>The other APR socket address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The return value will be non-zero if the addresses are equivalent.</dd></dl>
<p>See if the IP address in an APR socket address refers to the wildcard address for the protocol family (e.g., INADDR_ANY for IPv4).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>The APR socket address to examine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The return value will be non-zero if the address is initialized and is the wildcard address.</dd></dl>
<p>Return the type of the socket. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket to query. </td></tr>
    <tr><td class="paramname">type</td><td>The returned type (e.g., SOCK_STREAM).</td></tr>
  </table>
  </dd>
</dl>
<p>Given an <a class="el" href="structapr__sockaddr__t.html">apr_sockaddr_t</a> and a service name, set the port for the service </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sockaddr</td><td>The <a class="el" href="structapr__sockaddr__t.html">apr_sockaddr_t</a> that will have its port set </td></tr>
    <tr><td class="paramname">servname</td><td>The name of the service you wish to use</td></tr>
  </table>
  </dd>
</dl>
<p>Build an ip-subnet representation from an IP address and optional netmask or number-of-bits. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ipsub</td><td>The new ip-subnet representation </td></tr>
    <tr><td class="paramname">ipstr</td><td>The input IP address string </td></tr>
    <tr><td class="paramname">mask_or_numbits</td><td>The input netmask or number-of-bits string, or NULL </td></tr>
    <tr><td class="paramname">p</td><td>The pool to allocate from</td></tr>
  </table>
  </dd>
</dl>
<p>Test the IP address in an <a class="el" href="structapr__sockaddr__t.html">apr_sockaddr_t</a> against a pre-built ip-subnet representation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ipsub</td><td>The ip-subnet representation </td></tr>
    <tr><td class="paramname">sa</td><td>The socket address to test </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-zero if the socket address is within the subnet, 0 otherwise</dd></dl>
<p>Return the protocol of the socket. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket to query. </td></tr>
    <tr><td class="paramname">protocol</td><td>The returned protocol (e.g., APR_PROTO_TCP).</td></tr>
  </table>
  </dd>
</dl>
<p>Join a Multicast Group </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket to join a multicast group </td></tr>
    <tr><td class="paramname">join</td><td>The address of the multicast group to join </td></tr>
    <tr><td class="paramname">iface</td><td>Address of the interface to use. If NULL is passed, the default multicast interface will be used. (OS Dependent) </td></tr>
    <tr><td class="paramname">source</td><td>Source Address to accept transmissions from (non-NULL implies Source-Specific Multicast)</td></tr>
  </table>
  </dd>
</dl>
<p>Leave a Multicast Group. All arguments must be the same as apr_mcast_join. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket to leave a multicast group </td></tr>
    <tr><td class="paramname">addr</td><td>The address of the multicast group to leave </td></tr>
    <tr><td class="paramname">iface</td><td>Address of the interface to use. If NULL is passed, the default multicast interface will be used. (OS Dependent) </td></tr>
    <tr><td class="paramname">source</td><td>Source Address to accept transmissions from (non-NULL implies Source-Specific Multicast)</td></tr>
  </table>
  </dd>
</dl>
<p>Set the Multicast Time to Live (ttl) for a multicast transmission. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket to set the multicast ttl </td></tr>
    <tr><td class="paramname">ttl</td><td>Time to live to Assign. 0-255, default=1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the TTL is 0, packets will only be seen by sockets on the local machine, and only when multicast loopback is enabled.</dd></dl>
<p>Toggle IP Multicast Loopback </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket to set multicast loopback </td></tr>
    <tr><td class="paramname">opt</td><td>0=disable, 1=enable</td></tr>
  </table>
  </dd>
</dl>
<p>Set the Interface to be used for outgoing Multicast Transmissions. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket to set the multicast interface on </td></tr>
    <tr><td class="paramname">iface</td><td>Address of the interface to use for Multicast</td></tr>
  </table>
  </dd>
</dl>
<p>Set up a pollset object </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pollset</td><td>The pointer in which to return the newly created object </td></tr>
    <tr><td class="paramname">size</td><td>The maximum number of descriptors that this pollset can hold </td></tr>
    <tr><td class="paramname">p</td><td>The pool from which to allocate the pollset </td></tr>
    <tr><td class="paramname">flags</td><td>Optional flags to modify the operation of the pollset.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If flags contains APR_POLLSET_THREADSAFE, then a pollset is created on which it is safe to make concurrent calls to apr_pollset_add(), apr_pollset_remove() and apr_pollset_poll() from separate threads. This feature is only supported on some platforms; the apr_pollset_create() call will fail with APR_ENOTIMPL on platforms where it is not supported. </dd>
<dd>
If flags contains APR_POLLSET_WAKEABLE, then a pollset is created with an additional internal pipe object used for the apr_pollset_wakeup() call. The actual size of pollset is in that case <em>size</em> + 1. This feature is only supported on some platforms; the apr_pollset_create() call will fail with APR_ENOTIMPL on platforms where it is not supported. </dd>
<dd>
If flags contains APR_POLLSET_NOCOPY, then the <a class="el" href="structapr__pollfd__t.html">apr_pollfd_t</a> structures passed to apr_pollset_add() are not copied and must have a lifetime at least as long as the pollset. </dd>
<dd>
Some poll methods (including APR_POLLSET_KQUEUE, APR_POLLSET_PORT, and APR_POLLSET_EPOLL) do not have a fixed limit on the size of the pollset. For these methods, the size parameter controls the maximum number of descriptors that will be returned by a single call to apr_pollset_poll().</dd></dl>
<p>Set up a pollset object </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pollset</td><td>The pointer in which to return the newly created object </td></tr>
    <tr><td class="paramname">size</td><td>The maximum number of descriptors that this pollset can hold </td></tr>
    <tr><td class="paramname">p</td><td>The pool from which to allocate the pollset </td></tr>
    <tr><td class="paramname">flags</td><td>Optional flags to modify the operation of the pollset. </td></tr>
    <tr><td class="paramname">method</td><td>Poll method to use. See <a class="el" href="group__apr__poll.html#gabe6f1238ea45e9425fa052e2788e4a29">apr_pollset_method_e</a>. If this method cannot be used, the default method will be used unless the APR_POLLSET_NODEFAULT flag has been specified.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If flags contains APR_POLLSET_THREADSAFE, then a pollset is created on which it is safe to make concurrent calls to apr_pollset_add(), apr_pollset_remove() and apr_pollset_poll() from separate threads. This feature is only supported on some platforms; the apr_pollset_create_ex() call will fail with APR_ENOTIMPL on platforms where it is not supported. </dd>
<dd>
If flags contains APR_POLLSET_WAKEABLE, then a pollset is created with additional internal pipe object used for the apr_pollset_wakeup() call. The actual size of pollset is in that case size + 1. This feature is only supported on some platforms; the apr_pollset_create_ex() call will fail with APR_ENOTIMPL on platforms where it is not supported. </dd>
<dd>
If flags contains APR_POLLSET_NOCOPY, then the <a class="el" href="structapr__pollfd__t.html">apr_pollfd_t</a> structures passed to apr_pollset_add() are not copied and must have a lifetime at least as long as the pollset. </dd>
<dd>
Some poll methods (including APR_POLLSET_KQUEUE, APR_POLLSET_PORT, and APR_POLLSET_EPOLL) do not have a fixed limit on the size of the pollset. For these methods, the size parameter controls the maximum number of descriptors that will be returned by a single call to apr_pollset_poll().</dd></dl>
<p>Destroy a pollset object </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pollset</td><td>The pollset to destroy</td></tr>
  </table>
  </dd>
</dl>
<p>Add a socket or file descriptor to a pollset </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pollset</td><td>The pollset to which to add the descriptor </td></tr>
    <tr><td class="paramname">descriptor</td><td>The descriptor to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If you set client_data in the descriptor, that value will be returned in the client_data field whenever this descriptor is signalled in apr_pollset_poll(). </dd>
<dd>
If the pollset has been created with APR_POLLSET_THREADSAFE and thread T1 is blocked in a call to apr_pollset_poll() for this same pollset that is being modified via apr_pollset_add() in thread T2, the currently executing apr_pollset_poll() call in T1 will either: (1) automatically include the newly added descriptor in the set of descriptors it is watching or (2) return immediately with APR_EINTR. Option (1) is recommended, but option (2) is allowed for implementations where option (1) is impossible or impractical. </dd>
<dd>
If the pollset has been created with APR_POLLSET_NOCOPY, the <a class="el" href="structapr__pollfd__t.html">apr_pollfd_t</a> structure referenced by descriptor will not be copied and must have a lifetime at least as long as the pollset. </dd>
<dd>
Do not add the same socket or file descriptor to the same pollset multiple times, even if the requested events differ for the different calls to apr_pollset_add(). If the events of interest for a descriptor change, you must first remove the descriptor from the pollset with apr_pollset_remove(), then add it again specifying all requested events.</dd></dl>
<p>Remove a descriptor from a pollset </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pollset</td><td>The pollset from which to remove the descriptor </td></tr>
    <tr><td class="paramname">descriptor</td><td>The descriptor to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the descriptor is not found, APR_NOTFOUND is returned. </dd>
<dd>
If the pollset has been created with APR_POLLSET_THREADSAFE and thread T1 is blocked in a call to apr_pollset_poll() for this same pollset that is being modified via apr_pollset_remove() in thread T2, the currently executing apr_pollset_poll() call in T1 will either: (1) automatically exclude the newly added descriptor in the set of descriptors it is watching or (2) return immediately with APR_EINTR. Option (1) is recommended, but option (2) is allowed for implementations where option (1) is impossible or impractical. </dd>
<dd>
apr_pollset_remove() cannot be used to remove a subset of requested events for a descriptor. The reqevents field in the <a class="el" href="structapr__pollfd__t.html">apr_pollfd_t</a> parameter must contain the same value when removing as when adding.</dd></dl>
<p>Block for activity on the descriptor(s) in a pollset </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pollset</td><td>The pollset to use </td></tr>
    <tr><td class="paramname">timeout</td><td>The amount of time in microseconds to wait. This is a maximum, not a minimum. If a descriptor is signalled, the function will return before this time. If timeout is negative, the function will block until a descriptor is signalled or until apr_pollset_wakeup() has been called. </td></tr>
    <tr><td class="paramname">num</td><td>Number of signalled descriptors (output parameter) </td></tr>
    <tr><td class="paramname">descriptors</td><td>Array of signalled descriptors (output parameter) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>APR_EINTR will be returned if the pollset has been created with APR_POLLSET_WAKEABLE, apr_pollset_wakeup() has been called while waiting for activity, and there were no signalled descriptors at the time of the wakeup call. </dd>
<dd>
Multiple signalled conditions for the same descriptor may be reported in one or more returned <a class="el" href="structapr__pollfd__t.html">apr_pollfd_t</a> structures, depending on the implementation.</dd></dl>
<p>Interrupt the blocked apr_pollset_poll() call. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pollset</td><td>The pollset to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the pollset was not created with APR_POLLSET_WAKEABLE the return value is APR_EINIT.</dd></dl>
<p>Poll the descriptors in the poll structure </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aprset</td><td>The poll structure we will be using. </td></tr>
    <tr><td class="paramname">numsock</td><td>The number of descriptors we are polling </td></tr>
    <tr><td class="paramname">nsds</td><td>The number of descriptors signalled (output parameter) </td></tr>
    <tr><td class="paramname">timeout</td><td>The amount of time in microseconds to wait. This is a maximum, not a minimum. If a descriptor is signalled, the function will return before this time. If timeout is negative, the function will block until a descriptor is signalled or until apr_pollset_wakeup() has been called. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The number of descriptors signalled is returned in the third argument. This is a blocking call, and it will not return until either a descriptor has been signalled or the timeout has expired. </dd>
<dd>
The rtnevents field in the <a class="el" href="structapr__pollfd__t.html">apr_pollfd_t</a> array will only be filled- in if the return value is APR_SUCCESS.</dd></dl>
<p>Set up a pollcb object </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pollcb</td><td>The pointer in which to return the newly created object </td></tr>
    <tr><td class="paramname">size</td><td>The maximum number of descriptors that a single _poll can return. </td></tr>
    <tr><td class="paramname">p</td><td>The pool from which to allocate the pollcb </td></tr>
    <tr><td class="paramname">flags</td><td>Optional flags to modify the operation of the pollcb.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If flags contains APR_POLLSET_WAKEABLE, then a pollcb is created with an additional internal pipe object used for the apr_pollcb_wakeup() call. The actual size of pollcb is in that case <em>size</em> + 1. </dd>
<dd>
Pollcb is only supported on some platforms; the apr_pollcb_create() call will fail with APR_ENOTIMPL on platforms where it is not supported.</dd></dl>
<p>Set up a pollcb object </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pollcb</td><td>The pointer in which to return the newly created object </td></tr>
    <tr><td class="paramname">size</td><td>The maximum number of descriptors that a single _poll can return. </td></tr>
    <tr><td class="paramname">p</td><td>The pool from which to allocate the pollcb </td></tr>
    <tr><td class="paramname">flags</td><td>Optional flags to modify the operation of the pollcb. </td></tr>
    <tr><td class="paramname">method</td><td>Poll method to use. See <a class="el" href="group__apr__poll.html#gabe6f1238ea45e9425fa052e2788e4a29">apr_pollset_method_e</a>. If this method cannot be used, the default method will be used unless the APR_POLLSET_NODEFAULT flag has been specified.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If flags contains APR_POLLSET_WAKEABLE, then a pollcb is created with an additional internal pipe object used for the apr_pollcb_wakeup() call. The actual size of pollcb is in that case <em>size</em> + 1. </dd>
<dd>
Pollcb is only supported on some platforms; the apr_pollcb_create_ex() call will fail with APR_ENOTIMPL on platforms where it is not supported.</dd></dl>
<p>Add a socket or file descriptor to a pollcb </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pollcb</td><td>The pollcb to which to add the descriptor </td></tr>
    <tr><td class="paramname">descriptor</td><td>The descriptor to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If you set client_data in the descriptor, that value will be returned in the client_data field whenever this descriptor is signalled in apr_pollcb_poll(). </dd>
<dd>
Unlike the apr_pollset API, the descriptor is not copied, and users must retain the memory used by descriptor, as the same pointer will be returned to them from apr_pollcb_poll. </dd>
<dd>
Do not add the same socket or file descriptor to the same pollcb multiple times, even if the requested events differ for the different calls to apr_pollcb_add(). If the events of interest for a descriptor change, you must first remove the descriptor from the pollcb with apr_pollcb_remove(), then add it again specifying all requested events.</dd></dl>
<p>Remove a descriptor from a pollcb </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pollcb</td><td>The pollcb from which to remove the descriptor </td></tr>
    <tr><td class="paramname">descriptor</td><td>The descriptor to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the descriptor is not found, APR_NOTFOUND is returned. </dd>
<dd>
apr_pollcb_remove() cannot be used to remove a subset of requested events for a descriptor. The reqevents field in the <a class="el" href="structapr__pollfd__t.html">apr_pollfd_t</a> parameter must contain the same value when removing as when adding.</dd></dl>
<p>Block for activity on the descriptor(s) in a pollcb </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pollcb</td><td>The pollcb to use </td></tr>
    <tr><td class="paramname">timeout</td><td>The amount of time in microseconds to wait. This is a maximum, not a minimum. If a descriptor is signalled, the function will return before this time. If timeout is negative, the function will block until a descriptor is signalled or until apr_pollcb_wakeup() has been called. </td></tr>
    <tr><td class="paramname">func</td><td>Callback function to call for each active descriptor. </td></tr>
    <tr><td class="paramname">baton</td><td>Opaque baton passed to the callback function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Multiple signalled conditions for the same descriptor may be reported in one or more calls to the callback function, depending on the implementation. </dd>
<dd>
APR_EINTR will be returned if the pollset has been created with APR_POLLSET_WAKEABLE and apr_pollcb_wakeup() has been called while waiting for activity.</dd></dl>
<p>Interrupt the blocked apr_pollcb_poll() call. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pollcb</td><td>The pollcb to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the pollcb was not created with APR_POLLSET_WAKEABLE the return value is APR_EINIT.</dd></dl>
<p>Setup all of the internal structures required to use pools </p><dl class="section remark"><dt>Remarks</dt><dd>Programs do NOT need to call this directly. APR will call this automatically from apr_initialize.</dd></dl>
<p>Create a new pool. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newpool</td><td>The pool we have just created. </td></tr>
    <tr><td class="paramname">parent</td><td>The parent pool. If this is NULL, the new pool is a root pool. If it is non-NULL, the new pool will inherit all of its parent pool's attributes, except the <a class="el" href="structapr__pool__t.html">apr_pool_t</a> will be a sub-pool. </td></tr>
    <tr><td class="paramname">abort_fn</td><td>A function to use if the pool cannot allocate more memory. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use with the new pool. If NULL the allocator of the parent pool will be used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function is thread-safe, in the sense that multiple threads can safely create subpools of the same parent pool concurrently. Similarly, a subpool can be created by one thread at the same time that another thread accesses the parent pool.</dd></dl>
<p>Create a new pool. </p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000041">Deprecated:</a></b></dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd>apr_pool_create_unmanaged_ex.</dd></dl>
<p>Create a new unmanaged pool. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newpool</td><td>The pool we have just created. </td></tr>
    <tr><td class="paramname">abort_fn</td><td>A function to use if the pool cannot allocate more memory. </td></tr>
    <tr><td class="paramname">allocator</td><td>The allocator to use with the new pool. If NULL a new allocator will be created with the new pool as owner. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>An unmanaged pool is a special pool without a parent; it will NOT be destroyed upon apr_terminate. It must be explicitly destroyed by calling apr_pool_destroy, to prevent memory leaks. Use of this function is discouraged, think twice about whether you really really need it. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Any child cleanups registered against the new pool, or against sub-pools thereof, will not be executed during an invocation of apr_proc_create(), so resources created in an "unmanaged" pool hierarchy will leak to child processes.</dd></dl>
<p>Debug version of apr_pool_create_ex. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newpool</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__apr__pools.html#gaa7c40921aae156b665e82b0a66991a39">apr_pool_create</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__apr__pools.html#gaa7c40921aae156b665e82b0a66991a39">apr_pool_create</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">abort_fn</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__apr__pools.html#gaa7c40921aae156b665e82b0a66991a39">apr_pool_create</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__apr__pools.html#gaa7c40921aae156b665e82b0a66991a39">apr_pool_create</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file_line</td><td>Where the function is called from. This is usually APR_POOL__FILE_LINE__. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Only available when APR_POOL_DEBUG is defined. Call this directly if you have your apr_pool_create_ex calls in a wrapper function and wish to override the file_line argument to reflect the caller of your wrapper function. If you do not have apr_pool_create_ex in a wrapper, trust the macro and don't call apr_pool_create_ex_debug directly.</dd></dl>
<p>Debug version of apr_pool_create_core_ex. </p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000042">Deprecated:</a></b></dt><dd></dd></dl>
<dl class="section see"><dt>See also</dt><dd>apr_pool_create_unmanaged_ex_debug.</dd></dl>
<p>Debug version of apr_pool_create_unmanaged_ex. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newpool</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__apr__pools.html#ga03a06feb239bed9edd79a4f59679d56b">apr_pool_create_unmanaged</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">abort_fn</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__apr__pools.html#ga03a06feb239bed9edd79a4f59679d56b">apr_pool_create_unmanaged</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__apr__pools.html#ga03a06feb239bed9edd79a4f59679d56b">apr_pool_create_unmanaged</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file_line</td><td>Where the function is called from. This is usually APR_POOL__FILE_LINE__. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Only available when APR_POOL_DEBUG is defined. Call this directly if you have your apr_pool_create_unmanaged_ex calls in a wrapper function and wish to override the file_line argument to reflect the caller of your wrapper function. If you do not have apr_pool_create_core_ex in a wrapper, trust the macro and don't call apr_pool_create_core_ex_debug directly.</dd></dl>
<p>Determine if pool a is an ancestor of pool b. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The pool to search </td></tr>
    <tr><td class="paramname">b</td><td>The pool to search for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if a is an ancestor of b, NULL is considered an ancestor of all pools. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>if compiled with APR_POOL_DEBUG, this function will also return true if A is a pool which has been guaranteed by the caller (using apr_pool_join) to have a lifetime at least as long as some ancestor of pool B.</dd></dl>
<p>Set the data associated with the current pool </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The user data associated with the pool. </td></tr>
    <tr><td class="paramname">key</td><td>The key to use for association </td></tr>
    <tr><td class="paramname">cleanup</td><td>The cleanup program to use to cleanup the data (NULL if none) </td></tr>
    <tr><td class="paramname">pool</td><td>The current pool </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>The data to be attached to the pool should have a life span at least as long as the pool it is being attached to.</dd></dl>
<p>Users of APR must take EXTREME care when choosing a key to use for their data. It is possible to accidentally overwrite data by choosing a key that another part of the program is using. Therefore it is advised that steps are taken to ensure that unique keys are used for all of the userdata objects in a particular pool (the same key in two different pools or a pool and one of its subpools is okay) at all times. Careful namespace prefixing of key names is a typical way to help ensure this uniqueness.</p>
<p>Set the data associated with the current pool </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The user data associated with the pool. </td></tr>
    <tr><td class="paramname">key</td><td>The key to use for association </td></tr>
    <tr><td class="paramname">cleanup</td><td>The cleanup program to use to cleanup the data (NULL if none) </td></tr>
    <tr><td class="paramname">pool</td><td>The current pool </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>same as apr_pool_userdata_set(), except that this version doesn't make a copy of the key (this function is useful, for example, when the key is a string literal) </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This should NOT be used if the key could change addresses by any means between the apr_pool_userdata_setn() call and a subsequent apr_pool_userdata_get() on that key, such as if a static string is used as a userdata key in a DSO and the DSO could be unloaded and reloaded between the _setn() and the _get(). You MUST use apr_pool_userdata_set() in such cases. </dd>
<dd>
More generally, the key and the data to be attached to the pool should have a life span at least as long as the pool itself.</dd></dl>
<p>Return the data associated with the current pool. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The user data associated with the pool. </td></tr>
    <tr><td class="paramname">key</td><td>The key for the data to retrieve </td></tr>
    <tr><td class="paramname">pool</td><td>The current pool.</td></tr>
  </table>
  </dd>
</dl>
<p>convert the file from apr type to os specific type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thefile</td><td>The os specific file we are converting to </td></tr>
    <tr><td class="paramname">file</td><td>The apr file to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>On Unix, it is only possible to get a file descriptor from an apr file type.</dd></dl>
<p>convert the dir from apr type to os specific type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thedir</td><td>The os specific dir we are converting to </td></tr>
    <tr><td class="paramname">dir</td><td>The apr dir to convert.</td></tr>
  </table>
  </dd>
</dl>
<p>Convert the socket from an apr type to an OS specific socket </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thesock</td><td>The socket to convert. </td></tr>
    <tr><td class="paramname">sock</td><td>The os specific equivalent of the apr socket..</td></tr>
  </table>
  </dd>
</dl>
<p>Convert the proc mutex from apr type to os specific type </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ospmutex</td><td>The os specific proc mutex we are converting to. </td></tr>
    <tr><td class="paramname">pmutex</td><td>The apr proc mutex to convert.</td></tr>
  </table>
  </dd>
</dl>
<p>Convert the proc mutex from apr type to os specific type, also providing the mechanism used by the apr mutex. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ospmutex</td><td>The os specific proc mutex we are converting to. </td></tr>
    <tr><td class="paramname">pmutex</td><td>The apr proc mutex to convert. </td></tr>
    <tr><td class="paramname">mech</td><td>The mechanism used by the apr proc mutex (if not NULL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Allows for disambiguation for platforms with multiple mechanisms available.</dd></dl>
<p>Get the exploded time in the platforms native format. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ostime</td><td>the native time format </td></tr>
    <tr><td class="paramname">aprtime</td><td>the time to convert</td></tr>
  </table>
  </dd>
</dl>
<p>Get the imploded time in the platforms native format. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ostime</td><td>the native time format </td></tr>
    <tr><td class="paramname">aprtime</td><td>the time to convert</td></tr>
  </table>
  </dd>
</dl>
<p>convert the shm from apr type to os specific type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">osshm</td><td>The os specific shm representation </td></tr>
    <tr><td class="paramname">shm</td><td>The apr shm to convert.</td></tr>
  </table>
  </dd>
</dl>
<p>convert the thread to os specific type from apr type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thethd</td><td>The apr thread to convert </td></tr>
    <tr><td class="paramname">thd</td><td>The os specific thread we are converting to</td></tr>
  </table>
  </dd>
</dl>
<p>convert the thread private memory key to os specific type from an apr type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thekey</td><td>The apr handle we are converting from. </td></tr>
    <tr><td class="paramname">key</td><td>The os specific handle we are converting to.</td></tr>
  </table>
  </dd>
</dl>
<p>convert the thread from os specific type to apr type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>The apr thread we are converting to. </td></tr>
    <tr><td class="paramname">thethd</td><td>The os specific thread to convert </td></tr>
    <tr><td class="paramname">cont</td><td>The pool to use if it is needed.</td></tr>
  </table>
  </dd>
</dl>
<p>convert the thread private memory key from os specific type to apr type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The apr handle we are converting to. </td></tr>
    <tr><td class="paramname">thekey</td><td>The os specific handle to convert </td></tr>
    <tr><td class="paramname">cont</td><td>The pool to use if it is needed.</td></tr>
  </table>
  </dd>
</dl>
<p>Compare two thread id's </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tid1</td><td>1st Thread ID to compare </td></tr>
    <tr><td class="paramname">tid2</td><td>2nd Thread ID to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>non-zero if the two threads are equal, zero otherwise</dd></dl>
<p>convert the file from os specific type to apr type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>The apr file we are converting to. </td></tr>
    <tr><td class="paramname">thefile</td><td>The os specific file to convert </td></tr>
    <tr><td class="paramname">flags</td><td>The flags that were used to open this file. </td></tr>
    <tr><td class="paramname">cont</td><td>The pool to use if it is needed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>On Unix, it is only possible to put a file descriptor into an apr file type.</dd></dl>
<p>convert the file from os specific type to apr type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>The apr file we are converting to. </td></tr>
    <tr><td class="paramname">thefile</td><td>The os specific pipe to convert </td></tr>
    <tr><td class="paramname">cont</td><td>The pool to use if it is needed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>On Unix, it is only possible to put a file descriptor into an apr file type.</dd></dl>
<p>convert the file from os specific type to apr type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>The apr file we are converting to. </td></tr>
    <tr><td class="paramname">thefile</td><td>The os specific pipe to convert </td></tr>
    <tr><td class="paramname">register_cleanup</td><td>A cleanup will be registered on the <a class="el" href="structapr__file__t.html">apr_file_t</a> to issue apr_file_close(). </td></tr>
    <tr><td class="paramname">cont</td><td>The pool to use if it is needed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>On Unix, it is only possible to put a file descriptor into an apr file type.</dd></dl>
<p>convert the dir from os specific type to apr type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dir</td><td>The apr dir we are converting to. </td></tr>
    <tr><td class="paramname">thedir</td><td>The os specific dir to convert </td></tr>
    <tr><td class="paramname">cont</td><td>The pool to use when creating to apr directory.</td></tr>
  </table>
  </dd>
</dl>
<p>Convert a socket from the os specific type to the APR type. If sock points to NULL, a socket will be created from the pool provided. If **sock does not point to NULL, the structure pointed to by sock will be reused and updated with the given socket. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The pool to use. </td></tr>
    <tr><td class="paramname">thesock</td><td>The socket to convert to. </td></tr>
    <tr><td class="paramname">cont</td><td>The socket we are converting to an apr type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If it is a true socket, it is best to call <a class="el" href="unix_2sockets_8c.html#a5df9f6b1b9c07bfeca3685118760eefc">apr_os_sock_make()</a> and provide APR with more information about the socket.</dd></dl>
<p>Create a socket from an existing descriptor and local and remote socket addresses. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">apr_sock</td><td>The new socket that has been set up </td></tr>
    <tr><td class="paramname">os_sock_info</td><td>The os representation of the socket handle and other characteristics of the socket </td></tr>
    <tr><td class="paramname">cont</td><td>The pool to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If you only know the descriptor/handle or if it isn't really a true socket, use <a class="el" href="unix_2sockets_8c.html#a729bd6825dfadd814de2aa602462d838">apr_os_sock_put()</a> instead.</dd></dl>
<p>Convert the proc mutex from os specific type to apr type </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pmutex</td><td>The apr proc mutex we are converting to. </td></tr>
    <tr><td class="paramname">ospmutex</td><td>The os specific proc mutex to convert. </td></tr>
    <tr><td class="paramname">cont</td><td>The pool to use if it is needed.</td></tr>
  </table>
  </dd>
</dl>
<p>Convert the proc mutex from os specific type to apr type, using the specified mechanism. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pmutex</td><td>The apr proc mutex we are converting to. </td></tr>
    <tr><td class="paramname">ospmutex</td><td>The os specific proc mutex to convert. </td></tr>
    <tr><td class="paramname">mech</td><td>The apr mutex locking mechanism </td></tr>
    <tr><td class="paramname">register_cleanup</td><td>Whether to destroy the os mutex with the apr one (either on explicit destroy or pool cleanup). </td></tr>
    <tr><td class="paramname">cont</td><td>The pool to use if it is needed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Allows for disambiguation for platforms with multiple mechanisms available.</dd></dl>
<p>Put the imploded time in the APR format. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aprtime</td><td>the APR time format </td></tr>
    <tr><td class="paramname">ostime</td><td>the time to convert </td></tr>
    <tr><td class="paramname">cont</td><td>the pool to use if necessary</td></tr>
  </table>
  </dd>
</dl>
<p>Put the exploded time in the APR format. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aprtime</td><td>the APR time format </td></tr>
    <tr><td class="paramname">ostime</td><td>the time to convert </td></tr>
    <tr><td class="paramname">cont</td><td>the pool to use if necessary</td></tr>
  </table>
  </dd>
</dl>
<p>convert the shared memory from os specific type to apr type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shm</td><td>The apr shm representation of osshm </td></tr>
    <tr><td class="paramname">osshm</td><td>The os specific shm identity </td></tr>
    <tr><td class="paramname">cont</td><td>The pool to use if it is needed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>On fork()ed architectures, this is typically nothing more than the memory block mapped. On non-fork architectures, this is typically some internal handle to pass the mapping from process to process.</dd></dl>
<p>convert the dso handle from os specific to apr </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dso</td><td>The apr handle we are converting to </td></tr>
    <tr><td class="paramname">thedso</td><td>the os specific handle to convert </td></tr>
    <tr><td class="paramname">pool</td><td>the pool to use if it is needed</td></tr>
  </table>
  </dd>
</dl>
<p>convert the apr dso handle into an os specific one </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aprdso</td><td>The apr dso handle to convert </td></tr>
    <tr><td class="paramname">dso</td><td>The os specific dso to return</td></tr>
  </table>
  </dd>
</dl>
<p>Private: apr-util's apr_uuid module when supported by the platform</p>
<p>Create and initialize a mutex that can be used to synchronize processes. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>the memory address where the newly created mutex will be stored. </td></tr>
    <tr><td class="paramname">fname</td><td>A file name to use if the lock mechanism requires one. This argument should always be provided. The lock code itself will determine if it should be used. </td></tr>
    <tr><td class="paramname">mech</td><td>The mechanism to use for the interprocess lock, if any; one of <pre>
           APR_LOCK_FCNTL
           APR_LOCK_FLOCK
           APR_LOCK_SYSVSEM
           APR_LOCK_POSIXSEM
           APR_LOCK_PROC_PTHREAD
           APR_LOCK_DEFAULT     pick the default mechanism for the platform
</pre> </td></tr>
    <tr><td class="paramname">pool</td><td>the pool from which to allocate the mutex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__apr__proc__mutex.html#ga75dd95a48a1e855a87b509b522746ed4">apr_lockmech_e</a> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Check APR_HAS_foo_SERIALIZE defines to see if the platform supports APR_LOCK_foo. Only APR_LOCK_DEFAULT is portable.</dd></dl>
<p>Re-open a mutex in a child process. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>The newly re-opened mutex structure. </td></tr>
    <tr><td class="paramname">fname</td><td>A file name to use if the mutex mechanism requires one. This argument should always be provided. The mutex code itself will determine if it should be used. This filename should be the same one that was passed to apr_proc_mutex_create(). </td></tr>
    <tr><td class="paramname">pool</td><td>The pool to operate on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function must be called to maintain portability, even if the underlying lock mechanism does not require it.</dd></dl>
<p>Acquire the lock for the given mutex. If the mutex is already locked, the current thread will be put to sleep until the lock becomes available. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>the mutex on which to acquire the lock.</td></tr>
  </table>
  </dd>
</dl>
<p>Attempt to acquire the lock for the given mutex. If the mutex has already been acquired, the call returns immediately with APR_EBUSY. Note: it is important that the <a class="el" href="group__APR__STATUS__IS.html#gabb92ad7b6ef304132de70e9e5cbaa896">APR_STATUS_IS_EBUSY(s)</a> macro be used to determine if the return value was APR_EBUSY, for portability reasons. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>the mutex on which to attempt the lock acquiring.</td></tr>
  </table>
  </dd>
</dl>
<p>Release the lock for the given mutex. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>the mutex from which to release the lock.</td></tr>
  </table>
  </dd>
</dl>
<p>Destroy the mutex and free the memory associated with the lock. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>the mutex to destroy.</td></tr>
  </table>
  </dd>
</dl>
<p>Destroy the mutex and free the memory associated with the lock. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>the mutex to destroy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is generally used to kill a cleanup on an already created mutex</dd></dl>
<p>Generate cryptographically insecure random bytes. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>The RNG state </td></tr>
    <tr><td class="paramname">random</td><td>Buffer to fill with random bytes </td></tr>
    <tr><td class="paramname">bytes</td><td>Length of buffer in bytes</td></tr>
  </table>
  </dd>
</dl>
<p>Generate cryptographically secure random bytes. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>The RNG state </td></tr>
    <tr><td class="paramname">random</td><td>Buffer to fill with random bytes </td></tr>
    <tr><td class="paramname">bytes</td><td>Length of buffer in bytes</td></tr>
  </table>
  </dd>
</dl>
<p>Return APR_SUCCESS if the cryptographic PRNG has been seeded with enough data, APR_ENOTENOUGHENTROPY otherwise. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>The RNG state</td></tr>
  </table>
  </dd>
</dl>
<p>Return APR_SUCCESS if the PRNG has been seeded with enough data, APR_ENOTENOUGHENTROPY otherwise. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>The PRNG state</td></tr>
  </table>
  </dd>
</dl>
<p>Create and make accessible a shared memory segment with default properties. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The shared memory structure to create. </td></tr>
    <tr><td class="paramname">reqsize</td><td>The desired size of the segment. </td></tr>
    <tr><td class="paramname">filename</td><td>The file to use for shared memory on platforms that require it. </td></tr>
    <tr><td class="paramname">pool</td><td>the pool from which to allocate the shared memory structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>A note about Anonymous vs. Named shared memory segments: Not all plaforms support anonymous shared memory segments, but in some cases it is prefered over other types of shared memory implementations. Passing a NULL 'file' parameter to this function will cause the subsystem to use anonymous shared memory segments. If such a system is not available, APR_ENOTIMPL is returned. </dd>
<dd>
A note about allocation sizes: On some platforms it is necessary to store some metainformation about the segment within the actual segment. In order to supply the caller with the requested size it may be necessary for the implementation to request a slightly greater segment length from the subsystem. In all cases, the apr_shm_baseaddr_get() function will return the first usable byte of memory.</dd></dl>
<p>Create and make accessible a shared memory segment with platform- specific processing. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The shared memory structure to create. </td></tr>
    <tr><td class="paramname">reqsize</td><td>The desired size of the segment. </td></tr>
    <tr><td class="paramname">filename</td><td>The file to use for shared memory on platforms that require it. </td></tr>
    <tr><td class="paramname">pool</td><td>the pool from which to allocate the shared memory structure. </td></tr>
    <tr><td class="paramname">flags</td><td>mask of APR_SHM_* (defined above) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>A note about Anonymous vs. Named shared memory segments: Not all plaforms support anonymous shared memory segments, but in some cases it is prefered over other types of shared memory implementations. Passing a NULL 'file' parameter to this function will cause the subsystem to use anonymous shared memory segments. If such a system is not available, APR_ENOTIMPL is returned. </dd>
<dd>
A note about allocation sizes: On some platforms it is necessary to store some metainformation about the segment within the actual segment. In order to supply the caller with the requested size it may be necessary for the implementation to request a slightly greater segment length from the subsystem. In all cases, the apr_shm_baseaddr_get() function will return the first usable byte of memory.</dd></dl>
<p>Remove named resource associated with a shared memory segment, preventing attachments to the resource, but not destroying it. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The filename associated with shared-memory segment which needs to be removed </td></tr>
    <tr><td class="paramname">pool</td><td>The pool used for file operations </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function is only supported on platforms which support name-based shared memory segments, and will return APR_ENOTIMPL on platforms without such support. Removing the file while the shm is in use is not entirely portable, caller may use this to enhance obscurity of the resource, but be prepared for the call to fail, and for concurrent attempts to create a resource of the same name to also fail. The pool cleanup of apr_shm_create (apr_shm_destroy) also removes the named resource.</dd></dl>
<p>Delete named resource associated with a shared memory segment, preventing attachments to the resource. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The shared memory segment structure to delete. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function is only supported on platforms which support name-based shared memory segments, and will return APR_ENOTIMPL on platforms without such support. Removing the file while the shm is in use is not entirely portable, caller may use this to enhance obscurity of the resource, but be prepared for the call to fail, and for concurrent attempts to create a resource of the same name to also fail. The pool cleanup of apr_shm_create (apr_shm_destroy) also removes the named resource.</dd></dl>
<p>Destroy a shared memory segment and associated memory. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The shared memory segment structure to destroy.</td></tr>
  </table>
  </dd>
</dl>
<p>Attach to a shared memory segment that was created by another process. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The shared memory structure to create. </td></tr>
    <tr><td class="paramname">filename</td><td>The file used to create the original segment. (This MUST match the original filename.) </td></tr>
    <tr><td class="paramname">pool</td><td>the pool from which to allocate the shared memory structure for this process.</td></tr>
  </table>
  </dd>
</dl>
<p>Attach to a shared memory segment that was created by another process, with platform-specific processing. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The shared memory structure to create. </td></tr>
    <tr><td class="paramname">filename</td><td>The file used to create the original segment. (This MUST match the original filename.) </td></tr>
    <tr><td class="paramname">pool</td><td>the pool from which to allocate the shared memory structure for this process. </td></tr>
    <tr><td class="paramname">flags</td><td>mask of APR_SHM_* (defined above)</td></tr>
  </table>
  </dd>
</dl>
<p>Detach from a shared memory segment without destroying it. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The shared memory structure representing the segment to detach from.</td></tr>
  </table>
  </dd>
</dl>
<p>Allocate a new skip list </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sl</td><td>The pointer in which to return the newly created skip list </td></tr>
    <tr><td class="paramname">p</td><td>The pool from which to allocate the skip list (optional). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Unlike most APR functions, a pool is optional. If no pool is provided, the C standard library heap functions will be used instead.</dd></dl>
<p>Remove a node from the skip list. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sl</td><td>The skip list </td></tr>
    <tr><td class="paramname">iter</td><td>The skip list node to remove </td></tr>
    <tr><td class="paramname">myfree</td><td>A function to be called for the removed element</td></tr>
  </table>
  </dd>
</dl>
<p>Remove an element from the skip list using the specified comparison function for locating the element. In the case of duplicates, the 1st entry will be removed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sl</td><td>The skip list </td></tr>
    <tr><td class="paramname">data</td><td>The element to remove </td></tr>
    <tr><td class="paramname">myfree</td><td>A function to be called for each removed element </td></tr>
    <tr><td class="paramname">comp</td><td>The comparison function to use for placement into the skip list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the element is not found, 0 will be returned. Otherwise, the heightXXX will be returned.</dd></dl>
<p>Remove an element from the skip list using the existing comparison function for locating the element. In the case of duplicates, the 1st entry will be removed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sl</td><td>The skip list </td></tr>
    <tr><td class="paramname">data</td><td>The element to remove </td></tr>
    <tr><td class="paramname">myfree</td><td>A function to be called for each removed element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the element is not found, 0 will be returned. Otherwise, the heightXXX will be returned. </dd>
<dd>
If no comparison function has been set for the skip list, the element will not be removed and 0 will be returned.</dd></dl>
<p>Return the height of the list (number of skip paths), in O(1). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sl</td><td>The skip list</td></tr>
  </table>
  </dd>
</dl>
<p>Return the predefined maximum height of the skip list. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sl</td><td>The skip list</td></tr>
  </table>
  </dd>
</dl>
<p>Note: destroying a condition variable (or likewise, destroying or clearing the pool from which a condition variable was allocated) if any threads are blocked waiting on it gives undefined results. Create and initialize a condition variable that can be used to signal and schedule threads in a single process. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cond</td><td>the memory address where the newly created condition variable will be stored. </td></tr>
    <tr><td class="paramname">pool</td><td>the pool from which to allocate the condition.</td></tr>
  </table>
  </dd>
</dl>
<p>Put the active calling thread to sleep until signaled to wake up. Each condition variable must be associated with a mutex, and that mutex must be locked before calling this function, or the behavior will be undefined. As the calling thread is put to sleep, the given mutex will be simultaneously released; and as this thread wakes up the lock is again simultaneously acquired. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cond</td><td>the condition variable on which to block. </td></tr>
    <tr><td class="paramname">mutex</td><td>the mutex that must be locked upon entering this function, is released while the thread is asleep, and is again acquired before returning from this function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Spurious wakeups may occur. Before and after every call to wait on a condition variable, the caller should test whether the condition is already met.</dd></dl>
<p>Put the active calling thread to sleep until signaled to wake up or the timeout is reached. Each condition variable must be associated with a mutex, and that mutex must be locked before calling this function, or the behavior will be undefined. As the calling thread is put to sleep, the given mutex will be simultaneously released; and as this thread wakes up the lock is again simultaneously acquired. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cond</td><td>the condition variable on which to block. </td></tr>
    <tr><td class="paramname">mutex</td><td>the mutex that must be locked upon entering this function, is released while the thread is asleep, and is again acquired before returning from this function. </td></tr>
    <tr><td class="paramname">timeout</td><td>The amount of time in microseconds to wait. This is a maximum, not a minimum. If the condition is signaled, we will wake up before this time, otherwise the error APR_TIMEUP is returned.</td></tr>
  </table>
  </dd>
</dl>
<p>Signals a single thread, if one exists, that is blocking on the given condition variable. That thread is then scheduled to wake up and acquire the associated mutex. Although it is not required, if predictable scheduling is desired, that mutex must be locked while calling this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cond</td><td>the condition variable on which to produce the signal. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If no threads are waiting on the condition variable, nothing happens.</dd></dl>
<p>Signals all threads blocking on the given condition variable. Each thread that was signaled is then scheduled to wake up and acquire the associated mutex. This will happen in a serialized manner. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cond</td><td>the condition variable on which to produce the broadcast. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If no threads are waiting on the condition variable, nothing happens.</dd></dl>
<p>Destroy the condition variable and free the associated memory. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cond</td><td>the condition variable to destroy.</td></tr>
  </table>
  </dd>
</dl>
<p>Create and initialize a mutex that can be used to synchronize threads. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>the memory address where the newly created mutex will be stored. </td></tr>
    <tr><td class="paramname">flags</td><td>Or'ed value of: <pre>
          APR_THREAD_MUTEX_DEFAULT   platform-optimal lock behavior.
          APR_THREAD_MUTEX_NESTED    enable nested (recursive) locks.
          APR_THREAD_MUTEX_UNNESTED  disable nested locks (non-recursive).
</pre> </td></tr>
    <tr><td class="paramname">pool</td><td>the pool from which to allocate the mutex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Be cautious in using APR_THREAD_MUTEX_DEFAULT. While this is the most optimal mutex based on a given platform's performance characteristics, it will behave as either a nested or an unnested lock.</dd></dl>
<p>Acquire the lock for the given mutex. If the mutex is already locked, the current thread will be put to sleep until the lock becomes available. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>the mutex on which to acquire the lock.</td></tr>
  </table>
  </dd>
</dl>
<p>Attempt to acquire the lock for the given mutex. If the mutex has already been acquired, the call returns immediately with APR_EBUSY. Note: it is important that the <a class="el" href="group__APR__STATUS__IS.html#gabb92ad7b6ef304132de70e9e5cbaa896">APR_STATUS_IS_EBUSY(s)</a> macro be used to determine if the return value was APR_EBUSY, for portability reasons. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>the mutex on which to attempt the lock acquiring.</td></tr>
  </table>
  </dd>
</dl>
<p>Release the lock for the given mutex. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>the mutex from which to release the lock.</td></tr>
  </table>
  </dd>
</dl>
<p>Destroy the mutex and free the memory associated with the lock. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>the mutex to destroy.</td></tr>
  </table>
  </dd>
</dl>
<p>Create and initialize a new threadattr variable </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_attr</td><td>The newly created threadattr. </td></tr>
    <tr><td class="paramname">cont</td><td>The pool to use</td></tr>
  </table>
  </dd>
</dl>
<p>Set if newly created threads should be created in detached state. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr</td><td>The threadattr to affect </td></tr>
    <tr><td class="paramname">on</td><td>Non-zero if detached threads should be created.</td></tr>
  </table>
  </dd>
</dl>
<p>Get the detach state for this threadattr. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr</td><td>The threadattr to reference </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>APR_DETACH if threads are to be detached, or APR_NOTDETACH if threads are to be joinable.</dd></dl>
<p>Set the stack size of newly created threads. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr</td><td>The threadattr to affect </td></tr>
    <tr><td class="paramname">stacksize</td><td>The stack size in bytes</td></tr>
  </table>
  </dd>
</dl>
<p>Set the stack guard area size of newly created threads. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr</td><td>The threadattr to affect </td></tr>
    <tr><td class="paramname">guardsize</td><td>The stack guard area size in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Thread library implementations commonly use a "guard area" after each thread's stack which is not readable or writable such that stack overflows cause a segfault; this consumes e.g. 4K of memory and increases memory management overhead. Setting the guard area size to zero hence trades off reliable behaviour on stack overflow for performance.</dd></dl>
<p>Create a new thread of execution </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_thread</td><td>The newly created thread handle. </td></tr>
    <tr><td class="paramname">attr</td><td>The threadattr to use to determine how to create the thread </td></tr>
    <tr><td class="paramname">func</td><td>The function to start the new thread in </td></tr>
    <tr><td class="paramname">data</td><td>Any data to be passed to the starting function </td></tr>
    <tr><td class="paramname">cont</td><td>The pool to use</td></tr>
  </table>
  </dd>
</dl>
<p>stop the current thread </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>The thread to stop </td></tr>
    <tr><td class="paramname">retval</td><td>The return value to pass back to any thread that cares</td></tr>
  </table>
  </dd>
</dl>
<p>block until the desired thread stops executing. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">retval</td><td>The return value from the dead thread. </td></tr>
    <tr><td class="paramname">thd</td><td>The thread to join</td></tr>
  </table>
  </dd>
</dl>
<p>Initialize the control variable for apr_thread_once. If this isn't called, apr_initialize won't work. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">control</td><td>The control variable to initialize </td></tr>
    <tr><td class="paramname">p</td><td>The pool to allocate data from.</td></tr>
  </table>
  </dd>
</dl>
<p>Run the specified function one time, regardless of how many threads call it. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">control</td><td>The control variable. The same variable should be passed in each time the function is tried to be called. This is how the underlying functions determine if the function has ever been called before. </td></tr>
    <tr><td class="paramname">func</td><td>The function to call.</td></tr>
  </table>
  </dd>
</dl>
<p>detach a thread </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>The thread to detach</td></tr>
  </table>
  </dd>
</dl>
<p>Return user data associated with the current thread. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The user data associated with the thread. </td></tr>
    <tr><td class="paramname">key</td><td>The key to associate with the data </td></tr>
    <tr><td class="paramname">thread</td><td>The currently open thread.</td></tr>
  </table>
  </dd>
</dl>
<p>Set user data associated with the current thread. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The user data to associate with the thread. </td></tr>
    <tr><td class="paramname">key</td><td>The key to use for associating the data with the thread </td></tr>
    <tr><td class="paramname">cleanup</td><td>The cleanup routine to use when the thread is destroyed. </td></tr>
    <tr><td class="paramname">thread</td><td>The currently open thread.</td></tr>
  </table>
  </dd>
</dl>
<p>Create and initialize a new thread private address space </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The thread private handle. </td></tr>
    <tr><td class="paramname">dest</td><td>The destructor to use when freeing the private memory. </td></tr>
    <tr><td class="paramname">cont</td><td>The pool to use</td></tr>
  </table>
  </dd>
</dl>
<p>Get a pointer to the thread private memory </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_mem</td><td>The data stored in private memory </td></tr>
    <tr><td class="paramname">key</td><td>The handle for the desired thread private memory</td></tr>
  </table>
  </dd>
</dl>
<p>Set the data to be stored in thread private memory </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">priv</td><td>The data to be stored in private memory </td></tr>
    <tr><td class="paramname">key</td><td>The handle for the desired thread private memory</td></tr>
  </table>
  </dd>
</dl>
<p>Free the thread private memory </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The handle for the desired thread private memory</td></tr>
  </table>
  </dd>
</dl>
<p>Return the pool associated with the current threadkey. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The user data associated with the threadkey. </td></tr>
    <tr><td class="paramname">key</td><td>The key associated with the data </td></tr>
    <tr><td class="paramname">threadkey</td><td>The currently open threadkey.</td></tr>
  </table>
  </dd>
</dl>
<p>Return the pool associated with the current threadkey. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to set. </td></tr>
    <tr><td class="paramname">key</td><td>The key to associate with the data. </td></tr>
    <tr><td class="paramname">cleanup</td><td>The cleanup routine to use when the file is destroyed. </td></tr>
    <tr><td class="paramname">threadkey</td><td>The currently open threadkey.</td></tr>
  </table>
  </dd>
</dl>
<p>Create and initialize a new procattr variable </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_attr</td><td>The newly created procattr. </td></tr>
    <tr><td class="paramname">cont</td><td>The pool to use</td></tr>
  </table>
  </dd>
</dl>
<p>Determine if any of stdin, stdout, or stderr should be linked to pipes when starting a child process. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr</td><td>The procattr we care about. </td></tr>
    <tr><td class="paramname">in</td><td>Should stdin be a pipe back to the parent? </td></tr>
    <tr><td class="paramname">out</td><td>Should stdout be a pipe back to the parent? </td></tr>
    <tr><td class="paramname">err</td><td>Should stderr be a pipe back to the parent? </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If APR_NO_PIPE, there will be no special channel, the child inherits the parent's corresponding stdio stream. If APR_NO_FILE is specified, that corresponding stream is closed in the child (and will be INVALID_HANDLE_VALUE when inspected on Win32). This can have ugly side effects, as the next file opened in the child on Unix will fall into the stdio stream fd slot!</dd></dl>
<p>Set the child_in and/or parent_in values to existing <a class="el" href="structapr__file__t.html">apr_file_t</a> values. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr</td><td>The procattr we care about. </td></tr>
    <tr><td class="paramname">child_in</td><td><a class="el" href="structapr__file__t.html">apr_file_t</a> value to use as child_in. Must be a valid file. </td></tr>
    <tr><td class="paramname">parent_in</td><td><a class="el" href="structapr__file__t.html">apr_file_t</a> value to use as parent_in. Must be a valid file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This is NOT a required initializer function. This is useful if you have already opened a pipe (or multiple files) that you wish to use, perhaps persistently across multiple process invocations - such as a log file. You can save some extra function calls by not creating your own pipe since this creates one in the process space for you. </dd></dl>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000014">Bug:</a></b></dt><dd>Note that calling this function with two NULL files on some platforms creates an APR_FULL_BLOCK pipe, but this behavior is neither portable nor is it supported.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>apr_procattr_io_set instead for simple pipes.</dd></dl>
<p>Set the child_out and parent_out values to existing <a class="el" href="structapr__file__t.html">apr_file_t</a> values. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr</td><td>The procattr we care about. </td></tr>
    <tr><td class="paramname">child_out</td><td><a class="el" href="structapr__file__t.html">apr_file_t</a> value to use as child_out. Must be a valid file. </td></tr>
    <tr><td class="paramname">parent_out</td><td><a class="el" href="structapr__file__t.html">apr_file_t</a> value to use as parent_out. Must be a valid file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This is NOT a required initializer function. This is useful if you have already opened a pipe (or multiple files) that you wish to use, perhaps persistently across multiple process invocations - such as a log file. </dd></dl>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000015">Bug:</a></b></dt><dd>Note that calling this function with two NULL files on some platforms creates an APR_FULL_BLOCK pipe, but this behavior is neither portable nor is it supported.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>apr_procattr_io_set instead for simple pipes.</dd></dl>
<p>Set the child_err and parent_err values to existing <a class="el" href="structapr__file__t.html">apr_file_t</a> values. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr</td><td>The procattr we care about. </td></tr>
    <tr><td class="paramname">child_err</td><td><a class="el" href="structapr__file__t.html">apr_file_t</a> value to use as child_err. Must be a valid file. </td></tr>
    <tr><td class="paramname">parent_err</td><td><a class="el" href="structapr__file__t.html">apr_file_t</a> value to use as parent_err. Must be a valid file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This is NOT a required initializer function. This is useful if you have already opened a pipe (or multiple files) that you wish to use, perhaps persistently across multiple process invocations - such as a log file. </dd></dl>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000016">Bug:</a></b></dt><dd>Note that calling this function with two NULL files on some platforms creates an APR_FULL_BLOCK pipe, but this behavior is neither portable nor is it supported.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>apr_procattr_io_set instead for simple pipes.</dd></dl>
<p>Set which directory the child process should start executing in. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr</td><td>The procattr we care about. </td></tr>
    <tr><td class="paramname">dir</td><td>Which dir to start in. By default, this is the same dir as the parent currently resides in, when the createprocess call is made.</td></tr>
  </table>
  </dd>
</dl>
<p>Set what type of command the child process will call. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr</td><td>The procattr we care about. </td></tr>
    <tr><td class="paramname">cmd</td><td>The type of command. One of: <pre>
           APR_SHELLCMD     &ndash;  Anything that the shell can handle
           APR_PROGRAM      &ndash;  Executable program   (default) 
           APR_PROGRAM_ENV  &ndash;  Executable program, copy environment
           APR_PROGRAM_PATH &ndash;  Executable program on PATH, copy env
</pre></td></tr>
  </table>
  </dd>
</dl>
<p>Determine if the child should start in detached state. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr</td><td>The procattr we care about. </td></tr>
    <tr><td class="paramname">detach</td><td>Should the child start in detached state? Default is no.</td></tr>
  </table>
  </dd>
</dl>
<p>Set the Resource Utilization limits when starting a new process. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr</td><td>The procattr we care about. </td></tr>
    <tr><td class="paramname">what</td><td>Which limit to set, one of: <pre>
                APR_LIMIT_CPU
                APR_LIMIT_MEM
                APR_LIMIT_NPROC
                APR_LIMIT_NOFILE
</pre> </td></tr>
    <tr><td class="paramname">limit</td><td>Value to set the limit to.</td></tr>
  </table>
  </dd>
</dl>
<p>Specify an error function to be called in the child process if APR encounters an error in the child prior to running the specified program. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr</td><td>The procattr describing the child process to be created. </td></tr>
    <tr><td class="paramname">errfn</td><td>The function to call in the child process. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>At the present time, it will only be called from apr_proc_create() on platforms where fork() is used. It will never be called on other platforms, on those platforms apr_proc_create() will return the error in the parent process rather than invoke the callback in the now-forked child process.</dd></dl>
<p>Specify that apr_proc_create() should do whatever it can to report failures to the caller of apr_proc_create(), rather than find out in the child. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr</td><td>The procattr describing the child process to be created. </td></tr>
    <tr><td class="paramname">chk</td><td>Flag to indicate whether or not extra work should be done to try to report failures to the caller. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This flag only affects apr_proc_create() on platforms where fork() is used. This leads to extra overhead in the calling process, but that may help the application handle such errors more gracefully.</dd></dl>
<p>Determine if the child should start in its own address space or using the current one from its parent </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr</td><td>The procattr we care about. </td></tr>
    <tr><td class="paramname">addrspace</td><td>Should the child start in its own address space? Default is no on NetWare and yes on other platforms.</td></tr>
  </table>
  </dd>
</dl>
<p>Set the username used for running process </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr</td><td>The procattr we care about. </td></tr>
    <tr><td class="paramname">username</td><td>The username used </td></tr>
    <tr><td class="paramname">password</td><td>User password if needed. Password is needed on WIN32 or any other platform having APR_PROCATTR_USER_SET_REQUIRES_PASSWORD set.</td></tr>
  </table>
  </dd>
</dl>
<p>Set the group used for running process </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr</td><td>The procattr we care about. </td></tr>
    <tr><td class="paramname">groupname</td><td>The group name used</td></tr>
  </table>
  </dd>
</dl>
<p>Register permission set function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr</td><td>The procattr we care about. </td></tr>
    <tr><td class="paramname">perms_set_fn</td><td>Permission set callback </td></tr>
    <tr><td class="paramname">data</td><td>Data to pass to permission callback function </td></tr>
    <tr><td class="paramname">perms</td><td>Permissions to set</td></tr>
  </table>
  </dd>
</dl>
<p>This is currently the only non-portable call in APR. This executes a standard unix fork. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proc</td><td>The resulting process handle. </td></tr>
    <tr><td class="paramname">cont</td><td>The pool to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>returns APR_INCHILD for the child, and APR_INPARENT for the parent or an error.</dd></dl>
<p>Create a new process and execute a new program within that process. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_proc</td><td>The resulting process handle. </td></tr>
    <tr><td class="paramname">progname</td><td>The program to run </td></tr>
    <tr><td class="paramname">args</td><td>the arguments to pass to the new program. The first one should be the program name. </td></tr>
    <tr><td class="paramname">env</td><td>The new environment table for the new process. This should be a list of NULL-terminated strings. This argument is ignored for APR_PROGRAM_ENV, APR_PROGRAM_PATH, and APR_SHELLCMD_ENV types of commands. </td></tr>
    <tr><td class="paramname">attr</td><td>the procattr we should use to determine how to create the new process </td></tr>
    <tr><td class="paramname">pool</td><td>The pool to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function returns without waiting for the new process to terminate; use apr_proc_wait for that.</dd></dl>
<p>Wait for a child process to die </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proc</td><td>The process handle that corresponds to the desired child process </td></tr>
    <tr><td class="paramname">exitcode</td><td>The returned exit status of the child, if a child process dies, or the signal that caused the child to die. On platforms that don't support obtaining this information, the status parameter will be returned as APR_ENOTIMPL. </td></tr>
    <tr><td class="paramname">exitwhy</td><td>Why the child died, the bitwise or of: <pre>
           APR_PROC_EXIT         -- process terminated normally
           APR_PROC_SIGNAL       -- process was killed by a signal
           APR_PROC_SIGNAL_CORE  -- process was killed by a signal, and
                                    generated a core dump.
</pre> </td></tr>
    <tr><td class="paramname">waithow</td><td>How should we wait. One of: <pre>
           APR_WAIT   -- block until the child process dies.
           APR_NOWAIT -- return immediately regardless of if the 
                         child is dead or not.
</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The child's status is in the return code to this process. It is one of: <pre>
           APR_CHILD_DONE     &ndash; child is no longer running.
           APR_CHILD_NOTDONE  &ndash; child is still running.
</pre></dd></dl>
<p>Wait for any current child process to die and return information about that child. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proc</td><td>Pointer to NULL on entry, will be filled out with child's information </td></tr>
    <tr><td class="paramname">exitcode</td><td>The returned exit status of the child, if a child process dies, or the signal that caused the child to die. On platforms that don't support obtaining this information, the status parameter will be returned as APR_ENOTIMPL. </td></tr>
    <tr><td class="paramname">exitwhy</td><td>Why the child died, the bitwise or of: <pre>
           APR_PROC_EXIT         -- process terminated normally
           APR_PROC_SIGNAL       -- process was killed by a signal
           APR_PROC_SIGNAL_CORE  -- process was killed by a signal, and
                                    generated a core dump.
</pre> </td></tr>
    <tr><td class="paramname">waithow</td><td>How should we wait. One of: <pre>
           APR_WAIT   -- block until the child process dies.
           APR_NOWAIT -- return immediately regardless of if the 
                         child is dead or not.
</pre> </td></tr>
    <tr><td class="paramname">p</td><td>Pool to allocate child information out of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000017">Bug:</a></b></dt><dd>Passing proc as a *proc rather than **proc was an odd choice for some platforms... this should be revisited in 1.0 </dd></dl>
<p>Detach the process from the controlling terminal. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">daemonize</td><td>set to non-zero if the process should daemonize and become a background process, else it will stay in the foreground.</td></tr>
  </table>
  </dd>
</dl>
<p>Notify the maintenance callback of a registered other child process that application has detected an event, such as death. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proc</td><td>The process to check </td></tr>
    <tr><td class="paramname">reason</td><td>The reason code to pass to the maintenance function </td></tr>
    <tr><td class="paramname">status</td><td>The status to pass to the maintenance function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>An example of code using this behavior; <pre>
rv = apr_proc_wait_all_procs(&amp;proc, &amp;exitcode, &amp;status, APR_WAIT, p);
if (<a class="el" href="group__APR__STATUS__IS.html#ga1e6539dfa172cef4026105ca33b2b208">APR_STATUS_IS_CHILD_DONE(rv)</a>) {
#if APR_HAS_OTHER_CHILD
    if (apr_proc_other_child_alert(&amp;proc, APR_OC_REASON_DEATH, status)
            == APR_SUCCESS) {
        ;  (already handled)
    }
    else
#endif
        [... handling non-otherchild processes death ...]
</pre></dd></dl>
<p>Terminate a process. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">proc</td><td>The process to terminate. </td></tr>
    <tr><td class="paramname">sig</td><td>How to kill the process.</td></tr>
  </table>
  </dd>
</dl>
<p>Setup the process for a single thread to be used for all signal handling. </p><dl class="section warning"><dt>Warning</dt><dd>This must be called before any threads are created</dd></dl>
<p>Make the current thread listen for signals. This thread will loop forever, calling a provided function whenever it receives a signal. That functions should return 1 if the signal has been handled, 0 otherwise. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">signal_handler</td><td>The function to call when a signal is received apr_status_t apr_signal_thread((int)(*signal_handler)(int signum))</td></tr>
  </table>
  </dd>
</dl>
<p>Note: The following operations have undefined results: unlocking a read-write lock which is not locked in the calling thread; write locking a read-write lock which is already locked by the calling thread; destroying a read-write lock more than once; clearing or destroying the pool from which a <b>locked</b> read-write lock is allocated. Create and initialize a read-write lock that can be used to synchronize threads. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rwlock</td><td>the memory address where the newly created readwrite lock will be stored. </td></tr>
    <tr><td class="paramname">pool</td><td>the pool from which to allocate the mutex.</td></tr>
  </table>
  </dd>
</dl>
<p>Acquire a shared-read lock on the given read-write lock. This will allow multiple threads to enter the same critical section while they have acquired the read lock. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rwlock</td><td>the read-write lock on which to acquire the shared read.</td></tr>
  </table>
  </dd>
</dl>
<p>Attempt to acquire the shared-read lock on the given read-write lock. This is the same as apr_thread_rwlock_rdlock(), only that the function fails if there is another thread holding the write lock, or if there are any write threads blocking on the lock. If the function fails for this case, APR_EBUSY will be returned. Note: it is important that the <a class="el" href="group__APR__STATUS__IS.html#gabb92ad7b6ef304132de70e9e5cbaa896">APR_STATUS_IS_EBUSY(s)</a> macro be used to determine if the return value was APR_EBUSY, for portability reasons. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rwlock</td><td>the rwlock on which to attempt the shared read.</td></tr>
  </table>
  </dd>
</dl>
<p>Acquire an exclusive-write lock on the given read-write lock. This will allow only one single thread to enter the critical sections. If there are any threads currently holding the read-lock, this thread is put to sleep until it can have exclusive access to the lock. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rwlock</td><td>the read-write lock on which to acquire the exclusive write.</td></tr>
  </table>
  </dd>
</dl>
<p>Attempt to acquire the exclusive-write lock on the given read-write lock. This is the same as apr_thread_rwlock_wrlock(), only that the function fails if there is any other thread holding the lock (for reading or writing), in which case the function will return APR_EBUSY. Note: it is important that the <a class="el" href="group__APR__STATUS__IS.html#gabb92ad7b6ef304132de70e9e5cbaa896">APR_STATUS_IS_EBUSY(s)</a> macro be used to determine if the return value was APR_EBUSY, for portability reasons. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rwlock</td><td>the rwlock on which to attempt the exclusive write.</td></tr>
  </table>
  </dd>
</dl>
<p>Release either the read or write lock currently held by the calling thread associated with the given read-write lock. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rwlock</td><td>the read-write lock to be released (unlocked).</td></tr>
  </table>
  </dd>
</dl>
<p>Destroy the read-write lock and free the associated memory. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rwlock</td><td>the rwlock to destroy.</td></tr>
  </table>
  </dd>
</dl>
<p>Convert an ansi time_t to an apr_time_t </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>the resulting apr_time_t </td></tr>
    <tr><td class="paramname">input</td><td>the time_t to convert</td></tr>
  </table>
  </dd>
</dl>
<p>Convert a time to its human readable components using an offset from GMT. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>the exploded time </td></tr>
    <tr><td class="paramname">input</td><td>the time to explode </td></tr>
    <tr><td class="paramname">offs</td><td>the number of seconds offset to apply</td></tr>
  </table>
  </dd>
</dl>
<p>Convert a time to its human readable components (GMT). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>the exploded time </td></tr>
    <tr><td class="paramname">input</td><td>the time to explode</td></tr>
  </table>
  </dd>
</dl>
<p>Convert a time to its human readable components in the local timezone. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>the exploded time </td></tr>
    <tr><td class="paramname">input</td><td>the time to explode</td></tr>
  </table>
  </dd>
</dl>
<p>Convert time value from human readable format to a numeric apr_time_t (elapsed microseconds since the epoch). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>the resulting imploded time </td></tr>
    <tr><td class="paramname">input</td><td>the input exploded time</td></tr>
  </table>
  </dd>
</dl>
<p>Convert time value from human readable format to a numeric apr_time_t that always represents GMT. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>the resulting imploded time </td></tr>
    <tr><td class="paramname">input</td><td>the input exploded time</td></tr>
  </table>
  </dd>
</dl>
<p>apr_rfc822_date formats dates in the RFC822 format in an efficient manner. It is a fixed length format which requires APR_RFC822_DATA_LEN bytes of storage, including the trailing NUL terminator. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">date_str</td><td>String to write to. </td></tr>
    <tr><td class="paramname">t</td><td>the time to convert</td></tr>
  </table>
  </dd>
</dl>
<p>apr_ctime formats dates in the ctime() format in an efficient manner. It is a fixed length format and requires APR_CTIME_LEN bytes of storage including the trailing NUL terminator. Unlike ANSI/ISO C ctime(), <a class="el" href="unix_2timestr_8c.html#ad1fcb8f26d508fbb34ea2beca7bc851e">apr_ctime()</a> does not include a \n at the end of the string. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">date_str</td><td>String to write to. </td></tr>
    <tr><td class="paramname">t</td><td>the time to convert</td></tr>
  </table>
  </dd>
</dl>
<p>Formats the exploded time according to the format specified </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>string to write to </td></tr>
    <tr><td class="paramname">retsize</td><td>The length of the returned string </td></tr>
    <tr><td class="paramname">max</td><td>The maximum length of the string </td></tr>
    <tr><td class="paramname">format</td><td>The format for the time string </td></tr>
    <tr><td class="paramname">tm</td><td>The time to convert</td></tr>
  </table>
  </dd>
</dl>
<p>Get the userid (and groupid) of the calling process </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">userid</td><td>Returns the user id </td></tr>
    <tr><td class="paramname">groupid</td><td>Returns the user's group id </td></tr>
    <tr><td class="paramname">p</td><td>The pool from which to allocate working space </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function is available only if APR_HAS_USER is defined.</dd></dl>
<p>Get the user name for a specified userid </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">username</td><td>Pointer to new string containing user name (on output) </td></tr>
    <tr><td class="paramname">userid</td><td>The userid </td></tr>
    <tr><td class="paramname">p</td><td>The pool from which to allocate the string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function is available only if APR_HAS_USER is defined.</dd></dl>
<p>Get the userid (and groupid) for the specified username </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">userid</td><td>Returns the user id </td></tr>
    <tr><td class="paramname">groupid</td><td>Returns the user's group id </td></tr>
    <tr><td class="paramname">username</td><td>The username to look up </td></tr>
    <tr><td class="paramname">p</td><td>The pool from which to allocate working space </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function is available only if APR_HAS_USER is defined.</dd></dl>
<p>Get the home directory for the named user </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dirname</td><td>Pointer to new string containing directory name (on output) </td></tr>
    <tr><td class="paramname">username</td><td>The named user </td></tr>
    <tr><td class="paramname">p</td><td>The pool from which to allocate the string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function is available only if APR_HAS_USER is defined.</dd></dl>
<p>Get the group name for a specified groupid </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">groupname</td><td>Pointer to new string containing group name (on output) </td></tr>
    <tr><td class="paramname">groupid</td><td>The groupid </td></tr>
    <tr><td class="paramname">p</td><td>The pool from which to allocate the string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function is available only if APR_HAS_USER is defined.</dd></dl>
<p>Get the groupid for a specified group name </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">groupid</td><td>Pointer to the group id (on output) </td></tr>
    <tr><td class="paramname">groupname</td><td>The group name to look up </td></tr>
    <tr><td class="paramname">p</td><td>The pool from which to allocate the string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function is available only if APR_HAS_USER is defined. </dd></dl>
<p>The problem with trying to output the entire iovec is that we cannot maintain the behaviour that a real writev would have. If we iterate over the iovec one at a time, we lose the atomic properties of <a class="el" href="apr__arch__os2calls_8h.html#a3d0f3996136a9b5ab46431c60c746efd">writev()</a>. The other option is to combine the entire iovec into one buffer that we could then send in one call to write(). This is not reasonable since we do not know how much data an iovec could contain.</p>
<p>The only reasonable option, that maintains the semantics of a real <a class="el" href="apr__arch__os2calls_8h.html#a3d0f3996136a9b5ab46431c60c746efd">writev()</a>, is to only write the first iovec. Callers of file_writev() must deal with partial writes as they normally would. If you want to ensure an entire iovec is written, use apr_file_writev_full().</p>
<div class="fragment"><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;{</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="group__apr__errno.html#ga9ee311b7bf1c691dc521d721339ee2a6">APR_SUCCESS</a>;</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;}</div><div class="ttc" id="group__apr__errno_html_ga9ee311b7bf1c691dc521d721339ee2a6"><div class="ttname"><a href="group__apr__errno.html#ga9ee311b7bf1c691dc521d721339ee2a6">APR_SUCCESS</a></div><div class="ttdeci">#define APR_SUCCESS</div><div class="ttdef"><b>Definition:</b> apr_errno.h:225</div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="gab3ed16bee8def122c1d7c8f822ee0a5e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">APR_DECLARE </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__MOD__ISAPI.html#gacd6cdbf73df3d9eed42fa493d9b621a6">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destroy an allocator </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td>The allocator to be destroyed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Any memnodes not given back to the allocator prior to destroying will <em>not</em> be <a class="el" href="util__expr__parse_8c.html#af07d89f5ceaea0c7c8252cc41fd75f37">free()</a>d.</dd></dl>
<p>Free a list of blocks of mem, giving them back to the allocator. The list is typically terminated by a memnode with its next field set to NULL. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td>The allocator to give the mem back to </td></tr>
    <tr><td class="paramname">memnode</td><td>The memory node to return</td></tr>
  </table>
  </dd>
</dl>
<p>Set the owner of the allocator </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td>The allocator to set the owner for </td></tr>
    <tr><td class="paramname">pool</td><td>The pool that is to own the allocator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Typically pool is the highest level pool using the allocator</dd></dl>
<p>Set the current threshold at which the allocator should start giving blocks back to the system. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td>The allocator to set the threshold on </td></tr>
    <tr><td class="paramname">size</td><td>The threshold. 0 == unlimited.</td></tr>
  </table>
  </dd>
</dl>
<p>Set a mutex for the allocator to use </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td>The allocator to set the mutex for </td></tr>
    <tr><td class="paramname">mutex</td><td>The mutex </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;{</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;    atomic_sub((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *)<a class="code" href="group__MOD__DAV.html#gac8d0feaae3f1c6b0eac72aaa9af557c1">mem</a>,(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)<a class="code" href="group__APACHE__CORE__CONFIG.html#gae553dcb033cb5c1e269683855e4f676a">val</a>);</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;}</div><div class="ttc" id="group__APACHE__CORE__CONFIG_html_gae553dcb033cb5c1e269683855e4f676a"><div class="ttname"><a href="group__APACHE__CORE__CONFIG.html#gae553dcb033cb5c1e269683855e4f676a">val</a></div><div class="ttdeci">const module void * val</div><div class="ttdef"><b>Definition:</b> http_config.h:526</div></div>
<div class="ttc" id="group__MOD__DAV_html_gac8d0feaae3f1c6b0eac72aaa9af557c1"><div class="ttname"><a href="group__MOD__DAV.html#gac8d0feaae3f1c6b0eac72aaa9af557c1">mem</a></div><div class="ttdeci">dav_buffer const void * mem</div><div class="ttdef"><b>Definition:</b> mod_dav.h:471</div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ga1a358d9857909db42118ab336d2ed241"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">APR_DECLARE </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapr__memnode__t.html">apr_memnode_t</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocate a block of mem from the allocator </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td>The allocator to allocate from </td></tr>
    <tr><td class="paramname">size</td><td>The size of the mem to allocate (excluding the memnode structure) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1f88d1052393c7c22c1e2e2fef1c1067"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">APR_DECLARE </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apr__platform.html#gaaa72b2253f6f3032cefea5712a27540e">apr_size_t</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the true size that would be allocated for the given size (including the header and alignment). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The allocator from which to the memory would be allocated </td></tr>
    <tr><td class="paramname">size</td><td>The size to align </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The aligned size (or zero on apr_size_t overflow) </dd></dl>
<div class="fragment"><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;{</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="group__APACHE__CORE__LOG.html#ga52f984475a42d9227fcbfd159db35676">file</a>-&gt;bufsize;</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;}</div><div class="ttc" id="group__APACHE__CORE__LOG_html_ga52f984475a42d9227fcbfd159db35676"><div class="ttname"><a href="group__APACHE__CORE__LOG.html#ga52f984475a42d9227fcbfd159db35676">file</a></div><div class="ttdeci">const char * file</div><div class="ttdef"><b>Definition:</b> http_log.h:297</div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="gac5bd5875da60b3e97573ba81258cfd69"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">APR_DECLARE </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapr__pool__t.html">apr_pool_t</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the current owner of the allocator </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td>The allocator to get the owner from </td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;{</div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="group__apr__pools.html#ga3d4c7b6ba19a3b46b6fecdee3d867787">allocator</a>-&gt;<a class="code" href="structapr__allocator__t.html#a7765c4164197b52893dc4523e3104429">owner</a>;</div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;}</div><div class="ttc" id="structapr__allocator__t_html_a7765c4164197b52893dc4523e3104429"><div class="ttname"><a href="structapr__allocator__t.html#a7765c4164197b52893dc4523e3104429">apr_allocator_t::owner</a></div><div class="ttdeci">apr_pool_t * owner</div><div class="ttdef"><b>Definition:</b> apr_pools.c:142</div></div>
<div class="ttc" id="group__apr__pools_html_ga3d4c7b6ba19a3b46b6fecdee3d867787"><div class="ttname"><a href="group__apr__pools.html#ga3d4c7b6ba19a3b46b6fecdee3d867787">allocator</a></div><div class="ttdeci">apr_abortfunc_t apr_allocator_t * allocator</div><div class="ttdef"><b>Definition:</b> apr_pools.h:207</div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="gae93b7565ed822cd38dea54dbaf6141b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">APR_DECLARE </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapr__thread__mutex__t.html">apr_thread_mutex_t</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the mutex currently set for the allocator </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td>The allocator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="ga5f598d678d0ca77c25732a145c68d3c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__apr__platform.html#gaaa72b2253f6f3032cefea5712a27540e">apr_size_t</a> size</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
